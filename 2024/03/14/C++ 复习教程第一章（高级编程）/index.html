

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="yanhuigang">
  <meta name="keywords" content="">
  
    <meta name="description" content="C++ 高级编程 如果只想学习高级方法，那么就请看第 9 章的零规则，就可以知道，前面的努力很大程度上都只是在为了迁就一些较为落后的代码语法。前面的很重要但不必要！！！ 2.7 和 8.1 &#x2F; 3 的区别，记住比较两个浮点数的大小仅关注极小误差量！！！ 第1章 —— C++ 和标准库速成 1.1	C++ 基础知识 1.1	小程序 “hello world” 123456789&#x2F;&#x2F; hel">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 复习教程第一章（C++ 和标准库速成）">
<meta property="og:url" content="http://example.com/2024/03/14/C++%20%E5%A4%8D%E4%B9%A0%E6%95%99%E7%A8%8B%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%88%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%89/index.html">
<meta property="og:site_name" content="yanhuigang&#39;s blog">
<meta property="og:description" content="C++ 高级编程 如果只想学习高级方法，那么就请看第 9 章的零规则，就可以知道，前面的努力很大程度上都只是在为了迁就一些较为落后的代码语法。前面的很重要但不必要！！！ 2.7 和 8.1 &#x2F; 3 的区别，记住比较两个浮点数的大小仅关注极小误差量！！！ 第1章 —— C++ 和标准库速成 1.1	C++ 基础知识 1.1	小程序 “hello world” 123456789&#x2F;&#x2F; hel">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2024/02/09/xEkmeJX9yhDoYid.png">
<meta property="article:published_time" content="2024-03-14T10:18:20.000Z">
<meta property="article:modified_time" content="2024-03-15T12:19:34.862Z">
<meta property="article:author" content="yanhuigang">
<meta property="article:tag" content="编程">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://s2.loli.net/2024/02/09/xEkmeJX9yhDoYid.png">
  
  
  
  <title>C++ 复习教程第一章（C++ 和标准库速成） - yanhuigang&#39;s blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.7","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>yanhuigang&#39;s blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="C++ 复习教程第一章（C++ 和标准库速成）"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-03-14 18:18" pubdate>
          2024年3月14日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          22k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          180 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">C++ 复习教程第一章（C++ 和标准库速成）</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="C-高级编程"><a href="#C-高级编程" class="headerlink" title="C++ 高级编程"></a><em><strong>C++ 高级编程</strong></em></h1><hr>
<p>如果只想学习高级方法，那么就请看第 9 章的零规则，就可以知道，前面的努力很大程度上都只是在为了迁就一些较为落后的代码语法。前面的很重要但不必要！！！</p>
<p>2.7 和 8.1 &#x2F; 3 的区别，记住比较两个浮点数的大小仅关注极小误差量！！！</p>
<h2 id="第1章-——-C-和标准库速成"><a href="#第1章-——-C-和标准库速成" class="headerlink" title="第1章 —— C++ 和标准库速成"></a><strong>第1章 —— C++ 和标准库速成</strong></h2><hr>
<h3 id="1-1C-基础知识"><a href="#1-1C-基础知识" class="headerlink" title="1.1	C++ 基础知识"></a><strong>1.1	C++ 基础知识</strong></h3><hr>
<h4 id="1-1小程序-“hello-world”"><a href="#1-1小程序-“hello-world”" class="headerlink" title="1.1	小程序 “hello world”"></a><strong>1.1	小程序 “hello world”</strong></h4><hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// helloworld.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h5 id="1-注释"><a href="#1-注释" class="headerlink" title="1.注释"></a>1.注释</h5><blockquote>
<ul>
<li>单行注释，使用    <strong>&#x2F;&#x2F;</strong>    符；</li>
<li>多行注释，使用    <strong>&#x2F;*    *&#x2F;</strong>    符；</li>
</ul>
</blockquote>
<hr>
<h5 id="2-预处理指令"><a href="#2-预处理指令" class="headerlink" title="2.预处理指令"></a>2.预处理指令</h5><blockquote>
<ul>
<li><p>生成一个 C++ 程序共有三步：</p>
<blockquote>
<ul>
<li><p>首先，代码在预处理器中运行，预处理器会识别代码中的 <em><em>元信息</em>(meta-information)</em>**;</p>
</li>
<li><p>其次，代码被编译或转换为计算机可识别的目标文件；</p>
</li>
<li><p>最后，独立的目标文件被连接在一起变成一个目标文件；</p>
</li>
</ul>
</blockquote>
</li>
<li><p>预处理指令以    <strong>#</strong>    字符开始；</p>
</li>
<li><p><strong>include</strong> 指令告诉预处理器：提取    <strong><code>&lt;iostream&gt;</code></strong>    头文件中的所有内容并提供给当前文件；</p>
<blockquote>
<ul>
<li>头文件，最常见的用途是定义在其他位置的函数，<strong>函数声明</strong>会通知编译器如何调用这个函数，并声明函数中参数的个数和类型，以及函数的返回类型。而函数定义包含这个函数的实际代码；</li>
<li>在 C++ 中，<strong>声明</strong>通常放在扩展名为    <strong><code>.h</code></strong>    的文件中，称为头文件；</li>
<li>在 C++ 中，<strong>定义</strong>通常包含在扩展名为    <strong><code>.cpp</code></strong>    的文件中，称为源文件；</li>
<li><strong><code>&lt;iostream&gt;</code></strong>    头文件声明了 C++ 如何提供输入输出机制，如果程序没有包含这个头文件，甚至无法执行器仅需要完成的输入输出文本；</li>
</ul>
</blockquote>
</li>
<li><p>注意：</p>
<blockquote>
<ul>
<li><p>在 C 中，标准库头文件以    <strong><code>.h</code></strong>    结尾，如    <strong><code>&lt;stdio.h&gt;</code></strong>    ，不使用名称空间；</p>
</li>
<li><p>在 C++ 中，标准库头文件以    <strong><code>.h</code></strong>    结尾，如    <strong><code>&lt;iostream&gt;</code></strong>    ,所有文件都在 <strong><code>std</code></strong> 名称空间和 <strong><code>std</code></strong> 的子名称空间中定义；</p>
</li>
<li><p>C 中的标准库头文件在 C++ 中依然存在，但是使用以下两个版本：</p>
<ol>
<li><p>不使用    <strong><code>.h</code></strong>    后缀，改用前缀    **<code>c</code>**；</p>
<blockquote>
<p>这是新版本，也是推荐使用的版本。这些版本将一切放在     <strong><code>std</code></strong>    名称空间中，如    **<code>&lt;cstdio&gt;</code>**；</p>
</blockquote>
</li>
<li><p>使用    <strong><code>.h</code></strong>    后缀；</p>
<blockquote>
<p>这是旧版本，这些版本不使用名称空间，如    **<code>&lt;stdio.h&gt;</code>**；</p>
</blockquote>
</li>
</ol>
</li>
</ul>
</blockquote>
</li>
<li><p>常见预处理指令</p>
<blockquote>
<ul>
<li><pre><code class="C++">#include [filename]
// 将指定的文件插入代码指令虽在的位置；
// 几乎总是用来包含头文件，是代码可使用在其他位置定义的功能；
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><br><span class="hljs-selector-tag">-</span> ```<span class="hljs-selector-tag">c</span>++<br>  <span class="hljs-selector-id">#define</span> <span class="hljs-selector-attr">[key]</span> <span class="hljs-selector-attr">[value]</span><br>  <span class="hljs-comment">// 每个指定的 key 都被替换为指定的 value；</span><br>  <span class="hljs-comment">// 在 C 中，常用来定义常数值或宏；</span><br>  <span class="hljs-comment">// 在 C++ 中，提供了常数和大多数宏类型的更好机制，此外，宏的使用具有一定风险，故谨慎使用；</span><br></code></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code class="c++">#ifdef [key]
#endif
    
#ifndef [key]
#endif
// ifdef(&quot;if defined&quot;) 块或 ifndef(&quot;if not defined&quot;) 块中的代码被有条件地包含或者舍弃；
// 上述保留或舍弃取决于是否使用 #define 定义了指令的 key；
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><br>- ```C++<br>  pragma [<span class="hljs-built_in">xyz</span>]<br>  <span class="hljs-comment">// xyz 因编译器而异；</span><br>  <span class="hljs-comment">// 如果在预处理期间执行到这一指令通常会显示一条警告或错误信息；</span><br></code></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>下面是使用预处理指令避免重复包含的示例：</p>
<ul>
<li><pre><code class="c++">#ifndef MYHEADER_H
#define MYHEADER_H
// ... the contents of this header file
#endif
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>- ```c++<br>  <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br>  <span class="hljs-comment">// ... the contents of this header file</span><br></code></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>上述两段代码起到的效果相同；</p>
</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<hr>
<h5 id="3-main-函数"><a href="#3-main-函数" class="headerlink" title="3.main() 函数"></a><strong>3.main()</strong> 函数</h5><blockquote>
<ul>
<li><p>main()    函数是程序的入口。</p>
</li>
<li><p>main()    函数返回一个    int    值以指示程序的最终执行状态。</p>
</li>
<li><p>main()    函数中，可忽略显式的    <strong><code>return</code></strong>    语句，此时，会自动返回    0；</p>
</li>
<li><p>main()    函数只有两种参数设置：</p>
<ol>
<li><pre><code class="c++">int main()
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-number">2.</span> ```c++<br>   <span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span><br></code></pre></td></tr></table></figure>

&gt; **`argc`**    给出了传递给程序的实参数目，**`argv`**    包含了这些参数；
&gt;
&gt; 注意：
&gt;
&gt; ​	**`argv[0]`**    可能是程序的名称，也可能是空字符串，但不应依赖它，相反，应当使用特定于平台的功能来检索程序名。重要是记住，实际参数从索引    1    开始；
</code></pre>
</li>
</ol>
</li>
</ul>
</blockquote>
<hr>
<h5 id="4-输入输出流"><a href="#4-输入输出流" class="headerlink" title="4.输入输出流"></a>4.输入输出流</h5><blockquote>
<p>可以将输出流想象为针对数据的*<em>洗衣滑槽</em>(chute)***；</p>
<blockquote>
<p>放入其中的任何内容都可以被正确地输出</p>
</blockquote>
<ol>
<li><p><strong><code>std::cout</code></strong> </p>
<blockquote>
<p>对应用户控制台或标准输出的滑槽；</p>
<p>&lt;&lt;	用于将信息放入滑槽中；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;There are &quot;</span> &lt;&lt; <span class="hljs-number">219</span> &lt;&lt; <span class="hljs-string">&quot; ways.&quot;</span><br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>


</blockquote>
</li>
<li><p><strong><code>std::cerr</code></strong></p>
<blockquote>
<p>对应输出错误信息的滑槽；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	std::cerr &lt;&lt; <span class="hljs-string">&quot;Not right!&quot;</span>;<br>	<span class="hljs-comment">// 用于对错误信息的输出；</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>


</blockquote>
</li>
<li><p><strong><code>std::endl</code></strong></p>
<blockquote>
<p>用于表示序列的结尾，相当于 \n</p>
<p>此外常见的转义字符有：</p>
<p>​	\n	换行</p>
<p>​	\r	回车</p>
<p>​	\t	制表符</p>
<p>​	\\	反斜杠字符</p>
<p>​	\&quot;	引号</p>
</blockquote>
</li>
<li><p><strong><code>std::cin</code></strong></p>
<blockquote>
<p>用于接收用户的输入，最简单的方法就是在输入流中使用    &gt;&gt;    运算符；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> value;<br>	std::cin &gt;&gt; value;<br>	<span class="hljs-comment">// 由于永远不知道用户会输入什么类型的数据，因此需慎重对待用户的输入；</span><br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意：</p>
<p>​	在 C 中使用的    printf()    和    scanf()    未提供类型安全，虽然，在 C++ 中仍然使用    printf()，但，仍建议改用流库，更安全；</p>
</blockquote>
</li>
</ol>
</blockquote>
<hr>
<h4 id="1-2名称空间"><a href="#1-2名称空间" class="headerlink" title="1.2	名称空间"></a><strong>1.2	名称空间</strong></h4><hr>
<h5 id="1-名称空间"><a href="#1-名称空间" class="headerlink" title="1.名称空间"></a>1.名称空间</h5><p>​	名称空间，用于处理不同代码之间的名称冲突问题；</p>
<blockquote>
<p>例如，用户自己编辑了一段代码，其中有一个名为    foo()    的函数，但是，有一天，用户决定使用第三方库中，其中也有一个函数名为    foo()，这时编辑器无法自行判断你的代码要使用哪个版本的的    foo()    函数，库名称无法改变，而改变自己代码中函数名称又十分麻烦；</p>
<p>上述情况，可以使用名称空间来解决，使用名称空间来指定定义名称的环境，为某段代码加入名称空间可使用    namespace    块将其包含其中。例如，可在    namespaces.h    声明函数示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// namespace.h</span><br><span class="hljs-keyword">namespace</span> mycode<br>&#123;<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-comment">// 可以看到，这里的 mycode 实际上是 namespace 类的一个实例化</span><br></code></pre></td></tr></table></figure>

<p>在名称空间中还可以实现方法或函数，例如，foo()    函数可在    namespaces.cpp    中实现，下给出示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// namespaces.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;namespaces.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mycode::foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;foo() named in the mycode namespace.&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;namespaces.h&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> mycode<br>&#123;<br>	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function">	</span>&#123;<br>		std::cout &lt;&lt; <span class="hljs-string">&quot;foo() called in the mycode namespace.&quot;</span> &lt;&lt; std::endl;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这样，就能够将用户书写的    foo()    函数与第三方库的    foo()    函数区分，使用以下调用方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">mycode::<span class="hljs-built_in">foo</span>();<br><span class="hljs-comment">// 其中，    ::    符称为作用域解析运算符；</span><br><span class="hljs-comment">// mycode    名称空间中的任何代码都可以调用该名称空间中的其他代码，而不需要显式地说明该名称空间；</span><br><br><span class="hljs-comment">// 如果出现名称空间过长的情况，可使用以下方法：</span><br><span class="hljs-keyword">namespace</span> mynamespace = namespace_top::namespace_middle::naespace_bottom;<br>mynamespaces::<span class="hljs-built_in">foo</span>();<br><span class="hljs-comment">// 即，使用同名来化简</span><br></code></pre></td></tr></table></figure>
</blockquote>
<hr>
<h5 id="2-using-指令："><a href="#2-using-指令：" class="headerlink" title="2.using    指令："></a><strong>2.<code>using</code></strong>    指令：</h5><blockquote>
<ul>
<li><p>可以避免预先指明命名空间，使得代码清晰并且易于阅读；</p>
</li>
<li><p>该指令通知编译器，后面的代码将使用指定名称空间中的名称；</p>
<blockquote>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;namespaces.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> mycode</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">foo</span>();<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>虽然，一个源文件中可以包含多条    <strong><code>using</code></strong>    指令，但是这种方法虽然便捷，但是注意不要过度使用！</p>
<p><strong>注意：</strong></p>
<p>​	<strong>极端情况下，如果你使用了已知的所有名称空间，实际上，就是完全取消了名称空间；</strong></p>
<p>​	<strong>如果使用了两个同名的名称空间，将再次出现名称冲突问题；</strong></p>
<p>​	<strong>此外，应当知晓每段代码在哪个名称空间中运行，这样就不会无意中调用错误版本的函数；</strong></p>
</blockquote>
</li>
<li><p><strong>注意：切勿在头文件中使用    <code>using</code>    指令或    <code>using</code>    声明！</strong></p>
</li>
</ul>
</blockquote>
<h6 id="1-头文件中使用可能导致的问题"><a href="#1-头文件中使用可能导致的问题" class="headerlink" title="1.头文件中使用可能导致的问题"></a>1.头文件中使用可能导致的问题</h6><blockquote>
<blockquote>
<ol>
<li><p><strong>不允许在头文件中使用    <code>using</code>    指令，否则，可能会出现引入头文件的源文件中的全局命名空间被改变，从而可能引发命名冲突。</strong></p>
<blockquote>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 在头文件中避免这样的使用</span><br><span class="hljs-comment">// project_1.h</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 可能会出现引入头文件的源文件中的全局命名空间被改变，从而可能引发命名冲突</span><br></code></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>使用    <code>using</code>    声明引入头文件的源文件中的特定名称，作用于每个引入文件，同样可能也会导致命名冲突。</strong></p>
<blockquote>
<p>例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 在头文件中避免这样的使用</span><br><span class="hljs-comment">// project_1.h</span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-comment">// 作用于每个引入文件，同样可能也会导致命名冲突</span><br></code></pre></td></tr></table></figure></blockquote>
</li>
</ol>
</blockquote>
</blockquote>
<h6 id="2-解决方案："><a href="#2-解决方案：" class="headerlink" title="2.解决方案："></a><strong>2.解决方案：</strong></h6><ol>
<li><p><em>使用权限定名称</em>*</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 全限定名称示例</span><br><br>namespace_name::entity_name<br><span class="hljs-comment">// 即，在每次声明和定义函数的时候，都指明其命名空间</span><br></code></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>在头文件中使用命名空间别名</strong></p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// example.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> EXAMPLE_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXAMPLE_H</span><br><br><span class="hljs-keyword">namespace</span> mynamespace <br>&#123;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunction</span><span class="hljs-params">()</span></span>;  <br><span class="hljs-comment">// 使用命名空间别名</span><br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> </span><br></code></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>限制使用 using 的范围</strong></p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// example.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> EXAMPLE_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXAMPLE_H</span><br><br><span class="hljs-keyword">namespace</span> mynamespace <br>&#123;<br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-comment">// 在特定的命名空间中使用using</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunction</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> </span><br></code></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<h4 id="1-3字面量"><a href="#1-3字面量" class="headerlink" title="1.3	字面量"></a><strong>1.3	字面量</strong></h4><h5 id="1-字面量"><a href="#1-字面量" class="headerlink" title="1.字面量"></a>1.字面量</h5><p>字面量用于在代码中编写数字或字符串。C++ 支持大量标准字面量，可以使用以下字面量表示指定数字(列出的示例都表示数字 123)：</p>
<blockquote>
<ul>
<li>十进制字面量	123</li>
<li>八进制字面量	0173</li>
<li>十六进制字面量	0x7B</li>
<li>二进制字面量	0b1111011</li>
</ul>
</blockquote>
<h5 id="2-其他字面量："><a href="#2-其他字面量：" class="headerlink" title="2.其他字面量："></a>2.其他字面量：</h5><blockquote>
<ul>
<li>浮点值	如：3.14f</li>
<li>双精度浮点值	如：3.14</li>
<li>单个字符	如：’a’</li>
<li>以零结尾的字符数组	如：”character array”</li>
</ul>
</blockquote>
<h5 id="3-自定义自变量类型"><a href="#3-自定义自变量类型" class="headerlink" title="3.自定义自变量类型"></a>3.自定义自变量类型</h5><blockquote>
<p>自定义自变量类型，这是一种高级功能；</p>
</blockquote>
<h5 id="4-数字分隔符"><a href="#4-数字分隔符" class="headerlink" title="4.数字分隔符"></a>4.数字分隔符</h5><p>​	数字分隔符,可以在数值字面量中使用数字分隔符，数字分隔符是一个单引号，例如：</p>
<blockquote>
<ul>
<li>23’456’789</li>
<li>0.123’456f</li>
</ul>
</blockquote>
<h5 id="5-十六进制浮点字面量"><a href="#5-十六进制浮点字面量" class="headerlink" title="5.十六进制浮点字面量"></a>5.十六进制浮点字面量</h5><p>​	此外，C++17还增加了对十六进制浮点字面量的支持，例如：</p>
<blockquote>
<ul>
<li>0x3.ABCp-10</li>
<li>0Xb.cp121</li>
</ul>
</blockquote>
<hr>
<h4 id="1-4变量"><a href="#1-4变量" class="headerlink" title="1.4	变量"></a><strong>1.4	变量</strong></h4><blockquote>
<p>在 C++ 中，可以在任何位置声明变量，并且可以在声明一个变量所在行之后任意位置使用该变量。声明变量时可不指定值，这些未初始化的变量通常会被赋予一个半随机值，这个值取决于当前内存的内容(这是许多    bug    的来源)。在 C++ 中，也可以声明变量时为变量指定初始值。下面给出两种风格的变量声明方式，使用的都是代表整数的    int    类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> unintializedInt;<br><span class="hljs-type">int</span> initializedInt = <span class="hljs-number">7</span>;<br>cout &lt;&lt; uninitializedInt &lt;&lt; <span class="hljs-string">&quot; is a random value&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; initializedInt &lt;&lt; <span class="hljs-string">&quot; was assigned an initial value&quot;</span> &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<p>注意：</p>
<blockquote>
<p>当代码使用未初始化的变量时，多数编译器会给出警告或报错信息。当访问未初始化的变量时，某些 C++ 环境可能会报告运行时错误。</p>
</blockquote>
</blockquote>
<h5 id="1-整型-size-t："><a href="#1-整型-size-t：" class="headerlink" title="1.整型 &amp; size_t："></a>1.整型 &amp; size_t：</h5><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// (signed) int					正整数或负整数，范围取决于编译器</span><br><span class="hljs-comment">// 通常占 4 字节</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">-7</span>;<br><span class="hljs-type">signed</span> <span class="hljs-type">int</span> i = <span class="hljs-number">-6</span>;<br><span class="hljs-type">signed</span> i = <span class="hljs-number">-5</span>;<br><br><span class="hljs-comment">// (signed) short (int)			短整型整数</span><br><span class="hljs-comment">// 通常占 2 字节</span><br><span class="hljs-type">short</span> s = <span class="hljs-number">13</span>;<br><span class="hljs-type">short</span> <span class="hljs-type">int</span> s = <span class="hljs-number">14</span>;<br><span class="hljs-type">signed</span> <span class="hljs-type">short</span> s = <span class="hljs-number">15</span>;<br><span class="hljs-type">signed</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> s = <span class="hljs-number">16</span>;<br><br><span class="hljs-comment">// (signed) long (int)			长整型整数</span><br><span class="hljs-comment">// 通常占 4 字节</span><br><span class="hljs-type">long</span> l = <span class="hljs-number">-7L</span>;	<span class="hljs-comment">// L 可省略</span><br><br><span class="hljs-comment">// (signed) long long (int)		超长整型整数，范围取决于编辑器，但不低于长整数</span><br><span class="hljs-comment">// 通常占 8 字节</span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ll = <span class="hljs-number">14LL</span>;	<span class="hljs-comment">// LL 可省略</span><br><br><span class="hljs-comment">// unsigned (int / short int / long int / long long int)</span><br><span class="hljs-comment">// 对前面的类型加以限制，使其值 &gt;= 0</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">2U</span>;<br><span class="hljs-type">unsigned</span> j = <span class="hljs-number">5U</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> s = <span class="hljs-number">23U</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> l = <span class="hljs-number">5400UL</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> = <span class="hljs-number">140ULL</span>;<br><span class="hljs-comment">// 每个值的后缀单词都可以省略</span><br></code></pre></td></tr></table></figure>

<p><strong>关于 size_t 的使用优点</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 必须要引入以下头文件才可以使用：</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span><br></code></pre></td></tr></table></figure>

<ol>
<li><strong>无符号性质：</strong> <code>size_t</code> 是无符号整数类型，因此它只表示非负整数值。这有助于避免与负数相关的问题，特别是在处理数组索引和对象大小时。使用 <code>int</code> 可能导致符号错误，例如负索引或溢出。</li>
<li><strong>平台独立性：</strong> <code>size_t</code> 的大小足够大，可以容纳系统中最大可能的对象大小。在不同平台上，<code>int</code> 的大小可能会有所不同，因此在需要确保跨平台一致性时，使用 <code>size_t</code> 更为合适。</li>
<li><strong>与标准库的一致性：</strong> C++标准库和STL广泛使用 <code>size_t</code>，因此在与标准库交互时，使用 <code>size_t</code> 使得代码更一致，更容易集成。</li>
<li><strong>提高代码清晰度：</strong> 使用 <code>size_t</code> 作为大小和索引的类型，可以提高代码的可读性和表达能力。它传达了程序员的意图，即该值用于表示大小或索引，而不是一般性的整数。</li>
</ol>
</blockquote>
<h5 id="2-浮点型："><a href="#2-浮点型：" class="headerlink" title="2.浮点型："></a>2.<strong>浮点型：</strong></h5><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// float						浮点型数字</span><br><span class="hljs-comment">// 通常占 4 字节</span><br><span class="hljs-type">float</span> f = <span class="hljs-number">7.2f</span>;<br><br><span class="hljs-comment">// double						双精度浮点型数字</span><br><span class="hljs-comment">// 通常占 8 字节</span><br><span class="hljs-type">double</span> d = <span class="hljs-number">7.2</span>;<br><br><span class="hljs-comment">// long double					长双精度浮点型数字</span><br><span class="hljs-comment">// 通常占 8、12、16 等字节，取决于编译器和平台</span><br><span class="hljs-type">long</span> <span class="hljs-type">double</span> d = <span class="hljs-number">16.78L</span>;<br></code></pre></td></tr></table></figure>
</blockquote>
<h5 id="3-字符型："><a href="#3-字符型：" class="headerlink" title="3.字符型："></a>3.<strong>字符型：</strong></h5><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// char							单个字符</span><br><span class="hljs-comment">// 通常占 1 字节</span><br><span class="hljs-type">char</span> ch = <span class="hljs-string">&#x27;m&#x27;</span>;<br><br><span class="hljs-comment">// chat16_t						单个 16 位字符</span><br><span class="hljs-comment">// 占 16 位字节</span><br><span class="hljs-type">char16_t</span> c16 = <span class="hljs-string">u&#x27;m&#x27;</span>;	<span class="hljs-comment">// u 可省略</span><br><br><span class="hljs-comment">// chat32_t						单个 32 位字符</span><br><span class="hljs-comment">// 占 32 位字节</span><br><span class="hljs-type">char32_t</span> c32 = <span class="hljs-string">U&#x27;m&#x27;</span>;	<span class="hljs-comment">// U 可省略</span><br><br><span class="hljs-comment">// wchar_t						单个宽字符</span><br><span class="hljs-comment">// 大小取决于编译器</span><br><span class="hljs-type">wchar_t</span> w = <span class="hljs-string">L&#x27;m&#x27;</span>;<br><br><span class="hljs-comment">// 后面三种类型主要用于处理 Unicode 字符</span><br><span class="hljs-comment">// Unicode 是一种字符编码标准，为每个字符都分配了一个唯一的数字码点，以便在计算机中进行统一字符表示</span><br></code></pre></td></tr></table></figure>
</blockquote>
<h5 id="4-布尔类型："><a href="#4-布尔类型：" class="headerlink" title="4.布尔类型："></a>4.<strong>布尔类型：</strong></h5><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// bool							布尔类型，取值为 true 或 false</span><br><span class="hljs-comment">// 占 1 字节</span><br><span class="hljs-type">bool</span> b = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure>
</blockquote>
<h5 id="5-单字节：-需引入-头文件"><a href="#5-单字节：-需引入-头文件" class="headerlink" title="5.单字节：(需引入 &lt;cstddef&gt; 头文件)"></a>5.<strong>单字节：(需引入 <code>&lt;cstddef&gt;</code> 头文件)</strong></h5><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// std::byte							单个字节</span><br><span class="hljs-comment">// 在 C++17 之前，字符或无符号字符用于表示一个字节，但那些类型使得像在处理字符。std::byte 却能指明意图，即内存中的单个字节</span><br><span class="hljs-comment">// std::byte 的初始化需要使用单元素列表进行直接列表初始化</span><br>std::byte b&#123;<span class="hljs-number">42</span>&#125;;<br><span class="hljs-comment">// 相当于是：00101010</span><br><br>std::byte buffer[<span class="hljs-number">1024</span>];<br><span class="hljs-comment">// 处理网络数据，读写字节流等</span><br><br>std::byte data[<span class="hljs-number">256</span>];<br><span class="hljs-comment">// 读取或写入字节数据到文件或设备</span><br><br>std::byte flags = std::byte&#123;<span class="hljs-number">0x0F</span>&#125;; <br><span class="hljs-comment">// 00001111 in binary</span><br><br>std::byte b&#123;<span class="hljs-number">42</span>&#125;;<br>std::byte mask&#123;<span class="hljs-number">0xF0</span>&#125;;<br>std::byte result = b &amp; mask;<br><span class="hljs-comment">// 相当于 按位与 </span><br></code></pre></td></tr></table></figure>
</blockquote>
<h5 id="6-类型转换："><a href="#6-类型转换：" class="headerlink" title="6.类型转换："></a>6.类型转换：</h5><p>C++ 提供<strong>三种</strong>方式来显式地转换变量类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> myFloat = <span class="hljs-number">3.14f</span>;<br></code></pre></td></tr></table></figure>

<ol>
<li><p>来自于 C，并且依然被广泛使用，但实际上，<strong>不推荐</strong>使用：</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i_1 = (<span class="hljs-type">int</span>)myFloat;<br></code></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>初看上去肯自然，但<strong>很少使用</strong>：</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i_2 = <span class="hljs-built_in">int</span>(myFloat);<br></code></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>最复杂，却最整洁，也是<strong>推荐</strong>的方法，静态类型转换：</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i_3 = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(myFloat);<br></code></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<p><strong>注意：</strong></p>
<blockquote>
<ul>
<li>得到的整数是去掉小数部分的浮点部分。在某些环境中，可自动执行类型转换或强制执行类型转换，例如，short    可自动转换为    long,因为    long    代表精度更高的相同数据类型；</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">long</span> someLong = someShort;<br></code></pre></td></tr></table></figure>

<ul>
<li>当自动类型转换变量的类型时，应当了解潜在的数据丢失情况，例如，float    类型转化为    int    类型会丢失掉一部分信息(数字的小数部分)。如果，将一个    float    类型赋给    int    类型而不显示执行类型转换，多数编译器会给出警告信息，如果确信左边的类型和右边的类型完全兼容，那么隐式地转换完全没有问题；</li>
</ul>
</blockquote>
<h5 id="7-获取类型及大小："><a href="#7-获取类型及大小：" class="headerlink" title="7.获取类型及大小："></a>7.<strong>获取类型及大小：</strong></h5><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::cout &lt;&lt; <span class="hljs-built_in">typeid</span>(element).<span class="hljs-built_in">name</span>();<br><span class="hljs-comment">// 为 type_info 类型   </span><br><br>或者<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeindex&gt;</span>	<span class="hljs-comment">// 必需 &lt;typeindex&gt;</span></span><br>std::cout &lt;&lt; std::<span class="hljs-built_in">type_index</span>(<span class="hljs-built_in">typeid</span>(element)).<span class="hljs-built_in">name</span>();<br><span class="hljs-comment">// 为与 type_info 类似的类，但提供了比 type_info 更好的比较和哈希功能</span><br><br><span class="hljs-comment">// 类型大小</span><br><span class="hljs-built_in">sizeof</span>()	<span class="hljs-comment">// 获取内存所占比特数</span><br><span class="hljs-built_in">size</span>()		<span class="hljs-comment">// 获取元素个数</span><br><span class="hljs-built_in">strlen</span>()	<span class="hljs-comment">// 仅获取 C-string 字符串有效个数，不包括 NUL</span><br></code></pre></td></tr></table></figure>
</blockquote>
<h5 id="8-此外："><a href="#8-此外：" class="headerlink" title="8.此外："></a>8.<strong>此外：</strong></h5><blockquote>
<p>C++ 没有提供基本的字符串类型，但是作为标准库的一部分提供了字符串的标准实现；</p>
</blockquote>
<hr>
<h4 id="1-5运算符"><a href="#1-5运算符" class="headerlink" title="1.5	运算符"></a><strong>1.5	运算符</strong></h4><blockquote>
<p>在 C++ 中，运算符可以是一元的(操作一个表达式)、二元的(操作两个表达式)、三元的(操作三个表达式)。</p>
</blockquote>
<h5 id="1-一元运算符："><a href="#1-一元运算符：" class="headerlink" title="1.一元运算符："></a>1.<strong>一元运算符：</strong></h5><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">=<br><span class="hljs-comment">// 赋值符号</span><br><br>++<br>--<br><span class="hljs-comment">// 上述两自加加、自减减，仅对变量有效，对常量无效</span><br></code></pre></td></tr></table></figure>
</blockquote>
<h5 id="2-二元运算符："><a href="#2-二元运算符：" class="headerlink" title="2.二元运算符："></a>2.<strong>二元运算符：</strong></h5><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++">+<br>-<br>*<br>/<br><span class="hljs-comment">// 加、减、乘、除</span><br><br>%<br><span class="hljs-comment">// mod，取余运算</span><br><br>+=<br>-=<br>*=<br>/=<br>%=<br><span class="hljs-comment">// 简写</span><br><br>&amp;<br>|<br>&lt;&lt;<br>&gt;&gt;<br>^<br><span class="hljs-comment">// 按位与、按位或、左移、右移、按位异或</span><br><br>&amp;=<br>|=<br>&lt;&lt;=<br>&gt;&gt;=<br>^=<br><span class="hljs-comment">// 简写</span><br></code></pre></td></tr></table></figure>
</blockquote>
<h5 id="3-三元运算符-条件运算符-："><a href="#3-三元运算符-条件运算符-：" class="headerlink" title="3.三元运算符(条件运算符)："></a>3.<strong>三元运算符(条件运算符)：</strong></h5><blockquote>
<p>C++ 中有一个接收三个参数的运算符，称为三元运算符。可将其作为“如果【某事发生了】，那么【执行某个操作】；否则，【执行其他操作】”的条件表达式的简写。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">condition ? expression_if_true : expression_if_false;<br></code></pre></td></tr></table></figure>

<p>条件运算符的优点是几乎可以在任何环境中使用，而且是直接将结果用在代码中，而非执行代码块，这使得它是一个运算符，而非条件语句。</p>
</blockquote>
<h4 id="1-6类型"><a href="#1-6类型" class="headerlink" title="1.6	类型"></a><strong>1.6	类型</strong></h4><blockquote>
<p>在 C++ 中，可使用基本类型(int、bool 等)创建更复杂的自定义类型。一旦熟悉 C++ 程序，就会很少使用从 C 中沿袭来的技巧，因为类更强大。虽然如此，但是还是有必要学会以下两种创建类型的方法：</p>
</blockquote>
<h5 id="1-枚举类型："><a href="#1-枚举类型：" class="headerlink" title="1.枚举类型："></a>1.<strong>枚举类型：</strong></h5><blockquote>
<p>整数代表某个数字序列中的值，枚举类型允许用户定义自己的序列，这样声明的变量就只能使用这个序列中的值；</p>
<ul>
<li><p><strong>const    表示法：</strong></p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 当希望获取某些不变量的值的时候，使用以下方式并不是很好</span><br><span class="hljs-comment">// 以国际象棋为例，int 表示所有棋子</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> PieceTypeKing = <span class="hljs-number">0</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> PieceTypeQueen = <span class="hljs-number">1</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> PieceTypeRook = <span class="hljs-number">2</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> PieceTypePawn = <span class="hljs-number">3</span>;<br><span class="hljs-comment">// etc.</span><br><span class="hljs-type">int</span> myPiece = PieceTypeKing;<br><span class="hljs-comment">// 这种表示虽然正确，但是存在一定风险，因为，棋子是一个 int，如果另一个程序增加棋子的值，就可以让 King 变成 Queen，这实质上没有意义。更糟糕的是，有人可能将某个棋子的值设置成为 -1，而这个值并没有对应的常量</span><br></code></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>枚举表示法：</strong></p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 利用以下代码生成一个新类型 PieceType</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">PieceType</span><br>&#123;<br>PieceTypeKing,	<span class="hljs-comment">// 不显式设定，默认为 0</span><br>PieceTypeQueen,	<span class="hljs-comment">// 不显式设定，默认为 1</span><br>PieceTypeRook,	<span class="hljs-comment">// 不显式设定，默认为 2</span><br>PieceTypePawn	<span class="hljs-comment">// 不显式设定，默认为 3</span><br>&#125;;<br>PieceType myPiece;<br>myPiece = PieceTypeQueen;<br>cout &lt;&lt; myPiece;<br><span class="hljs-comment">// 正常输出一个整型值</span><br><br>myPiece = <span class="hljs-number">0</span>;<br>cout &lt;&lt; myPiece;<br><span class="hljs-comment">// 出现类型不匹配报错</span><br></code></pre></td></tr></table></figure>

<p>由于实质上，enum    类型是一个整型值，但是由于它本身并不是    int    类型，所以能降低风险；</p>
<p>关于枚举类型语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">PieceType</span><br>&#123;<br>PieceTypeKing = <span class="hljs-number">1</span>,	<span class="hljs-comment">// 设定为 1</span><br>PieceTypeQueen,		<span class="hljs-comment">// 为前驱 +1，为 2</span><br>PieceTypeRook = <span class="hljs-number">10</span>,	<span class="hljs-comment">// 设定为 10</span><br>PieceTypePawn		<span class="hljs-comment">// 为前驱 +1，为 11</span><br>&#125;;<br><span class="hljs-comment">// 即，某位置的值若未被设定，则，其值为前驱值 +1</span><br></code></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</blockquote>
<h5 id="2-强类型枚举："><a href="#2-强类型枚举：" class="headerlink" title="2.强类型枚举："></a>2.<strong>强类型枚举：</strong></h5><blockquote>
<ul>
<li><p>上面给出的枚举并不是强类型的，这意味着并非是类型安全的，它们总被解释为整形数据，因此可以比较完全不同的枚举类型的枚举值；</p>
<blockquote>
<p>意思是说，虽然无法参与整型运算，但是，本质上，又被解释为整形变量，所以，可以参与到整型变量比较，这同样是一种不安全；</p>
</blockquote>
</li>
<li><p>强类型的 enum class 枚举解决了这些问题，例如，下面定义前述的 PieceType 枚举类型的安全版本：</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">PieceType</span><br>&#123;<br>	King = <span class="hljs-number">1</span>,<br>	Queen,<br>	Rook = <span class="hljs-number">10</span>,<br>	Pawn<br>&#125;;<br></code></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>对于 enum class，枚举值名不会超出封闭的作用域，这代表总要使用作用域解析操作符：</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">PieceType piece = PieceType::King;<br></code></pre></td></tr></table></figure>

<p>这也意味着，枚举值可以指定更简短的名称，因为有作用域的限定，每次都要作用域解析；</p>
<p>因此，避免了枚举值自动类型转换为整数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 以下代码是不合法的</span><br><span class="hljs-keyword">if</span> (PieceType == <span class="hljs-number">2</span>) &#123;...&#125;<br></code></pre></td></tr></table></figure>

<p>此外，默认情况下，枚举值的基本类型是整型，但是可以采用以下方法加以改变：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">PieceType</span> : <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span><br>&#123;<br>	King = <span class="hljs-number">1</span>,<br>	Queen,<br>	Rook = <span class="hljs-number">10</span>,<br>	Pawn<br>&#125;;<br></code></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>注意：</strong></p>
<blockquote>
<p>建议用类型安全的 enum class 枚举来代替类型不安全的 enum 枚举；</p>
</blockquote>
</li>
</ul>
</blockquote>
<h5 id="3-结构-struct-："><a href="#3-结构-struct-：" class="headerlink" title="3.结构(struct)："></a>3.<strong>结构(struct)：</strong></h5><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// employeestruct.h</span><br><span class="hljs-comment">// 在头文件中声明结构体 Employee</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Employee</span><br>&#123;<br>	<span class="hljs-type">char</span> firstInitial;<br>	<span class="hljs-type">char</span> lastInitial;<br>	<span class="hljs-type">int</span> employeeNumber;<br>	<span class="hljs-type">int</span> salary;<br>&#125;;<br></code></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// employee.cpp</span><br><span class="hljs-comment">// 在头文件中实现结构体 Employee</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;employeestruct.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Employee anEmployee;<br>	anEmployee.firstInitial = <span class="hljs-string">&#x27;M&#x27;</span>;<br>	anEmployee.lastInitial = <span class="hljs-string">&#x27;G&#x27;</span>;<br>	anEmployee.employeeNumber = <span class="hljs-number">42</span>;<br>	anEmployee.salary = <span class="hljs-number">80000</span>;<br><br>	cout &lt;&lt; <span class="hljs-string">&quot;Employee: &quot;</span> &lt;&lt; anEmployee.firstInitial &lt;&lt; anEmployee.lastInitial &lt;&lt; emdl;<br>	cout &lt;&lt; <span class="hljs-string">&quot;Number: &quot;</span> &lt;&lt; anEmployee.employeeNumber &lt;&lt; endl;<br>	cout &lt;&lt; <span class="hljs-string">&quot;Salary: $&quot;</span> &lt;&lt; anEmployee.salary &lt;&lt; endl;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<hr>
<h4 id="1-7条件语句"><a href="#1-7条件语句" class="headerlink" title="1.7	条件语句"></a><strong>1.7	条件语句</strong></h4><h5 id="1-if-else-语句"><a href="#1-if-else-语句" class="headerlink" title="1.if &#x2F; else 语句"></a>1.<strong>if &#x2F; else 语句</strong></h5><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (condition)<br>	&#123;...&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (condition)<br>	&#123;...&#125;<br><span class="hljs-keyword">else</span><br>	&#123;...&#125;<br></code></pre></td></tr></table></figure>

<p>0&#x2F;false	  都被视为 	false；</p>
<p>非0&#x2F;true	都被视为 	true；</p>
</blockquote>
<h5 id="2-if-语句的初始化器"><a href="#2-if-语句的初始化器" class="headerlink" title="2.if 语句的初始化器"></a>2.<strong>if 语句的初始化器</strong></h5><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (&lt;initializer&gt;;&lt;conditional_expression&gt;) &#123;&lt;body&gt;&#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>&lt;initializer&gt;</code></strong> 中引入的任何变量只能在**<code>&lt;conditional_expression&gt;</code>** 和 <strong><code>&lt;body&gt;</code></strong> 中可用，此类变量在 if 语句外不可用，是匿名变量；</p>
<p>示例：</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (Employee employee = <span class="hljs-built_in">GetEmployee</span>(); employee.salary &gt; <span class="hljs-number">1000</span>) &#123;...&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<h5 id="3-switch-语句"><a href="#3-switch-语句" class="headerlink" title="3.switch 语句"></a>3.<strong>switch 语句</strong></h5><blockquote>
<p>switch 是另一种根据表达式值执行操作的语法。在 C++ 中，switch 语句的表达式必须是整型、能转化为整形的类型、枚举类型或强类型枚举，必须与一个常量比较，每个常量值代表一种“*<em>情况</em>(case)***”，如果表达式与这种情况匹配，随后的代码将会被执行，直到遇到 <strong><code>break</code></strong> 语句为止。此外，还提供 <strong><code>default</code></strong> 情况，如果没有其他情况与表达式匹配，表达式值将与 <strong><code>default</code></strong> 情况匹配；</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">switch</span> (menuItem)<br>&#123;<br>	<span class="hljs-keyword">case</span> OpenMenuItem:<br>		<span class="hljs-comment">// Code to open a file</span><br>		<span class="hljs-keyword">break</span>;<br>	<span class="hljs-keyword">case</span> SaveMenuItem:<br>		<span class="hljs-comment">// Code to save a file</span><br>		<span class="hljs-keyword">break</span>;<br>	<span class="hljs-keyword">default</span>:<br>		<span class="hljs-comment">// Code to give an error message</span><br>		<span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-comment">// 转化为相应的 if/else 语句</span><br><span class="hljs-keyword">if</span> (menuItem == OpenMenuItem)<br>&#123;<br>	<span class="hljs-comment">// Code to open a file</span><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (menuItem == SaveMenuItem)<br>&#123;<br>	<span class="hljs-comment">// Code to save a file</span><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>	<span class="hljs-comment">// Code to give an error message</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果要基于多个表达式的多个值(而非对表达式进行一些检测)执行操作 ，通常使用 switch 语句。此时，switch 语句可以避免级联使用 if-else 语句。</p>
<p><strong>注意：</strong></p>
<blockquote>
<p>一旦找到与 switch 条件匹配的 case 表达式，就执行其后的语句，知道遇到 break 语句为止。即使遇到另一个 case 表达式，执行也会继续，这种语法称为 fallthrough；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">switch</span> (backgroundColor)<br>&#123;<br>	<span class="hljs-keyword">case</span> Color::DarkBlue:<br>	<span class="hljs-keyword">case</span> Color::Black:<br> 	 	<span class="hljs-comment">// Code to execute for both a dark blue or black background color</span><br>  		<span class="hljs-keyword">break</span>;<br>	<span class="hljs-keyword">case</span> Color::Red:<br>  		<span class="hljs-comment">// Code to excute for a red background color</span><br>  		<span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果是无意忘记 break 语句，fallthough 将成为 bug 的来源，因此如果在 switch 语句中，检测到 fallthough，编译器将会生成警告信息，除非像上例那样 case 为空。</p>
<p>此外，可以通过使用 <strong><code>[[fallthougn]]</code></strong> 特殊性，来告诉编辑器某个 fall though 是有意为之的；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">switch</span> (backgroundColor)<br>&#123;<br><span class="hljs-keyword">case</span> Color::DarkBlue:<br>  <span class="hljs-built_in">doSomethingForDarkBlue</span>();<br>  [[fallthough]];<br><span class="hljs-keyword">case</span> Color::Black:<br>  <span class="hljs-comment">// Code to execute for both a dark blue or black background color</span><br>  <span class="hljs-built_in">doSomethingForBlackOrDarkBlue</span>();<br>  <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> Color::Red:<br><span class="hljs-keyword">case</span> Color::Green:<br>  <span class="hljs-comment">// Code to excute for a red or green background color</span><br>  <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<h5 id="4-switch-语句的初始化器"><a href="#4-switch-语句的初始化器" class="headerlink" title="4.switch 语句的初始化器"></a>4.<strong>switch 语句的初始化器</strong></h5><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">switch</span> (&lt;initializer&gt;, &lt;expression&gt;) &#123;&lt;body&gt;&#125;<br></code></pre></td></tr></table></figure>

<p>与 if 语句一致，**<code>&lt;initializer&gt;</code>** 中引入的任何变量只能在**<code>&lt;conditional_expression&gt;</code>** 和 <strong><code>&lt;body&gt;</code></strong> 中可用，它们在 switch 语句外不可用；</p>
</blockquote>
<h5 id="5-条件运算符"><a href="#5-条件运算符" class="headerlink" title="5.条件运算符"></a>5.<strong>条件运算符</strong></h5><blockquote>
<p>略，详见三元运算符；</p>
</blockquote>
<hr>
<h4 id="1-8逻辑比较运算符"><a href="#1-8逻辑比较运算符" class="headerlink" title="1.8	逻辑比较运算符"></a><strong>1.8	逻辑比较运算符</strong></h4><blockquote>
<p><strong>逻辑比较运算符(conditional operator)：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">&lt;<br>&gt;<br>&lt;=<br>&gt;=<br>==<br>!=<br>!<br>&amp;&amp;<br>||<br></code></pre></td></tr></table></figure>

<ul>
<li><p>在 C++ 中，对表达式求值时，会采用短路逻辑，即，一旦发现最终结果可以确定，就不再对后面的表达式求值；</p>
</li>
<li><p>短路的做法对性能有好处：在使用逻辑短路时，可将代价更低的测试放在前面，以避免执行代价更高的测试。通过逻辑短路还可以避免在指针上下文中，避免指针无效时执行表达式的一部分的情况；</p>
</li>
</ul>
</blockquote>
<hr>
<h4 id="1-9函数"><a href="#1-9函数" class="headerlink" title="1.9	函数"></a><strong>1.9	函数</strong></h4><blockquote>
<ul>
<li><p>对于大型程序来说，将所有代码都放到 main() 函数中是无法管理的。为了使程序便于理解，需要将代码分解为简单明了的程序。</p>
</li>
<li><p>在 C++ 中，为了让其他代码能够使用某个函数，首先，应当声明该函数。如果函数在某个特定的文件内部被使用，通常会在源文件中声明并定义这个函数。如果函数是供其他模块或文件使用的，通常在<strong>头文件</strong>中声明函数，并在源文件中定义函数。</p>
</li>
<li><p>函数声明通常被称为<strong>“函数原型”</strong>或<strong>“函数头”</strong>，以强调这代表函数的访问方式，而不是具体代码，术语<strong>“函数签名”</strong>指将函数名和参数列表与形参列表组合在一起，但没有返回值。</p>
</li>
<li><p>当没有与函数声明匹配的函数定义时，在编译过程中，会出现<strong>链接阶段</strong>错误；</p>
</li>
<li><p>注意：与 C 不同，在 C++ 中没有形参的函数仅需要一个空的参数列表，不需要使用 void 指出此处没有形参；然而，如果没有返回值，那么仍需要 void 来指明这一点；</p>
<ol>
<li><p><strong>函数返回类型的推断：</strong></p>
<blockquote>
<p>C++14 允许要求编辑器自动推出函数的返回值，要使用这个功能，需要把 <strong><code>auto</code></strong> 指定为返回类型；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">addnumber</span><span class="hljs-params">(<span class="hljs-type">int</span> number1, <span class="hljs-type">int</span> number2)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span> number1 + number2;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意：函数中可有多个 <strong><code>return</code></strong> 语句，但是它们应解析为<strong>相同的类型</strong>。这种函数甚至可以包含<strong>递归调用</strong>(调用自身)，但函数中的第一个 <strong><code>return</code></strong> 语句必须时非递归调用的；</p>
</blockquote>
</li>
<li><p><strong>当前函数的名称：</strong></p>
<blockquote>
<p>每个函数都有一个预定义的局部变量 **<code>_ _func_ _</code>**，其中包括当前函数的名称。这个变量的一个用途是用于日志记录：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">addNumbers</span><span class="hljs-params">(<span class="hljs-type">int</span> number1, <span class="hljs-type">int</span> number2)</span></span><br><span class="hljs-function"></span>&#123;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;Entering function &quot;</span> &lt;&lt; __func__ &lt;&lt; std::endl;<br> <span class="hljs-comment">// 左右两边各两个下划线，用于包括当前函数的名称</span><br> <span class="hljs-comment">// __func__ 为 const char[] 类型</span><br> <span class="hljs-comment">// __func__ 是编译器提供的宏，在编译时展开，而不是在运行时展开，这使得它在程序执行期间不会产生额外的运行开销，主要用于调试和日志记录，以便在运行时了解代码的执行流程，而不会影响实际的程序性能</span><br>	<span class="hljs-keyword">return</span> number1 + number2;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote>
</li>
</ol>
</li>
</ul>
</blockquote>
<hr>
<h4 id="1-10C-风格的数组"><a href="#1-10C-风格的数组" class="headerlink" title="1.10	C 风格的数组"></a><strong>1.10	C 风格的数组</strong></h4><blockquote>
<p>注意：在 C++ 中，尽量<strong>避免</strong>使用这种 C 风格的数组，而改用<strong>标准库</strong>功能，例如：**<code>std::array</code>** 和 **<code>std::vector</code>**；</p>
</blockquote>
<h5 id="1-一维数组："><a href="#1-一维数组：" class="headerlink" title="1.一维数组："></a>1.<strong>一维数组：</strong></h5><blockquote>
<p>数组具有一系列值，所有值的<strong>类型相同</strong>，每个值都可以根据它在数组中的位置进行访问。在 C++ 中声明数组时，必须声明<strong>数组大小</strong>。数组大小不能用变量表示——必须用<strong>常量</strong>或<strong>常量表示式</strong><em><strong>(coonstexpr)</strong></em> 表示数组大小；</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int myArray[<span class="hljs-number">3</span>]<span class="hljs-comment">;</span><br>myArray[<span class="hljs-number">0</span>] <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>myArray[<span class="hljs-number">1</span>] <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>myArray[<span class="hljs-number">2</span>] <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>// Index 的起点始终是 <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>不使用循环的初始化机制：</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> myArray[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> myArray[<span class="hljs-number">3</span>] = &#123;&#125;;<br><span class="hljs-comment">// 都起到将所有列表中元素置零的作用</span><br><br><span class="hljs-type">int</span> myArray[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-comment">// 自动推导出列表长度，并初始化每个位置的值</span><br><br><span class="hljs-type">int</span> myArray[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">2</span>&#125;;<br><span class="hljs-comment">// 将数组第一个元素置为 2，其余置为 0</span><br><br><span class="hljs-type">int</span> myArray[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br><span class="hljs-comment">// 将数组第一个元素置为 1，将数组第二个元素置为 2，其余置为 0</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p><strong>获取数组大小(元素个数)：</strong></p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 遇到数组长度等，都使用 size_t 的方式来描述大小！！！</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span>	<span class="hljs-comment">// 必须 &lt;array&gt;</span></span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> arraySize = std::<span class="hljs-built_in">size</span>(myArray);<br><span class="hljs-comment">// 使用 unsigned int 接收数组大小</span><br>std::cout &lt;&lt; std::<span class="hljs-built_in">size</span>(myArray);<br><br>或者：<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> arraySize = <span class="hljs-built_in">sizeof</span>(myArray) / <span class="hljs-built_in">sizeof</span>(myArray[<span class="hljs-number">0</span>]);<br></code></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</blockquote>
<h5 id="2-二维数组："><a href="#2-二维数组：" class="headerlink" title="2.二维数组："></a>2.<strong>二维数组：</strong></h5><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> ticTacToeBoard[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure>
</blockquote>
<h5 id="3-三维数组、更高维数组："><a href="#3-三维数组、更高维数组：" class="headerlink" title="3.三维数组、更高维数组："></a>3.<strong>三维数组、更高维数组：</strong></h5><blockquote>
<p>难以描绘，极少使用；</p>
</blockquote>
<hr>
<h4 id="1-11std-array"><a href="#1-11std-array" class="headerlink" title="1.11	std::array"></a><strong>1.11	<code>std::array</code></strong></h4><blockquote>
<p>在 C++ 中，有一种<strong>大小固定</strong>的特殊容器 <strong><code>std::array</code><strong>，这种容器在 <strong><code>&lt;array&gt;</code></strong> 头文件中定义。它详细用法在之后学习，但基本就是对 C 风格的数组进行</strong>简单包装</strong>：</p>
<p><strong>用 <code>std::array</code> 代替 C 风格的数组优点：</strong></p>
<blockquote>
<ol>
<li>它总是知道<strong>自身大小</strong>；</li>
<li><strong>不会自动转化为指针</strong>，从而避免了某些类型的 bug；</li>
<li>具有<strong>迭代器</strong>，可以方便地遍历元素；</li>
</ol>
<p><strong>示例：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::array&lt;<span class="hljs-type">int</span>, 3&gt; arr = &#123; <span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span> &#125;; <br>std::cout &lt;&lt; <span class="hljs-string">&quot;Array size = &quot;</span> &lt;&lt; arr.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;2nd element = &quot;</span> &lt;&lt; arr[<span class="hljs-number">1</span>] &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<blockquote>
<p><strong>C 风格和 std::array 的数组</strong>都具有<strong>固定的大小</strong>，在编译过程中不会改变；</p>
<p>如果希望数组的大小是动态的，推荐使用 <code>std::vector</code>，在 vector 中添加新元素时，vector 会自动增加其大小；</p>
</blockquote>
</blockquote>
</blockquote>
<hr>
<h4 id="1-12std-vector"><a href="#1-12std-vector" class="headerlink" title="1.12	std::vector"></a><strong>1.12	<code>std::vector</code></strong></h4><blockquote>
<ul>
<li>标准库提供了多个不同的<strong>非固定大小容器</strong>，可用于存储信息。**<code>std::vector</code>** 就是其中的一个示例。它在 <strong><code>&lt;vector&gt;</code></strong> 头文件中被声明，用一种更灵活更安全的机制取代 C 中的数组概念。用户不必担心内存的管理，因为 vector 将自动分配足够的内存来存放元素。vector 是动态的，意味着可以在运行时添加和删除元素,而且它的用法十分简单，示例：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Create a vector of integers</span><br>std::vector&lt;<span class="hljs-type">int</span>&gt; myVector = (<span class="hljs-number">11</span>, <span class="hljs-number">12</span>);<br><br><span class="hljs-comment">// Add some more integers to the vector using push_back()</span><br>myVector.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">33</span>);<br>myVector.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">44</span>);<br><br><span class="hljs-comment">// Delete some more integer to the vector using pop_back()</span><br><span class="hljs-comment">// 删除最后一个元素</span><br>myVector.<span class="hljs-built_in">pop_back</span>();<br><br><span class="hljs-comment">// 删除中间元素，后面元素顺位向前移动，使用 erase()</span><br>myVector.<span class="hljs-built_in">erase</span>(myVector.<span class="hljs-built_in">begin</span>());	<span class="hljs-comment">// 删除索引为 0 元素</span><br>myVector.<span class="hljs-built_in">erase</span>(myVector.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">2</span>) <span class="hljs-comment">// 删除索引为 2 元素</span><br><br><span class="hljs-comment">// Access elements</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;1st element: &quot;</span> &lt;&lt; myVector[<span class="hljs-number">0</span>] &lt;&lt; endl;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>vector 中尖括号用来指定模板函数，与之前的 <strong><code>std::array</code></strong> 一样，vector 时一个泛类容器，几乎可以容纳任何类型的对象；但是必须使用简括号指定要在 vector 中存放的对象类型；</p>
</li>
<li><p>为向 vector 中添加元素，可以使用 push_back() 方法；</p>
</li>
<li><p>为访问 vector 中各个元素，可使用类似于数组的语法，即，operator[]；</p>
</li>
</ul>
</blockquote>
<hr>
<h4 id="1-13结构化绑定"><a href="#1-13结构化绑定" class="headerlink" title="1.13	结构化绑定"></a><strong>1.13	结构化绑定</strong></h4><blockquote>
<p><strong>结构化绑定*(structured budings)*<strong>，允许声明多个变量，这些变量使用数组、结构、</strong><code>std::pair</code></strong> 关键词或 <strong><code>std::tuple</code></strong> 中的元素来初始化。它允许你以一种简洁的方式从复合类型（例上面所提的**<code>std::pair</code>** 或  **<code>std::tuple</code>**）或结构体中提取成员，并将其绑定到命名变量上。结构化绑定的主要目的是提高代码的可读性和简洁性，特别是在处理复杂数据结构时；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 基本语法：</span><br><span class="hljs-keyword">auto</span> [var1, var2, ...] = expression;<br></code></pre></td></tr></table></figure>

<p>使用特点：</p>
<blockquote>
<ul>
<li>假定有以下数组：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::array&lt;<span class="hljs-type">int</span>, 3&gt; values = &#123;<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li>可声明三个变量 x、y、z，使用其后数组中的三个值进行初始化。注意，必须为结构化绑定使用 auto 关键字（例，不能用 int 替代 auto）：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> [x, y, z] = values;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>注意：使用结构化绑定声明的变量数量必须与右侧表达式中的值数量匹配；</p>
</li>
<li><p>此外，如果所有非静态成员都是公有的，也可以将结构化绑定用于结构；</p>
</li>
<li><p>使用结构化绑定优点，示例：</p>
<blockquote>
<ol>
<li><p>简化**<code>std::pair</code>** 、  <strong><code>std::tuple</code></strong> 或结构体使用，无需显式地访问元素索引或成员变量;</p>
<blockquote>
<pre><code class="c++">std::tuple&lt;int, double, std::string&gt; myTuple = std::make_tuple(42, 3.14, &quot;Hello&quot;);
auto [a, b, c] = myTuple;
</code></pre>
</blockquote>
</li>
<li><p>提高代码可读性，直观显示内容；</p>
<blockquote>
<pre><code class="c++">struct Point
&#123;
    double mX;
    double mY;
    double mZ;
&#125;;
Point point;
point.mX = 1.0;
point.mY = 2.0;
point.mZ = 3.0;
auto [x, y, z] = point;
</code></pre>
</blockquote>
</li>
<li><p>减少错误风险，减少手动索引或访问机构提而引起的错误；</p>
<blockquote>
<pre><code class="c++">std::pair&lt;int, std::string&gt; myPair = std::make_pair(42, &quot;Hello&quot;);
auto [num, text] = myPair;
</code></pre>
</blockquote>
</li>
</ol>
</blockquote>
</li>
</ul>
</blockquote>
</blockquote>
<hr>
<h4 id="1-14循环"><a href="#1-14循环" class="headerlink" title="1.14	循环"></a><strong>1.14	循环</strong></h4><blockquote>
<p>在 C++ 中，提供了 4 种循环结构：</p>
</blockquote>
<h5 id="1-while-循环"><a href="#1-while-循环" class="headerlink" title="1.while 循环"></a>1.<strong>while 循环</strong></h5><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (condition_expr)<br>&#123;...&#125;<br><span class="hljs-comment">// 在循环中使用 break 关键字立即跳出循环并执行之后程序</span><br><span class="hljs-comment">// 在循环中使用 continue 关键字可返回循环顶部并对 while 表达式重新求值</span><br><span class="hljs-comment">// 这两种风格都不提倡使用，因为它们会使程序的执行产生无规则的跳转，应该慎用</span><br></code></pre></td></tr></table></figure>
</blockquote>
<h5 id="2-do-while-循环"><a href="#2-do-while-循环" class="headerlink" title="2.do&#x2F;while 循环"></a>2.<strong>do&#x2F;while 循环</strong></h5><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">do</span><br>&#123;...&#125;<br><span class="hljs-keyword">while</span>(condition_expr);<br><span class="hljs-comment">// 使得程序至少执行一次</span><br></code></pre></td></tr></table></figure>
</blockquote>
<h5 id="3-for-循环"><a href="#3-for-循环" class="headerlink" title="3.for 循环"></a>3.<strong>for 循环</strong></h5><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (init_state; loop_conditon; iter_expr) <br>&#123;...&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<h5 id="4-基于区间的-for-循环-Range-Based-for-Loop"><a href="#4-基于区间的-for-循环-Range-Based-for-Loop" class="headerlink" title="4.基于区间的 for 循环(Range-Based for Loop)**"></a>4.<em><em>基于区间的 for 循环</em>(Range-Based for Loop)</em>**</h5><blockquote>
<p>这种循环类似于 Python，允许方便地迭代容器中的元素。这种循环可用于 C 风格的数组、初始化列表等，也可用于具有返回迭代器的 begin() 和 end() 函数的类型，例如， <strong><code>std::array</code></strong> 、 <strong><code>std::vector</code></strong> 等其他所有标准库容器；</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::array&lt;<span class="hljs-type">int</span>, 4&gt; arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : arr)<br>&#123;<br>	std::cout &lt;&lt; i &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<hr>
<h4 id="1-15初始化列表"><a href="#1-15初始化列表" class="headerlink" title="1.15	初始化列表"></a><strong>1.15	初始化列表</strong></h4><blockquote>
<p>初始化列表在  <strong><code>initializer_list</code></strong>  头文件中定义；利用初始化列表，可以轻松地编写能接收<strong>可变数量参数</strong>的函数。  <strong><code>initializer_list</code></strong>  类是一个模板，要求在尖括号之间指定列表中的元素类型，这类似于指定 vector 中存储的对象类型；</p>
<p>示例：</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;initializer_list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 定义可变数量参数累加函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">makeSun</span><span class="hljs-params">(initializer_list&lt;<span class="hljs-type">int</span>&gt; lst)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> total = <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : lst)<br>	&#123;<br>		total += value;<br>	&#125;<br><br><span class="hljs-keyword">return</span> total;<br>&#125;<br><br><span class="hljs-type">int</span> a = <span class="hljs-built_in">makeSun</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;);<br><span class="hljs-type">int</span> b = <span class="hljs-built_in">makeSun</span>(&#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>, <span class="hljs-number">60</span>&#125;);<br><br><span class="hljs-comment">// 初始化列表是类型安全的，会定义列表中允许的类型。对于此处的 makeSun() 函数，初始化列表所有元素必须都是整数。</span><br><span class="hljs-comment">// 尝试使用 double 数值进行调用，将会导致编译器生成错误或警告</span><br><span class="hljs-type">int</span> c = <span class="hljs-built_in">makeSun</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3.0</span>&#125;);<br></code></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<hr>
<h4 id="1-16小结"><a href="#1-16小结" class="headerlink" title="1.16	小结"></a><strong>1.16	小结</strong></h4><blockquote>
<p>至此，C++ 程序设计的基本要点已经复习完成，这些是很简单的内容；</p>
</blockquote>
<hr>
<h3 id="1-2-深入研究-C"><a href="#1-2-深入研究-C" class="headerlink" title="1.2    深入研究 C++"></a><strong>1.2    深入研究 C++</strong></h3><hr>
<h4 id="2-1C-中的字符串"><a href="#2-1C-中的字符串" class="headerlink" title="2.1	C++ 中的字符串"></a><strong>2.1	C++ 中的字符串</strong></h4><blockquote>
<p>在 C++ 中使用字符串有三种方法。</p>
</blockquote>
<h5 id="1-C-风格的字符串"><a href="#1-C-风格的字符串" class="headerlink" title="1.C 风格的字符串"></a>1.<strong>C 风格的字符串</strong></h5><blockquote>
<p>将字符看成字符数组；</p>
</blockquote>
<h5 id="2-C-风格的字符串"><a href="#2-C-风格的字符串" class="headerlink" title="2.C++ 风格的字符串"></a>2.<strong>C++ 风格的字符串</strong></h5><blockquote>
<p>将字符串封装到一种易于使用的 string 类型中，需要引入 <strong><code>&lt;string&gt;</code></strong> 头文件；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C++ 中 string 的用法与基本类型几乎相同</span><br><span class="hljs-comment">// 与 I/O 流一样，string 类型位于 std 名称空间</span><br>std::string myString = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;The value of myString is &quot;</span> &lt;&lt; myString &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;The second letter is &quot;</span> &lt;&lt; myString[<span class="hljs-number">1</span>] &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure>
</blockquote>
<h5 id="3-非标准的普通类"><a href="#3-非标准的普通类" class="headerlink" title="3.非标准的普通类"></a>3.<strong>非标准的普通类</strong></h5><blockquote>
<p>略，详见第二章；</p>
</blockquote>
<hr>
<h4 id="2-2指针和动态内存"><a href="#2-2指针和动态内存" class="headerlink" title="2.2	指针和动态内存"></a><strong>2.2	指针和动态内存</strong></h4><blockquote>
<p>动态内存允许所创建的程序具有在编译时大小可变的数据，大多数复杂程序都会以某种方式使用动态内存；</p>
</blockquote>
<h5 id="1-堆栈和堆"><a href="#1-堆栈和堆" class="headerlink" title="1.堆栈和堆"></a>1.<strong>堆栈和堆</strong></h5><blockquote>
<p>在 C++ 的内存中，分为两部分：<strong>堆栈</strong> 和 <strong>堆</strong>。</p>
<ul>
<li><p><strong>堆栈</strong></p>
<blockquote>
<p><strong>堆栈</strong>就像一副扑克牌，当前顶部的牌代表程序当前的作用域，通常时当前正在执行的函数；当前函数中声明的所有变量将占用顶部<strong>堆栈帧</strong>(也就是最上面的那张牌)的内存。如果当前函数(将其称为 foo())调用了另一个函数 bar()，就会翻开一张新牌，这样 bar() 就会拥有自己的<strong>堆栈帧</strong>供其运行。任何从 foo() 传递给 bar() 的参数都会从 foo() <strong>堆栈帧</strong>复制到 bar() <strong>堆栈帧</strong>；</p>
<p><strong>堆栈帧</strong>很好，因为它为每个函数提供了独立的内存空间。如果在 foo() <strong>堆栈帧</strong> 中声明了一个变量，那么除非专门要求，否则调用 bar() 函数不会更改该变量。此外，foo() 函数执行完毕时，<strong>堆栈帧</strong> 就会消失，该函数声明的所有变量都不会再占用内存。堆栈上的分配内存的变量<strong>不需要</strong>程序员**释放内存(删除)**，这个过程是自动完成的；</p>
</blockquote>
</li>
<li><p><strong>堆</strong></p>
<blockquote>
<p><strong>堆</strong>是与当前函数与堆栈帧完全没有关系的内存区域。如果想在函数调用结束后仍保存其中声明的变量，可以将变量放到堆中。堆的结构并不复杂，可以将堆当作一个堆位。程序可在任何时候向堆中添加新位或修改堆中已有的位。**必须确保释放(删除)**在堆中分配的任何内存，这个过程不会自动完成，除非使用了智能指针；</p>
</blockquote>
</li>
</ul>
</blockquote>
<h5 id="2-使用指针"><a href="#2-使用指针" class="headerlink" title="2.使用指针"></a>2.<strong>使用指针</strong></h5><blockquote>
<ul>
<li><p><strong>在数据类型后加 <code>*</code></strong> ，将使之变为其类型的指针，但声明时，如果未初始化那么它可能指向一个随机的位置，而这时，这个指针很可能使得程序崩溃；所以，<strong>必须要在同时证明和初始化指针</strong>，如果不希望立即分配地址，则可以将它们<strong>初始化为空指针 nullptr</strong>；</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span>* myIntegerPointer = <span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>nullptr 是一个<strong>特殊默认值</strong>，可以在布尔表达式中被转化为 false;</p>
</li>
<li><p>使用 **new 操作符 **分配内存：</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">myIntegerPointer = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br></code></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>指针的解除引用</strong></p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">*myIntegerPointer = <span class="hljs-number">8</span>;<br><span class="hljs-comment">// 这并不是将 myIntegerPointer 的值设定为 8，而是将 myIntegerPointer 指向的内存设为 int 类型的整型 8</span><br><span class="hljs-comment">// 而如果真不是解除引用，而是调整 myIntegerPointer 为 8 则很有可能是一个随机无用的内存单元，最终导致程序崩溃</span><br></code></pre></td></tr></table></figure>

<p>可将解除引用看成沿着指针箭头方向寻找堆中实际的值；</p>
<p><strong>使用完 new 动态分配后的内存，需要使用 delete 操作符进行释放内存，为防止在释放指针指向的内存后再使用指针，建议把指针设置为 nullptr;</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">delete</span> myIntegerPointer;<br>myIntegerPointer = <span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></table></figure>

<p><strong>警告：</strong></p>
<blockquote>
<p><strong>在解除引用前指针必须有效！对 NULL 或未初始化的指针解除引用会导致不可确定的行为</strong>，程序可能崩溃，也可能继续运行，但可能会给出奇怪的结果；</p>
</blockquote>
</blockquote>
</li>
<li><p>指针并被总是指向堆内存，可声明一个指向堆栈中变量甚至指向其他指针的指针。为让指针指向某个变量，**需要使用“取”址运算符 &amp;**；</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">8</span>;<br><span class="hljs-type">int</span>* myIntegerPointer = &amp;i;<br></code></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>在 C++ 中，使用特殊语法来处理指向结构的指针。从技术角度上说，如果指针指向某个结构体，可以先<strong>用 * 对指针进行解除引用，然后使用普通的 . 语法来访问结构中的字段</strong>，以一个名为 getEmployee() 的函数作为示例：</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">Employee* anEmployee = <span class="hljs-built_in">getEmployee</span>();<br><span class="hljs-comment">// getEmployee() 是对 Employee 结构(类)的封装</span><br>std::cout &lt;&lt; (*anEmployee).salary &lt;&lt; endl;<br></code></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>除此以外，还可以<strong>使用 -&gt; 运算符同时对指针进行解引用并访问字段</strong>：</p>
<blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">Employee* amEmployee = <span class="hljs-title function_ invoke__">getEmployee</span>();<br>std::cout &lt;&lt; anEmployee<span class="hljs-punctuation">-&gt;</span>salary &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>注意：</strong></p>
<blockquote>
<p>记住前面所提到的短路逻辑，示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">bool</span> isValidSalary = (anEmployee &amp;&amp; anEmployee-&gt;salary &gt; <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>

<p>还可以用以下详细的方式复写：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">bool</span> isValidSalary = (anEmlpoyee != <span class="hljs-literal">null</span>ptr &amp;&amp; anEmployee-&gt;salary &gt; <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>

<p>这样，<strong>可以使得仅当 anEmployee 指针有效的时候，才可对其进行解除引用以获取薪水。如果它是一个空指针，则逻辑运算短路，不再解除引用 anEmployee 指针</strong>；</p>
</blockquote>
</li>
</ul>
</blockquote>
<h5 id="3-动态分配的数组"><a href="#3-动态分配的数组" class="headerlink" title="3.动态分配的数组"></a>3.<strong>动态分配的数组</strong></h5><blockquote>
<p>堆也可以用于动态分配数组。<strong>使用 new[] 操作符给数组分配内存</strong>；</p>
<p><img src="https://s2.loli.net/2024/02/09/xEkmeJX9yhDoYid.png" srcset="/img/loading.gif" lazyload alt="image-20240204093145571"></p>
<p>示例：</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> arraySize = <span class="hljs-number">8</span>;<br><span class="hljs-type">int</span>* myVariableSizeArray = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[arraySize];<br></code></pre></td></tr></table></figure>

<p>指针变量仍在堆栈中，但动态创建的数组在堆中；</p>
<p>完成这个数组后，应该将其堆中删除，这样其他变量就可以使用这块内存，在 C++ 中，可使用 <strong><code>delete[]</code></strong> 操作符完成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">delete</span> [] myVariableSizeArray;<br>myVariableSizeArray = <span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<blockquote>
<p>避免使用 C 中的 malloc() 和 free()，而使用 new 和 delete，或者使用 new[] 和 delete[];</p>
<p><strong><code>delete</code></strong> 后的方括号表明所删除的是一个数组；</p>
</blockquote>
</blockquote>
<p>注意：</p>
<blockquote>
<ul>
<li><p>在 C++ 中，每次调用 <strong><code>new</code></strong> 时，都必须相应地调用 delete；</p>
</li>
<li><p>在 C++ 中，每次调用 <strong><code>new []</code></strong> 时，必须相应地调用 **<code>delete []</code>**，以避免内存泄漏；</p>
</li>
<li><p>如果未调用 <strong><code>delete</code></strong> 或 **<code>delete []</code>**，或者调用不匹配，会导致内存泄漏。之后会详细讨论内存泄漏；</p>
</li>
</ul>
</blockquote>
</blockquote>
<h5 id="4-空指针常量"><a href="#4-空指针常量" class="headerlink" title="4.空指针常量"></a>4.<strong>空指针常量</strong></h5><blockquote>
<p>在 C++11 之前，常量 NULL 用于表示空指针。将 NULL 定义为常量 0，会导致一些问题，下面给出示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span> <span class="hljs-params">(<span class="hljs-type">char</span>* str)</span></span><br><span class="hljs-function"></span>&#123;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;char* version&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span> <span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;int version&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">func</span>(<span class="hljs-literal">NULL</span>);<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上述情况，由于使用的 NULL 指针等价于整数 0，所以调用的是 func 的整数版本，而非指针版本；</p>
<p>可引入真正的<strong>空指针常量 nullptr</strong> 来解决这个问题，给出代码：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-built_in">func</span>(<span class="hljs-literal">nullptr</span>);<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<h5 id="5-智能指针"><a href="#5-智能指针" class="headerlink" title="5.智能指针"></a>5.<strong>智能指针</strong></h5><blockquote>
<p>为避免常见的内存错误，应使用智能指针代替通常的 C 风格的 “裸” 指针，智能指针对象在<strong>超出作用域</strong>时(例如，在函数执行完毕后)，会<strong>自动释放内存</strong>，在 C++ 中，有两个最重要的智能指针；</p>
<p><strong>智能指针有时被视为右值引用，一般通过 std::move() 进行右值引用化。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 详见后面关于雇员记录系统设计的内容</span><br><span class="hljs-function">std::unique_ptr&lt;Employee&gt;&amp; <span class="hljs-title">Database::addEmployee</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; firstName,</span></span><br><span class="hljs-params"><span class="hljs-function">                                             <span class="hljs-type">const</span> std::string&amp; lastName)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">auto</span> theEmployee = std::<span class="hljs-built_in">make_unique</span>&lt;Employee&gt;(firstName, lastName);<br> theEmployee-&gt;<span class="hljs-built_in">setEmployeeNumber</span>(mNextEmployeeNumber++);<br> theEmployee-&gt;<span class="hljs-built_in">hire</span>();<br> mEmployees.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(theEmployee));<br><br> <span class="hljs-keyword">return</span> mEmployees[mEmployees.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-function">std::unique_ptr&lt;Employee&gt; <span class="hljs-title">Database::getEmployee</span><span class="hljs-params">(<span class="hljs-type">int</span> employeeNumber)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; employee : mEmployees)<br> &#123;<br>     <span class="hljs-keyword">if</span> (employee-&gt;<span class="hljs-built_in">getEmployeeNumber</span>() == employeeNumber)<br>     &#123;<br>         <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">move</span>(employee);<br>     &#125;<br> &#125;<br> <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">logic_error</span>(<span class="hljs-string">&quot;No employee found.&quot;</span>);<br>&#125;<br><br><span class="hljs-function">std::unique_ptr&lt;Employee&gt; <span class="hljs-title">Database::getEmployee</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; firstName,</span></span><br><span class="hljs-params"><span class="hljs-function">                                             <span class="hljs-type">const</span> std::string&amp; lastName)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; employee : mEmployees)<br> &#123;<br>     <span class="hljs-keyword">if</span> (employee-&gt;<span class="hljs-built_in">getFirstName</span>() == firstName &amp;&amp; employee-&gt;<span class="hljs-built_in">getLastName</span>() == lastName)<br>     &#123;<br>         <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">move</span>(employee);<br>     &#125;<br> &#125;<br> <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">logic_error</span>(<span class="hljs-string">&quot;No employee found.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>


</blockquote>
<h6 id="1-std-unique-ptr"><a href="#1-std-unique-ptr" class="headerlink" title="1.std::unique_ptr"></a>1.std::unique_ptr</h6><blockquote>
<ul>
<li><p><strong><code>std::make_unique&lt;elementType&gt;()</code></strong>	</p>
</li>
<li><p><strong>数组，允许：	<code>std::make_unique&lt;elementType[]&gt;(listSize)</code></strong></p>
</li>
<li><p><strong><code>std::unique_ptr&lt;elementType&gt; elementName (new elementType);</code></strong></p>
</li>
<li><p><strong>数组，允许：	<code>std::unique_ptr&lt;elementType[]&gt; elementName (new elementType[listSize]);</code></strong></p>
</li>
<li><p><strong><code>std::unique_ptr </code></strong> 类似于普通指针，但在它超出作用域或者被删除时，会自动释放内存或资源。**<code>std::unique_ptr</code>** 只属于它指向的对象。它的优点是：内存和资源始终被释放，即使执行返回语句或抛出异常(见稍后的讨论)。这极大地简化了代码，例如，如果有一个函数有多个返回语句，可以不必记着每个返回语句前释放资源。</p>
</li>
<li><p>要创建 **<code>std::unique_ptr</code>**，应当使用 **<code>std::make_unique&lt;&gt;()</code>**，例如，不要编写以下代码：</p>
</li>
</ul>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">Employee* anEmployee = <span class="hljs-keyword">new</span> Employee;<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">delete</span> anEmployee;<br></code></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>而应当编写以下代码：</li>
</ul>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> anEmployee = std::<span class="hljs-built_in">make_enique</span>&lt;Employee&gt;();<br><br><span class="hljs-comment">// 关于 () 内参数设定，示例：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> <br>&#123;<br>	<span class="hljs-keyword">public</span>:<br> 	<span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> value1, <span class="hljs-type">double</span> value2);<br> 	<span class="hljs-comment">// Other members...</span><br>&#125;;<br><span class="hljs-keyword">auto</span> myObject = std::<span class="hljs-built_in">make_unique</span>&lt;MyClass&gt;(<span class="hljs-number">42</span>, <span class="hljs-number">3.14</span>);<br></code></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>注意，这样一来，将不再需要调用 delete，因为这将自动完成。本章后面的类型推断将详细讲解 auto 关键字(这里先不详细说明)。这里只需要了解，auto 关键字告诉编译器自动推断变量的类型，因此你不必手动指定完整类型；</p>
</li>
<li><p>std::unique_ptr 是一个通用的智能指针，他可以指向任意类型的内存，所以，它本质上是一个模板。模板需要尖括号来指定模板类型参数。在尖括号中必须指定 unique_ptr 要指向的内存类型。模板详见第12章、第22章，而智能指针在本书开头介绍，可见，事实上，它们使用起来很简单；</p>
</li>
<li><p>make_unique() 在 C++14 中被引入，如果用户编译器与 C++14 不兼容，可使用如下形式的 unique_ptr(注意，现在必须将 Employee 类型指定两次)：</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::unique_ptr&lt;Employee&gt; <span class="hljs-title">anEmployee</span> <span class="hljs-params">(<span class="hljs-keyword">new</span> Employee)</span></span>;<br></code></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>可以像普通指针那样使用 anEmployee 智能指针，例如：</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (anEmployee)<br>&#123;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;Salary: &quot;</span> &lt;&lt; anEmployee-&gt;salary &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>此外，<strong>unique_ptr</strong> 也可以储存 C 风格的数组，下例创建了一个包含 10 个 Employee 示例的数组，将其存储在 <strong>unique_ptr</strong> 中，并显示如何访问数组中的元素：</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> employees = std::<span class="hljs-built_in">make_unique</span>&lt;Employee[]&gt;(<span class="hljs-number">10</span>);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Salary: &quot;</span> &lt;&lt; employees[<span class="hljs-number">0</span>].salary &lt;&lt; std::endl;<br><br><span class="hljs-comment">// 使用 C 风格的不兼容处理</span><br><span class="hljs-function">std::unique_ptr&lt;Employee[]&gt; <span class="hljs-title">employees</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Employee[<span class="hljs-number">10</span>])</span></span>;<br></code></pre></td></tr></table></figure>
</blockquote>
<ul>
<li><p>辨析：</p>
<blockquote>
<ol>
<li><p>上面的代码使用 <strong><code>anEmployee-&gt;salary</code></strong> 而非**<code>anEmployee.salary</code><strong>，是因为</strong><code>anEmployee</code>** 是一个指向 <strong><code>Employee</code></strong> 对象的 **<code>unique_ptr</code>**，而不是直接的对象，-&gt; 的作用是解引用并访问成员，. 的作用是访问成员；</p>
</li>
<li><p>下面的代码使用**<code> employees[0].salary</code>** 而非 <strong><code> employees[0]-&gt;salary</code></strong> ，因为，**<code>employees</code>** 是一个指向动态分配数组的 <strong><code>std::unique_ptr</code></strong> ，可见，[] 符能起到解引用的作用，. 的作用认识访问成员；</p>
</li>
</ol>
</blockquote>
</li>
</ul>
</li>
</ul>
</blockquote>
<h6 id="2-std-shared-ptr"><a href="#2-std-shared-ptr" class="headerlink" title="2.std::shared_ptr"></a>2.<strong>std::shared_ptr</strong></h6><blockquote>
<ul>
<li><p><strong><code>std::make_shared&lt;elementType&gt;()</code></strong>		</p>
</li>
<li><p><strong>数组，不允许：	<code>std::make_shared&lt;elementType[]&gt;(listSize)</code></strong></p>
</li>
<li><p><strong><code>std::shared_ptr&lt;elementType&gt; elementName (new elementType);</code></strong></p>
</li>
<li><p><strong>数组，仅允许：	<code>std::shared_ptr&lt;elementType[]&gt; elementName (new elementType[listSize]);</code></strong></p>
</li>
<li><p><strong><code>std::shared_ptr</code></strong> 允许数据的分布式“所有权”，每次指定 <strong><code>std::shared_ptr</code></strong> 时，都递增一个引用计数，指出数据又多出了一位“拥有者”。当它超出作用域时，就递减引用计数，当引用计数为 0 时，就表示数据不再拥有任何拥有者，于是释放指针引用的对象；</p>
</li>
<li><p>要创建 **<code>std::shared_ptr</code>**，应当使用 <strong><code>std::make_shared&lt;&gt;()</code><strong>，它与</strong><code>std::make_unique&lt;&gt;()</code></strong>:</p>
</li>
</ul>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> anEmployee = std::<span class="hljs-built_in">make_unique</span>&lt;Employee&gt;();<br><span class="hljs-keyword">if</span> (anEmployee)<br>&#123;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;Salary: &quot;</span> &lt;&lt; anEmployee-&gt;salary &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>从 C++17 开始，也可以将数组存储在 <strong><code>std::shared_ptr</code></strong> 中，而旧版的 C++ 是不允许的。但注意，此时不能使用 C++17 中的 **<code>make_shared&lt;&gt;()</code>**，示例：</li>
</ul>
<blockquote>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">std</span>::shared_ptr&lt;Employee[]&gt; employees(<span class="hljs-built_in">new</span> Employee[<span class="hljs-number">10</span>]);<br><span class="hljs-built_in">std</span>::cout &lt;&lt; <span class="hljs-string">&quot;Salary: &quot;</span> &lt;&lt; employees[<span class="hljs-number">0</span>].salary &lt;&lt; <span class="hljs-built_in">std</span>::endl;<br></code></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<p>​	第七章将详细阐述内存管理和智能指针，但由于 <strong>std::unique_ptr</strong> 和 <strong>std::shared_ptr</strong> 的基本用法十分简单，所以，在这里阐述；</p>
<h6 id="3-注意"><a href="#3-注意" class="headerlink" title="3.注意"></a>3.<strong>注意</strong></h6><blockquote>
<ul>
<li><p><strong>普通的裸指针仅允许在不涉及所有权时使用，否则默认使用  <code>std::unique_ptr</code>；</strong></p>
</li>
<li><p><strong>如果有需要共享所有权，就使用  <code>std::shared_ptr</code>；</strong></p>
</li>
<li><p><strong>如果知道 <code>auto_ptr</code>，应当忘记它，因为 C++ 11&#x2F;14 不赞成使用它，而 C++17 已经废弃它；</strong></p>
</li>
<li><p><strong>如果第二种表示法：<code>std::XXX_ptr&lt;elementType&gt; elementName (new elementType);</code>中构造函数抛出异常，那么就会出现内存泄漏</strong></p>
</li>
</ul>
</blockquote>
<hr>
<h4 id="2-3const-的多种用法"><a href="#2-3const-的多种用法" class="headerlink" title="2.3	const 的多种用法"></a><strong>2.3	const 的多种用法</strong></h4><blockquote>
<p>可以使用 auto 来去除 const 函数性质</p>
</blockquote>
<h5 id="1-使用-const-定义常量"><a href="#1-使用-const-定义常量" class="headerlink" title="1.使用 const 定义常量"></a>1.<strong>使用 const 定义常量</strong></h5><blockquote>
<ul>
<li><p>在 C 中，通常使用预处理器的 #define 机制来声明一个符号名称，其值在程序执行时不会改变；</p>
</li>
<li><p>在 C++ 中，鼓励使用 const 代替 #define 定义常量，使用 const 定义常量就像定义变量一样，只是编译器保证代码不会改变这个值；</p>
</li>
<li><p>示例：</p>
<blockquote>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">const</span> <span class="hljs-type">int</span> versionNumberMajor = <span class="hljs-number">2</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> versionNumberMinor = <span class="hljs-number">1</span>;<br><span class="hljs-type">const</span> std::string productName = <span class="hljs-string">&quot;Super Hyper Net Modulator&quot;</span>;<br></code></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</blockquote>
<h5 id="2-使用-const-保护参数"><a href="#2-使用-const-保护参数" class="headerlink" title="2.使用 const 保护参数"></a>2.<strong>使用 const 保护参数</strong></h5><blockquote>
<ul>
<li><p>在 C++ 中，可将非 const 变量转换为 const 变量，这可以提供一定保护，防止其他代码修改变量。如果程序试图改变参数的值，编译不会完成；</p>
</li>
<li><p>示例：</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mysteryFunction</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string* someString)</span></span><br><span class="hljs-function"></span>&#123;<br>	*someString = <span class="hljs-string">&quot;Test&quot;</span>;<br>	<span class="hljs-comment">// Will not complie</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	std::string myString = <span class="hljs-string">&quot;The string&quot;</span>;<br>	<span class="hljs-built_in">mysteryFunction</span>(&amp;myString);<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</blockquote>
<hr>
<h4 id="2-4引用"><a href="#2-4引用" class="headerlink" title="2.4	引用"></a><strong>2.4	引用</strong></h4><blockquote>
<ul>
<li>C++ 允许使用给已有变量定义另一个名称：</li>
</ul>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x = <span class="hljs-number">42</span>;<br><span class="hljs-type">int</span>&amp; xReference = x;<br>std::cout &lt;&lt; xReference;<br><br><span class="hljs-comment">// 对比上下两者的不同</span><br><span class="hljs-type">int</span>* xPointer = &amp;x;<br>std::cout &lt;&lt; *xPointer;<br></code></pre></td></tr></table></figure>

<p>给类型附加 &amp;，则指示相应的变量是引用。在幕后他是一个指向原始变量的指针；</p>
</blockquote>
</blockquote>
<h5 id="1-按引用传递"><a href="#1-按引用传递" class="headerlink" title="1.按引用传递"></a><strong>1.按引用传递</strong></h5><blockquote>
<p>区别于值传递(制作副本)，不会改变原始变量的值；</p>
<p>按引用传递参数是引用而非指针，在执行函数时，会改变原始变量的值；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 传值版本</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addOne</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>	i++;<br>	<span class="hljs-comment">// Has no real effect because this is a copy of the original</span><br>&#125;<br><br><span class="hljs-comment">// 传引用版本</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addOne</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; i)</span></span><br><span class="hljs-function"></span>&#123;<br>i++;<br><span class="hljs-comment">// Actually change the original variable</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意：</p>
<blockquote>
<p>对于两个版本的 addOne() 函数：</p>
<p>当前者传入字面量时，是可行的；</p>
<p>当后者传入字面量时，会导致编译错误；</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">addOne</span>(<span class="hljs-number">3</span>);<br><span class="hljs-comment">// 这对后者来说需要改变 3 的值，显然是不可能的</span><br><span class="hljs-comment">// 此外，还可以通过右值引用来解决，这将在之后讨论</span><br></code></pre></td></tr></table></figure>
</blockquote>
<p>此外，在 C++11 之前推荐使用这种非 const 引用，但 C++11 开始，再也不这么做了，因为存在了 move 语义(之后讨论)；</p>
</blockquote>
<h5 id="2-按-const-引用传递"><a href="#2-按-const-引用传递" class="headerlink" title="2.按 const 引用传递"></a><strong>2.按 const 引用传递</strong></h5><blockquote>
<p>由于制作副本，代价较大，所以，使用不改变值的引用传递，示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printString</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; myString)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; myString &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::string someString = <span class="hljs-string">&quot;Hello World&quot;</span>;<br><span class="hljs-built_in">printString</span>(someString);<br><span class="hljs-built_in">printString</span>(<span class="hljs-string">&quot;Hello World&quot;</span>);	<span class="hljs-comment">// Passing literals works</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<h5 id="3-注意-1"><a href="#3-注意-1" class="headerlink" title="3.注意"></a><strong>3.注意</strong></h5><blockquote>
<p>如需要给函数传递对象，最好按 const 引用(而非值)传递，这样可以防止多余复制；</p>
<p>如果需要修改对象，则为其传递非 const 引用；</p>
</blockquote>
<hr>
<h4 id="2-5异常"><a href="#2-5异常" class="headerlink" title="2.5	异常 &amp; "></a><strong>2.5	异常 &amp; <stdexcept></strong></h4><blockquote>
<ul>
<li><p><strong>C++是一种非常灵活的语言，但并不是非常安全</strong>，编译器通编写改变随机内存地址或尝试除以 0  的代码(计算机无法处理无穷大的数值)。<strong>异常就是试图增加一点安全性的语言特性；</strong></p>
</li>
<li><p>异常是一种无法预料的情形，例如如果编写一个获取web页面的函数 ，就有几件事可能出错，包含页面的 Internet 主机可能被关闭，页面可能是空白的，或者连接可能会丢失。处理这种情况的一种方法是从函数返回特定的值，如 nullptr 或其他错误代码。异常提供了处理此类问题的更好方法；</p>
</li>
<li><p>一场伴随着一些新的术语。当某段代码检测到异常时就会抛出一个异常，另一段代码会捕捉这个异常并执行恰当的操作。 下例给出一个名为 divideNumber() 的函数，如果调用者传递给分母的值为0，就会抛出一个异常。使用 <strong><code>std::invalid_arugment</code></strong> 时需要**<code> &lt;stdexcept&gt;</code>**:</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">divideNumbers</span><span class="hljs-params">(<span class="hljs-type">double</span> numerator, <span class="hljs-type">double</span> denominator)</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">if</span> (denominator == <span class="hljs-number">0</span>)<br> &#123;<br>     <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Denominator cannot be 0.&quot;</span>);<br>     <span class="hljs-comment">// 此处为抛出异常</span><br>     <span class="hljs-comment">// 详细内容将在异常章节讲述</span><br> &#125;<br> <span class="hljs-keyword">return</span> numerator / denominator;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>当执行 throw 行时，程序会立即结束而且不会返回值。</strong>如果调用者将函数调用放到 try &#x2F; catch块中就可以辅助捕获异常并进行处理，示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">try</span> <br>&#123;<br>	std::cout &lt;&lt; <span class="hljs-built_in">divideNumbers</span>(<span class="hljs-number">2.5</span>, <span class="hljs-number">0.5</span>) &lt;&lt; std::endl;<br>	std::cout &lt;&lt; <span class="hljs-built_in">divideNumbers</span>(<span class="hljs-number">2.3</span>, <span class="hljs-number">0</span>) &lt;&lt; std::endl;<br>	std::cout &lt;&lt; <span class="hljs-built_in">divideNumbers</span>(<span class="hljs-number">4.5</span>, <span class="hljs-number">2.5</span>) &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::invalid_argument&amp; exception)<br>&#123;<br>	std::cout &lt;&lt; <span class="hljs-string">&quot;Expression caught: &quot;</span> &lt;&lt; exception.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><p><strong>第一次调用 divideNumbers() 成功执行，结果会输出给用户；</strong></p>
</li>
<li><p><strong>第二次调用 divideNumbers() 会抛出一个异常，不会返回值，唯一的输出是捕获异常时输出的错误信息；</strong></p>
</li>
<li><p><strong>第三次调用 根本不会执行，因为第二次调用抛出了一个异常，导致程序跳转到 catch 块；</strong></p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">5</span><br>Expression caught: Denominator cannot be <span class="hljs-number">0.</span><br></code></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</blockquote>
</li>
<li><p><strong>C++ 的异常非常灵活，为了正确使用异常，需要理解抛出异常时堆栈变量的行为，必须正确捕获并处理必要的异常</strong>。前面的示例中使用了内建的 **<code>std::invalid_argument </code>**类型，但最好根据所抛出的具体错误编写自己的异常类型。最后，C++ 编译器并不强制要求捕获可能发生的所有异常。如果代码从不捕获任何异常，但有异常抛出，程序自身会捕获异常并终止。第14章将进一步讨论异常的这些更复杂方面；</p>
</li>
</ul>
</blockquote>
<h4 id="2-6类型推断"><a href="#2-6类型推断" class="headerlink" title="2.6	类型推断"></a><strong>2.6	类型推断</strong></h4><blockquote>
<ul>
<li><strong>类型推断允许编译器自动推断出表达式的类型。类型推断有两个关键词 auto 和 decltype;</strong></li>
</ul>
</blockquote>
<h5 id="1-关键字-auto"><a href="#1-关键字-auto" class="headerlink" title="1.关键字 auto"></a>1.<strong>关键字 auto</strong></h5><blockquote>
<p><strong>多种完全不同的含义：</strong></p>
<ul>
<li><p>推断函数的返回类型如前所述结构化绑定，如前所述；</p>
</li>
<li><p>推断表达式的类型，如前所述；</p>
</li>
<li><p>推断非类型模板参数的类型，见第12章；</p>
</li>
<li><p>decltype(auto)，见第12章；</p>
</li>
<li><p>其他函数语法，见第12章。</p>
</li>
<li><p>通用 Lambda 表达式，见第18章；</p>
<blockquote>
<ul>
<li><p>auto 可用于告诉编译器在编译时自动推断变量的类型。下面的代码演示了在这种情况下关键字 auto 最简单的用法： </p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> x =<span class="hljs-number">123</span>;<br><span class="hljs-comment">// x will be of type int </span><br></code></pre></td></tr></table></figure>

<p>在这个示例中输入 auto 和输入 int 的效果没有区别，但 auto 对于较复杂的类型会更有用。假定 getFoo() 函数有一个复杂的返回类型。如果希望把调用该函数的结果赋予一个变量,就可以输入该复杂类型，也可以简单的使用 auto 让编译器推断出该类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> result = <span class="hljs-built_in">getFoo</span>();<br></code></pre></td></tr></table></figure>

<p>这样，你可以方便地更改函数的返回类型，而不需要更新代码中调用该函数的所有位置；</p>
</blockquote>
</li>
<li><p>但使用 auto 去除了引用和 const 限定符号。假设有以下函数：</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-type">const</span> std::string message = <span class="hljs-string">&quot;Test&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-keyword">return</span> message;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以调用 Foo()，把结果存储在一个变量中，将该变量的类型指定为auto，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> f1 = <span class="hljs-built_in">foo</span>();<br></code></pre></td></tr></table></figure>

<p>因为 auto 去除了引用和 const 限定符，且 f1 是 string 类型，所以建立一个副本。如果希望 f1 是一个 const 引用，就可以明确将它建立为一个引用，并标记为 const 如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; f2 = <span class="hljs-built_in">foo</span>();<br><br><span class="hljs-comment">// 补充</span><br>std::cout &lt;&lt; <span class="hljs-built_in">typeid</span>(element).<span class="hljs-built_in">name</span>();<br><span class="hljs-comment">// 为 type_info 类型   </span><br><br>或者<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeindex&gt;</span>	<span class="hljs-comment">// 必需 &lt;typeindex&gt;</span></span><br>std::cout &lt;&lt; std::<span class="hljs-built_in">type_index</span>(<span class="hljs-built_in">typeid</span>(element)).<span class="hljs-built_in">name</span>();<br><span class="hljs-comment">// 为与 type_info 类似的类，但提供了比 type_info 更好的比较和哈希功能</span><br></code></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>注意</strong>：</p>
<blockquote>
<p><strong>始终要记住，auto 去除了引用和 const 限定符，从而会创建副本！如果不需要副本，可使用 auto&amp; 或 const auto&amp;；</strong></p>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h5 id="2-关键字-decltype"><a href="#2-关键字-decltype" class="headerlink" title="2.关键字 decltype"></a>2.<strong>关键字 decltype</strong></h5><blockquote>
<p><strong>关键词 decltype 把表达式作为实参，计算出该表达式的类型</strong>，示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x = <span class="hljs-number">123</span>;<br><span class="hljs-keyword">decltype</span>(x) y = <span class="hljs-number">456</span>;<br></code></pre></td></tr></table></figure>

<p>在这个示例中，<strong>编译器会推断出 y 的类型是 int，因为这是 x 的类型；</strong></p>
<p><strong>auto 与 decltype 的区别在于，decltype 未除引用和 const 限定符。再来分析返回 const string引用的 foo() 函数。按照如下方式使用 decltype 定义 f2，导致 f2 的类型为 const string&amp;，从而不生成副本：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">foo</span>()) f2 = <span class="hljs-built_in">foo</span>();<br></code></pre></td></tr></table></figure>

<p>刚开始不会觉得 decltype 有多大价值。但<strong>在模板环境中，decltype 会变得十分强大</strong>，详见第12 和第 22 章；</p>
</blockquote>
<hr>
<h3 id="1-3-作为面向对象语言的-C"><a href="#1-3-作为面向对象语言的-C" class="headerlink" title="1.3    作为面向对象语言的 C++"></a><strong>1.3    作为面向对象语言的 C++</strong></h3><hr>
<ul>
<li>如果你是一位 C 程序员，可能会认为本章讲述的内容到目前为止只是传统 C 语言的补充最好顾名思义，C++语言在很多方面只是“更好的C”。这种观点忽略了一个重点：与 C 不同 C++ 是一种面向对象的语言；</li>
<li><strong>面向对象程序设计 <em>(OPP)</em></strong> 是一种完全不同的、更趋自然的编码方式。如果习惯使用过程语言，如 C 或者 Pascal，不要担心。第五章的讲述将观念转换到面向对象范型所需的所有背景知识。如果你已经了解OPP的理论，下面的内容将帮助你加速了解 (或者回顾) 基本的 C++ 对象语法；</li>
</ul>
<h4 id="3-1定义类"><a href="#3-1定义类" class="headerlink" title="3.1	定义类"></a><strong>3.1	定义类</strong></h4><blockquote>
<ul>
<li><p><strong>类定义了对象的特征。在 C++ 中，类通常在头文件 (.h) 中声明，在对应的源文件 (.cpp) 中定义其并 非内联 方式和静态数据成员；</strong></p>
</li>
<li><p>下面示例定义了一个基本的<strong>机票类</strong>，这个类可根据飞行的里程数以及顾客是不是“精英超级奖励计划”的成员计算票价。这个定义<strong>首先声明一个类名</strong>，在大括号内声明了类的数据成员(属性)以及方法(行为)。 每个数据成员以及方法都具有特定的访问级别：<strong>public</strong>、<strong>protected</strong> 或 <strong>private</strong>。这些标记可按任意顺序出现，也可重复使用。<strong>public 成员可在类的外部访问，private 成员不能在类的外部访问，推荐把所有的数据成员都声明为 private,在需要时，可通过 public 读取器和设置器来访问它们。</strong>  <strong>这样，就很容易改变数据的表达方式，同时使 public 接口保持不变。</strong>关于 protected 的用法，将在第 5 和 10 章中介绍“继承”时讲解。</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// AirlineTicket.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AirlineTicket</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br> <span class="hljs-comment">// 构造类</span><br> <span class="hljs-built_in">AirlineTicket</span>();<br><br> <span class="hljs-comment">// 析构类</span><br> ~<span class="hljs-built_in">AirlineTicket</span>();<br><br> <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">calculatePriceInDollars</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br> <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getPassengerName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setPassageName</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name)</span></span>;<br><br> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getNumberOfMiles</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setNumberOfMiles</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> miles)</span></span>;<br><br> <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasEliteSuperRewardsStatus</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setHasEliteSuperRewardsStatus</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">bool</span> status)</span></span>;<br><span class="hljs-keyword">private</span>:<br> std::string mPassengerName;<br> <span class="hljs-type">int</span> mNumberOfMiles;<br> <span class="hljs-type">bool</span> mHasEliteSuperRewardsStatus;<br>&#125;;<br><br><span class="hljs-comment">// 约定：在类的每个数据成员之前加上小写字母 m, 如 mPassengefName</span><br></code></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<blockquote>
<p><strong>为遵循 const 正确性原则，最好将不改变对象的任何数据成员的成员函数声明为 const。相对于非 const 成员函数“修改器”，这些成员函数也称为 “检测器”。</strong></p>
</blockquote>
<ul>
<li><strong>构造函数的初始化：</strong></li>
</ul>
<ol>
<li><p><strong>更推荐的</strong>，使用<strong>构造函数初始化器</strong><em><strong>(constructor initializer)</strong></em></p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 构造函数</span><br><span class="hljs-comment">// AirlineTicket.h</span><br><span class="hljs-comment">// 推荐使用构造函数初始化器</span><br>AirlineTicket::<span class="hljs-built_in">AirlineTicket</span>()<br> : <span class="hljs-built_in">mPassengerName</span>(<span class="hljs-string">&quot;Unknown Passenger&quot;</span>)<br> , <span class="hljs-built_in">mNumberOfMiles</span>(<span class="hljs-number">0</span>)<br> , <span class="hljs-built_in">mHasEliteSuperRewardsStatus</span>(<span class="hljs-literal">false</span>)<br>&#123;<br>&#125;  <br></code></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>将初始化任务放在构造函数体内</strong></p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// AirlineTicket.h</span><br>AirlineTicket::<span class="hljs-built_in">AirlineTicket</span>()<br>&#123;<br>	<span class="hljs-comment">//Initialize data member</span><br>	mPassengerName = <span class="hljs-string">&quot;Unknown Passsenger&quot;</span>;<br>	mNumberOfMiles = <span class="hljs-number">0</span>;<br>	mHasEliteSuperRewardsStatus = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote>
</li>
</ol>
<ul>
<li><p>如果构造函数只是初始化数据成员，而不做其他事情，实际上就没必要使用构造函数，因为可在类定义中直接初始化数据成员。例如，不编写 AirlineTicket 构造函数，而是修改类定义中数据成员的定义，如下所示：  </p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// AirlineTicket.h</span><br><span class="hljs-keyword">private</span>:<br>	std::string nPassengerName = <span class="hljs-string">&quot;Unknown Passenger&quot;</span>;<br>	<span class="hljs-type">int</span> mNumberOfMiles = <span class="hljs-number">0</span>;<br>	<span class="hljs-type">bool</span> mHasEliteSuperRewardsStatus = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure>

<p>如果类还需要执行其他的一些初始化类型，如打开文件、分配内存等，则需要编写构造函数进行处理；</p>
</blockquote>
</li>
<li><p><strong>析构函数</strong></p>
<blockquote>
<p>如下所示，为 AirlineTicket 类的析构函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">AirlineTicket::~<span class="hljs-built_in">AirlineTicket</span>()<br>&#123;<br> <span class="hljs-comment">// Nothing much to do in terms of cleanup</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个析构函数什么都不做，因此可以从类中删除，这里之所以需要显示它，是为了更好了解析构函数的语法；如果需要执行一些清理，如关闭文件、释放内存等，则需要使用析构函数；</p>
</blockquote>
</li>
<li><p><strong>AirlinTicket 的其他类方法</strong></p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// AirlineTicket.cpp</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">AirlineTicket::calculatePriceInDollars</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">hasEliteSuperRewardsStatus</span>())<br> &#123;<br>     <span class="hljs-comment">// Elite Super Rewards customers fly for free</span><br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125;<br> <span class="hljs-comment">// The cost of the ticket is the number of mile times 0.1.</span><br> <span class="hljs-comment">// Real airlines probably have a more complicated formula!</span><br> <span class="hljs-keyword">return</span> <span class="hljs-built_in">getNumberOfMiles</span>() * <span class="hljs-number">0.1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">AirlineTicket::getPassengerName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">return</span> mPassengerName;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AirlineTicket::setPassengerName</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name)</span></span><br><span class="hljs-function"></span>&#123;<br> mPassengerName = name;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">AirlineTicket::getNumberOfMiles</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">return</span> mNumberOfMiles;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AirlineTicket::setNumberOfMiles</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> miles)</span></span><br><span class="hljs-function"></span>&#123;<br> mNumberOfMiles = miles;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">AirlineTicket::hasEliteSuperRewardsStatus</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">return</span> mHasEliteSuperRewardsStatus;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AirlineTicket::setHasEliteSuperRewardsStatus</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">bool</span> status)</span></span><br><span class="hljs-function"></span>&#123;<br> mHasEliteSuperRewardsStatus = status;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<h4 id="3-2使用类"><a href="#3-2使用类" class="headerlink" title="3.2	使用类"></a><strong>3.2	使用类</strong></h4><blockquote>
<p>下面示例程序给出了如何使用 AirlineTicket 类。这个示例创建的两个 AirlineTicket 对象分别给予堆栈和堆：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// testAirlineTicket.cpp</span><br><br><span class="hljs-comment">// Stack-based(堆栈) AirlineTicket</span><br><span class="hljs-comment">// 优点：</span><br><span class="hljs-comment">//    1.简单直观，不需要动态内存管理。</span><br><span class="hljs-comment">// 缺点：</span><br><span class="hljs-comment">//    1.对象的生命周期受限于其所在的作用域，一旦超出作用域，对象将被销毁。</span><br>AirlineTicket myTicket;<br>myTicket.<span class="hljs-built_in">setPassengerName</span>(<span class="hljs-string">&quot;Sherman T. Socketwrench&quot;</span>);<br>myTicket.<span class="hljs-built_in">setNumberOfMiles</span>(<span class="hljs-number">700</span>);<br><span class="hljs-type">double</span> cost = myTicket.<span class="hljs-built_in">calculatePriceInDollars</span>();<br>std::cout &lt;&lt; <span class="hljs-string">&quot;This ticket will cost $&quot;</span> &lt;&lt; cost &lt;&lt; std::endl;<br><span class="hljs-comment">/*--------------------------------------------------------------------------*/</span><br><br><span class="hljs-comment">// Heap-based(堆) AirlineTicket with smart pointer</span><br><span class="hljs-comment">// 推荐，使用</span><br><span class="hljs-comment">// 优点：</span><br><span class="hljs-comment">//    1.动态分配的内存由 std::unique_ptr 管理，无需手动释放内存。</span><br><span class="hljs-comment">//    2.可以更灵活地控制对象的生命周期</span><br><span class="hljs-comment">// 缺点：</span><br><span class="hljs-comment">//    1.相对于栈上创建，略微复杂</span><br><span class="hljs-keyword">auto</span> myTicket2 = std::<span class="hljs-built_in">make_unique</span>&lt;AirlineTicket&gt;();<br>myTicket2-&gt;<span class="hljs-built_in">setPassengerName</span>(<span class="hljs-string">&quot;Laudimore M. Hallidue&quot;</span>);<br>myTicket2-&gt;<span class="hljs-built_in">setNumberOfMiles</span>(<span class="hljs-number">2000</span>);<br>myTicket2-&gt;<span class="hljs-built_in">setHasEliteSuperRewardsStatus</span>(<span class="hljs-literal">true</span>);<br><span class="hljs-type">double</span> cost2 = myTicket2-&gt;<span class="hljs-built_in">calculatePriceInDollars</span>();<br>std::cout &lt;&lt; <span class="hljs-string">&quot;This other ticket will cost $&quot;</span> &lt;&lt; cost2 &lt;&lt; std::endl;<br><span class="hljs-comment">// No need to delete myTicket2, happens automatically</span><br><span class="hljs-comment">/*--------------------------------------------------------------------------*/</span><br><br><span class="hljs-comment">// Heap-based AirlineTicket without smart pointer (not recommended)</span><br><span class="hljs-comment">// 不推荐，也不要使用</span><br><span class="hljs-comment">// 优点：</span><br><span class="hljs-comment">//    1.可以手动控制对象的生命周期。</span><br><span class="hljs-comment">// 缺点：</span><br><span class="hljs-comment">//    1.容易出现内存泄漏或释放已删除的内存，因为没有智能指针进行内存管理。</span><br><span class="hljs-comment">//    2.必须手动调用 delete 来释放内存，容易出现忘记释放或者释放多次的问题。</span><br>AirlineTicket* myTicket3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AirlineTicket</span>();<br><span class="hljs-comment">// ... Use ticket 3</span><br><span class="hljs-keyword">delete</span> myTicket3;<br></code></pre></td></tr></table></figure>
</blockquote>
<hr>
<h3 id="1-4-统一初始化"><a href="#1-4-统一初始化" class="headerlink" title="1.4    统一初始化"></a><strong>1.4    统一初始化</strong></h3><h5 id="1-结构与类的初始化"><a href="#1-结构与类的初始化" class="headerlink" title="1.结构与类的初始化"></a><strong>1.结构与类的初始化</strong></h5><blockquote>
<h5 id="在-C-之前，初始化类型并非总是统一的。例如，考虑下面的两个定义，其中一个作为结构，另一个作为类，示例："><a href="#在-C-之前，初始化类型并非总是统一的。例如，考虑下面的两个定义，其中一个作为结构，另一个作为类，示例：" class="headerlink" title="在 C++之前，初始化类型并非总是统一的。例如，考虑下面的两个定义，其中一个作为结构，另一个作为类，示例："></a><strong>在 C++之前，初始化类型并非总是统一的。例如，考虑下面的两个定义，其中一个作为结构，另一个作为类，示例：</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CircleStruct</span><br>&#123;<br>	<span class="hljs-type">int</span> x, y;<br>	<span class="hljs-type">double</span> radius;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CircleClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>	<span class="hljs-comment">// 使用成员初始化列表可以提高性能</span><br>	<span class="hljs-built_in">CircleClass</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">double</span> radius)<br>      : <span class="hljs-built_in">mX</span>(x), <span class="hljs-built_in">mY</span>(y), <span class="hljs-built_in">mRadius</span>(radius)<br>   &#123;<br><br>   &#125;<br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">	CircleClass(int x = 1, int y = 1, double radius = 3)</span><br><span class="hljs-comment">		: mX(x), mY(y), mRadius(radius)</span><br><span class="hljs-comment">		&#123;</span><br><span class="hljs-comment">		// 这样实现默认值填充</span><br><span class="hljs-comment">		&#125;</span><br><span class="hljs-comment">		*/</span><br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-type">int</span> mX, mY;<br>	<span class="hljs-type">double</span> mRadius;<br>&#125;;<br><br><span class="hljs-comment">// 复写 Circle 类，使之更符合现代 C++ 关于默认初始变量设置的通常做法</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CircleClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br> <span class="hljs-built_in">Circle</span>() = <span class="hljs-keyword">default</span>;<br>	<span class="hljs-comment">// 使用成员初始化列表可以提高性能</span><br>	<span class="hljs-built_in">CircleClass</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">double</span> radius)<br>      : <span class="hljs-built_in">mX</span>(x), <span class="hljs-built_in">mY</span>(y), <span class="hljs-built_in">mRadius</span>(radius)<br>   &#123;<br><br>   &#125;<br><br><span class="hljs-keyword">private</span>:<br>	<span class="hljs-type">int</span> mX = <span class="hljs-number">1</span>;<br> 	<span class="hljs-type">int</span> mY = <span class="hljs-number">1</span>;<br>	<span class="hljs-type">double</span> mRadius = <span class="hljs-number">3</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>在 C++11 之前，CircleStruct 类型变量和CircleClass 类型变量的初始化是不同的，对于结构版本，可使用 {…} 语法。然而，对于类版本，需要使用函数符号 (…) 调用构造函数。  ：</strong>  </p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">CircleStruct myCirclel = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2.5</span>&#125;;<br><span class="hljs-function">CircleClass <span class="hljs-title">myCircle2</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2.5</span>)</span></span>;<br></code></pre></td></tr></table></figure>
</blockquote>
<p><strong>自 C++11 以后，允许一律使用 {… }语法初始化类型，如下所示：</strong>  </p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">CircleStruct myCircle3 = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2.5</span>&#125;;<br>CircleClass myCircle4 = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2.5</span>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>定义 myCircle4 时将自动调用 CircleClass 的构造函数。甚至等号也是可选的，因此下面的代码与前面的代码等价：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">CircleStruct myCircle5&#123;<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2.5</span>&#125;;<br>CircleClass myCircle6&#123;<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2.5</span>&#125;;<br></code></pre></td></tr></table></figure>
</blockquote>
<p><strong>统一初始化并不局限于结构和类</strong>，<strong>它可以用于初始化 C++ 中的任何内容</strong>，示例：</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 均将变量初始化为 3</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">3</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;<br><span class="hljs-type">int</span> c = &#123;<span class="hljs-number">3</span>&#125;;<br><span class="hljs-type">int</span> d&#123;<span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<h5 id="2-默认统一初始化："><a href="#2-默认统一初始化：" class="headerlink" title="2.默认统一初始化："></a>2.<strong>默认统一初始化</strong>：</h5><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 示例</span><br><br><span class="hljs-comment">// 对于基本整型</span><br><span class="hljs-type">char</span>、<span class="hljs-type">int</span>	-&gt;		<span class="hljs-number">0</span><br>ptr			-&gt;		nullprt<br><br><span class="hljs-comment">// 为此只需要指定一系列空大括号</span><br><span class="hljs-type">int</span> e&#123;&#125;;	<span class="hljs-comment">// Uniform initialization，e will be 0</span><br></code></pre></td></tr></table></figure>
</blockquote>
<h5 id="3-阻止窄化-narrowing"><a href="#3-阻止窄化-narrowing" class="headerlink" title="3.**阻止窄化 (narrowing) **"></a>3.**阻止窄化 <em>(narrowing)</em> **</h5><p>​	<strong>一般情况下，C++ 隐式地执行窄化，但存在部分编译器报错，部分不报错的情况，为解决不统一问题</strong>，示例：</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">/*...*/</span>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> x = <span class="hljs-number">3.14</span>;<br>	<span class="hljs-built_in">func</span>(<span class="hljs-number">3.14</span>);<br><span class="hljs-comment">// 上面两种情况窄化，将 3.14 截取成为 3</span><br><span class="hljs-comment">// 对于窄化，部分编译器报错，部分不报</span><br><span class="hljs-comment">// 但是，使用 统一初始化 则都会生成编译错误</span><br>&#125;<br><br><span class="hljs-comment">// 替换为：</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	<span class="hljs-type">int</span> x = &#123;<span class="hljs-number">3.14</span>&#125;; 	<span class="hljs-comment">// Error because narrowing</span><br>	<span class="hljs-built_in">func</span>(&#123;<span class="hljs-number">3.14</span>&#125;); 		<span class="hljs-comment">// Error because narrowing</span><br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<h5 id="4-其他类型的统一初始化"><a href="#4-其他类型的统一初始化" class="headerlink" title="4.其他类型的统一初始化"></a><strong>4.其他类型的统一初始化</strong></h5><blockquote>
<p><strong>动态分配的数组的统一初始化：</strong></p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span>* pArray = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">4</span>]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure>
</blockquote>
<p><strong>构造函数初始化器的统一初始化：</strong></p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass</span><br>&#123;<br> <span class="hljs-keyword">public</span>:<br>		<span class="hljs-built_in">Myclass</span>()<br>     	: mArray&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br> 	&#123;  <br><br>       &gt;     	&#125;<br><br>    <span class="hljs-keyword">private</span>:<br>    	<span class="hljs-type">int</span> Array[<span class="hljs-number">4</span>];<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<p><strong>此外，统一初始化还可以用于标准库容器，之后讨论；</strong></p>
</blockquote>
<h5 id="5-两种统一初始化的初始化列表"><a href="#5-两种统一初始化的初始化列表" class="headerlink" title="5.两种统一初始化的初始化列表"></a>5.两种统一初始化的初始化列表</h5><blockquote>
<ul>
<li><p><strong>复制列表初始化：	T obj &#x3D; {arg1, arg2, …};</strong></p>
</li>
<li><p><strong>直接初始化：	    T obj {arg1, arg2, …}</strong></p>
<blockquote>
<p>在 C++17 后，与 <strong>auto</strong> 结合有以下结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Copy list initialization</span><br><span class="hljs-keyword">auto</span> a = &#123;<span class="hljs-number">11</span>&#125;; 		<span class="hljs-comment">// initializer_list&lt;int&gt;</span><br><span class="hljs-keyword">auto</span> b = &#123;<span class="hljs-number">11</span>, <span class="hljs-number">22</span>&#125;; 	<span class="hljs-comment">// initial!zer_list&lt;int&gt;</span><br><br><span class="hljs-comment">// Direct list initialization</span><br><span class="hljs-keyword">auto</span> c &#123;<span class="hljs-number">11</span>); 		<span class="hljs-comment">// int</span><br><span class="hljs-keyword">auto</span> d &#123;<span class="hljs-number">11</span>, <span class="hljs-number">22</span>&#125;; 	<span class="hljs-comment">// Error, too many elements.</span><br><br><span class="hljs-comment">// 注意，auto 作为 std::initializer_list&lt;int&gt; 类型，不可以直接 std::cout &lt;&lt; 输出，使用下面方法：</span><br>       &gt; <span class="hljs-comment">// 以 a 为例</span><br><span class="hljs-keyword">auto</span> a = &#123; <span class="hljs-number">11</span> &#125;;<br><br><span class="hljs-comment">// 使用范围遍历输出</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; element : a) <br>&#123;<br>	std::cout &lt;&lt; element &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-comment">// 或者使用迭代器</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> item = a.<span class="hljs-built_in">begin</span>(); item != a.<span class="hljs-built_in">end</span>(); ++item) <br>&#123;<br>	std::cout &lt;&lt; *item &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<blockquote>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">注意：<br><br><span class="hljs-number">1.</span> **对于复制列表初始化，放在大括号中的初始化器的所有元素都必须使用相同的类型**。例如，以下代码无法编译： <br><br>   &gt; ``` c++<br>   &gt; <span class="hljs-built_in">auto</span> b = &#123;<span class="hljs-number">11</span>, <span class="hljs-number">12.33</span>&#125;;	<span class="hljs-comment">// Compilation error</span><br></code></pre></td></tr></table></figure>

<ol start="2">
<li><strong>区分结构化绑定；</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>**在早期版本 (C++<span class="hljs-number">11</span>/<span class="hljs-number">14</span>) 中，复制初始化列表和直接列表初始化会推导出 std::initializer_list&lt;&gt;:**<br><br>```c++<br><span class="hljs-comment">// Copy list initialization</span><br><span class="hljs-keyword">auto</span> a = &#123;<span class="hljs-number">11</span>&#125;; 		<span class="hljs-comment">// initializer_list&lt;int&gt;</span><br><span class="hljs-keyword">auto</span> b = &#123;<span class="hljs-number">11</span>, <span class="hljs-number">22</span>&#125;; 	<span class="hljs-comment">// initializer_list&lt;int&gt;</span><br><br><span class="hljs-comment">// Direct list initialization</span><br><span class="hljs-keyword">auto</span> c &#123;<span class="hljs-number">11</span>&#125;; 		<span class="hljs-comment">// initial!zer_list&lt;int&gt;</span><br><span class="hljs-keyword">auto</span> d &#123;<span class="hljs-number">11</span>, <span class="hljs-number">22</span>&#125;; 	<span class="hljs-comment">// initializer_list&lt;int&gt;</span><br></code></pre></td></tr></table></figure></li>
</ol>
</blockquote>
</blockquote>
<hr>
<h3 id="1-5-标准库"><a href="#1-5-标准库" class="headerlink" title="1.5    标准库"></a><strong>1.5    标准库</strong></h3><blockquote>
<p><strong>C++ 具有标准库，其中包含许多有用的类，在代码中可方便地使用这些类。使用标准库中类的好处是不需要重新创建某些类，也不需要浪费时间去实现系统已经自动实现的内容。另一好处是标准库中的类己经过成千上万用户的严格测试和验证。标准库中类的性能也比较高，因此使用这些类比使用自己的类效率更高。</strong></p>
<p>标准库中可用的功能非常多。第 16~20 章将详细讲述标准库。<strong>当开始使用 C++时，最好立刻了解标准库可以做什么。</strong>如果你是一位 C 程序员，这一点尤其重要。作为 C 程序员，你使用 C++时可能会以 C 的方式解决问题。然而使用 C++ 的标准库类可以更方便、安全地解决问题。</p>
<p>本章前面己经介绍了标准库中的一些类，例如 <strong>std::string、std::array、std::vector、std::unique_ptr</strong> 和<strong>std::shared_ptr</strong> 第 16~20 章将介绍更多的类。</p>
</blockquote>
<hr>
<h3 id="1-6-第一个有用的-C-程序"><a href="#1-6-第一个有用的-C-程序" class="headerlink" title="1.6    第一个有用的 C++ 程序"></a><strong>1.6    第一个有用的 C++ 程序</strong></h3><hr>
<h4 id="6-1雇员记录系统"><a href="#6-1雇员记录系统" class="headerlink" title="6.1	雇员记录系统"></a><strong>6.1	雇员记录系统</strong></h4><blockquote>
<p>管理公司雇员记录的程序应该灵活并具有有效的功能，这个程序包含的功能有：</p>
<ul>
<li>添加雇员</li>
<li>解雇雇员</li>
<li>雇员晋升</li>
<li>查看所有雇员，包括过去和现在的雇员</li>
<li>查看所有当前雇员</li>
<li>查看所有之前雇员</li>
</ul>
<p>程序的代码分为三部分：Employee 类封装了单个雇员的信息，Database 类管理公司的所有雇员，单独的用户界面提供程序的接口；</p>
</blockquote>
<hr>
<h4 id="6-2Employee-类"><a href="#6-2Employee-类" class="headerlink" title="6.2	Employee 类"></a><strong>6.2	Employee 类</strong></h4><blockquote>
<p>Employee 类维护了某个雇员的的全部信息，该类的方法提供了查询以及修改信息的途径。Employee 类还知道如何在控制台显示自身。此外，还存在调整雇员薪水和就业状态的方法。</p>
</blockquote>
<hr>
<h6 id="1-Employee-h"><a href="#1-Employee-h" class="headerlink" title="1.Employee.h"></a>1.Employee.h</h6><blockquote>
<p><strong>注意：使用以下约定：给常量加前缀 k(小写字母)。这源于德语单词 Konstant, 意思是“顾问”  ；</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*第一行包括 #pragma once，以防止文件被包含多次。</span><br><span class="hljs-comment">此外还包括 string 功能。*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-comment">// 不推荐，也不要将这个参量定义于头文件命名空间外，因为当引入到实现文件后，文件之间耦合性可能增加，可能引起错误</span><br><span class="hljs-comment">// const int kDefaultStartingSalary = 30000;</span><br><br><span class="hljs-comment">/*代码还声明后面的代码(包括在大括号中)将位于Records名称空间。</span><br><span class="hljs-comment">为使用特定代码，整个程序都会用到 Rewards 名称空间；*/</span><br><span class="hljs-keyword">namespace</span> Records<br>&#123;<br> <span class="hljs-comment">/*下面的常量代表新雇员的默认起薪，位于 Records 名称空间。</span><br><span class="hljs-comment"> Records 名称空间中的其他代码可以将这个常量作为 kDefhultStartingSalary 访问。</span><br><span class="hljs-comment"> 在其他位置，必须通过 Records::kDefaultStartingSalary 来引用它。*/</span><br> <span class="hljs-comment">// 这里在命名空间内定义这个参量，使得 kDefaultStartingSalary 作用域限定于命名空间域，避免耦合</span><br> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kDefaultStartingSalary = <span class="hljs-number">30000</span>;<br><br> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span><br> &#123;<br>     <span class="hljs-keyword">public</span>:<br>     	<span class="hljs-built_in">Employee</span>() = <span class="hljs-keyword">default</span>;<br>     	<span class="hljs-built_in">Employee</span>(<span class="hljs-type">const</span> std::string&amp; firstName,<br>                  <span class="hljs-type">const</span> std::string&amp; lastNmae);<br>     	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">promote</span><span class="hljs-params">(<span class="hljs-type">int</span> raiseAmount = <span class="hljs-number">1000</span>)</span></span>;<br>     	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demote</span><span class="hljs-params">(<span class="hljs-type">int</span> demeritAmount = <span class="hljs-number">1000</span>)</span></span>;<br>     	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hire</span><span class="hljs-params">()</span></span>;			<span class="hljs-comment">// Hires or rehires the employee</span><br>     	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fire</span><span class="hljs-params">()</span></span>;			<span class="hljs-comment">// Dissmisses the employee</span><br>     	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;	 <span class="hljs-comment">// Output employee info to console</span><br><br>     	<span class="hljs-comment">// Getters and setters</span><br>     	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setFirstName</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; firstName)</span></span>;<br>     	<span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getFirstName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>     	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setLastName</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; lastName)</span></span>;<br>     	<span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getLastName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>     	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setEmployeeNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> employeeNumber)</span></span>;<br>     	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getEmployeeNumber</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>     	<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setSalary</span><span class="hljs-params">(<span class="hljs-type">int</span> newSalary)</span></span>;<br>     	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getSalary</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>     	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isHired</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>     <span class="hljs-comment">/*最后将数据成员声明为 private, 这样其他部分的代码将无法直接修改它们。</span><br><span class="hljs-comment">     获取器和设置器提供了修改或查询这些值的唯一公有途径。</span><br><span class="hljs-comment">     数据成员也在这里(而非构造函数中)进行初始化。*/</span><br>     <span class="hljs-keyword">private</span>:<br>     	std::string mFirstName;<br>     	std::string mLastName;<br>     	<span class="hljs-type">int</span> mEmployeeNumber = <span class="hljs-number">-1</span>;		   <span class="hljs-comment">// 雇员编号而非雇员数量</span><br>     	<span class="hljs-type">int</span> mSalary = kDefaultStartingSalary;	<span class="hljs-comment">// 默认起始薪资</span><br>     	<span class="hljs-type">bool</span> mHired = <span class="hljs-literal">false</span>;			   <span class="hljs-comment">// 受雇状态</span><br> &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<h6 id="2-Employee-cpp"><a href="#2-Employee-cpp" class="headerlink" title="2.Employee.cpp"></a><strong>2.Employee.cpp</strong></h6><p>​								<strong>注意，整型参数的默认值不显示在源文件中；</strong></p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Employee.h&quot;</span></span><br><br><span class="hljs-comment">// using namespace std;</span><br><span class="hljs-comment">// 课本上这样讲了，但是这事实上引入 std 名称空间是一种不好的实践，尤其是在头文件中</span><br><span class="hljs-comment">// 下面给出更好的做法，引入所需要的标识符：</span><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-keyword">namespace</span> Records<br>&#123;<br> <span class="hljs-comment">/*构造函数接收姓名，只设置相应的数据成员；*/</span><br> Employee::<span class="hljs-built_in">Employee</span>(<span class="hljs-type">const</span> std::string&amp; firstName,<br>                    <span class="hljs-type">const</span> std::string&amp; lastName)<br>     			: <span class="hljs-built_in">mFirstName</span>(firstName), <span class="hljs-built_in">mLastName</span>(lastName)<br> &#123;<br><br> &#125;<br><br> <span class="hljs-comment">/*promote() 和 demote() 方法只是用一些新值调用 setSalary() 方法。</span><br><span class="hljs-comment">   注意，整型参数的默认值不显示在源文件中；</span><br><span class="hljs-comment">	 它们只能出现在函数声明中，不能出现在函数定义中。*/</span><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Employee::promote</span><span class="hljs-params">(<span class="hljs-type">int</span> raiseAmount)</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-built_in">setSalary</span>(<span class="hljs-built_in">getSalary</span>() + raiseAmount);<br> &#125;<br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Employee::demote</span><span class="hljs-params">(<span class="hljs-type">int</span> demoteAmount)</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-built_in">setSalary</span>(<span class="hljs-built_in">getSalary</span>() - demoteAmount);<br> &#125;<br><br> <span class="hljs-comment">/*hire() 和 fire() 方法正确设置了 mHired 数据成员*/</span><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Employee::hire</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123;<br>     mHired = <span class="hljs-literal">true</span>;<br> &#125;<br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Employee::fire</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123;<br>     mHired = <span class="hljs-literal">false</span>;<br> &#125;<br><br> <span class="hljs-comment">/*display()方法使用控制台输出流显示当前雇员的信息。</span><br><span class="hljs-comment"> 由于这段代码是 Employee 类的一部分，因此可直谈访问数据成员(如 mSalary), 而不需要使用 getSalaryo获取器。</span><br><span class="hljs-comment"> 然而，使用获取器和设置器(当存在时)是一种好的风格，甚至在类的内部也是如此。*/</span><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Employee::display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"> </span>&#123;<br>     cout &lt;&lt; <span class="hljs-string">&quot;Employee: &quot;</span> &lt;&lt; <span class="hljs-built_in">getLastName</span>() &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; <span class="hljs-built_in">getFirstName</span>() &lt;&lt; endl;<br>     cout &lt;&lt; <span class="hljs-string">&quot;-------------------------&quot;</span> &lt;&lt; endl;<br>     cout &lt;&lt; (<span class="hljs-built_in">isHired</span>() ? <span class="hljs-string">&quot;Current Employee&quot;</span> : <span class="hljs-string">&quot;Former Employee&quot;</span>) &lt;&lt; endl;<br>     cout &lt;&lt; <span class="hljs-string">&quot;Employee Number : &quot;</span> &lt;&lt; <span class="hljs-built_in">getEmployeeNumber</span>() &lt;&lt; endl;<br>     cout &lt;&lt; <span class="hljs-string">&quot;Salary: $&quot;</span> &lt;&lt; <span class="hljs-built_in">getSalary</span>() &lt;&lt; endl;<br>     cout &lt;&lt; std::endl;<br> &#125;<br><br> <span class="hljs-comment">/*许多获取器和设置器执行获取值以及设置值的任务。</span><br><span class="hljs-comment"> 即使这些方法看起来微不足道，但是使用这些微不足道的获取器和设置器，仍然优于将数据成员设置为 public。</span><br><span class="hljs-comment"> 可能想在 setSalary() 方法中执行边界检查，它们也能简化调试，因为可在其中设置断点，在检索或设置值时检查它们。</span><br><span class="hljs-comment"> 另一个原因是决定修改类中存储数据的方式时，只需要修改这些获取器和设置器。*/</span><br> <span class="hljs-comment">// Getters and setters</span><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Employee::setFirstName</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; firstName)</span></span><br><span class="hljs-function"> </span>&#123;<br>     mFirstName = firstName;<br> &#125;<br> <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getFirstName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">return</span> mFirstName;<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Employee::setLastName</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; lastName)</span></span><br><span class="hljs-function"> </span>&#123;<br>     mLastName = lastName;<br> &#125;<br> <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getLastName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">return</span> mLastName;<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Employee::setEmployeeNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> employeeNumber)</span></span><br><span class="hljs-function"> </span>&#123;<br>     mEmployeeNumber = employeeNumber;<br> &#125;<br> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Employee::getEmployeeNumber</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">return</span> mEmployeeNumber;<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Employee::setSalary</span><span class="hljs-params">(<span class="hljs-type">int</span> newSalary)</span></span><br><span class="hljs-function"> </span>&#123;<br>     mSalary = newSalary;<br> &#125;<br> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Employee::getSalary</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">return</span> mSalary;<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Employee::isHired</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">return</span> mHired;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<hr>
<h6 id="3-EmployeeTest-cpp"><a href="#3-EmployeeTest-cpp" class="headerlink" title="3.EmployeeTest.cpp"></a><strong>3.EmployeeTest.cpp</strong></h6><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Employee.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> Records;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	cout &lt;&lt; <span class="hljs-string">&quot;Testing the Employee class.&quot;</span> &lt;&lt; endl;<br>	Employee emp;<br>	emp.<span class="hljs-built_in">setFirstName</span>(<span class="hljs-string">&quot;John&quot;</span>);<br>	emp.<span class="hljs-built_in">setLastName</span>(<span class="hljs-string">&quot;Doe&quot;</span>);<br>	emp.<span class="hljs-built_in">setEmployeeNumber</span>(<span class="hljs-number">71</span>);<br>	emp.<span class="hljs-built_in">setSalary</span>(<span class="hljs-number">50000</span>);<br>	emp.<span class="hljs-built_in">promote</span>();<br>	emp.<span class="hljs-built_in">promote</span>(<span class="hljs-number">50</span>);<br>	emp.<span class="hljs-built_in">hire</span>();<br>	emp.<span class="hljs-built_in">display</span>();<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上为书中给出的测试文件书写方法，但下面给出我认为更好的方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Employee.h&quot;</span></span><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> Records; 					<span class="hljs-comment">// 这里选择性地引入 Records 命名空间</span><br>	<span class="hljs-comment">// 因为是对这个文件的测试所以引入了，但一般大型工程中不使用</span><br> cout &lt;&lt; <span class="hljs-string">&quot;Testing the Employee class.&quot;</span> &lt;&lt; endl;<br><br> Employee emp;<br> emp.<span class="hljs-built_in">setFirstName</span>(<span class="hljs-string">&quot;John&quot;</span>);<br> emp.<span class="hljs-built_in">setLastName</span>(<span class="hljs-string">&quot;Doe&quot;</span>);<br> emp.<span class="hljs-built_in">setEmployeeNumber</span>(<span class="hljs-number">71</span>);<br> emp.<span class="hljs-built_in">setSalary</span>(<span class="hljs-number">50000</span>);<br> emp.<span class="hljs-built_in">promote</span>();<br> emp.<span class="hljs-built_in">promote</span>(<span class="hljs-number">50</span>);<br> emp.<span class="hljs-built_in">hire</span>();<br> emp.<span class="hljs-built_in">display</span>();<br><br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 乃至使用以下的方式：</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Employee.h&quot;</span></span><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> Records;<br> cout &lt;&lt; <span class="hljs-string">&quot;Testing the Employee class.&quot;</span> &lt;&lt; endl;<br><br> <span class="hljs-keyword">auto</span> emp = std::<span class="hljs-built_in">make_unique</span>&lt;Employee&gt;();<br> emp-&gt;<span class="hljs-built_in">setFirstName</span>(<span class="hljs-string">&quot;John&quot;</span>);<br> emp-&gt;<span class="hljs-built_in">setLastName</span>(<span class="hljs-string">&quot;Doe&quot;</span>);<br> emp-&gt;<span class="hljs-built_in">setEmployeeNumber</span>(<span class="hljs-number">71</span>);<br> emp-&gt;<span class="hljs-built_in">setSalary</span>(<span class="hljs-number">50000</span>);<br> emp-&gt;<span class="hljs-built_in">promote</span>();<br> emp-&gt;<span class="hljs-built_in">promote</span>(<span class="hljs-number">50</span>);<br> emp-&gt;<span class="hljs-built_in">hire</span>();<br> emp-&gt;<span class="hljs-built_in">display</span>();<br><br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>当确信 Employee 类可正常运行后，应删除这个文件，或将这个文件注释掉，这样就不会编译具有多个 main() 函数的代码;</li>
<li>一种测试各个类的方法是使用单元测试，详见第 26 章中的讨论;</li>
</ul>
</blockquote>
<hr>
<h4 id="6-3Database-类"><a href="#6-3Database-类" class="headerlink" title="6.3	Database 类"></a><strong>6.3	Database 类</strong></h4><blockquote>
<p>Database 类使用标准库中的 std::vector 类来存储 Employee 对象</p>
</blockquote>
<hr>
<h5 id="1-Database-h"><a href="#1-Database-h" class="headerlink" title="1.Database.h"></a><strong>1.Database.h</strong></h5><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*由于数据库会自动给新雇员指定一个雇员号，因此定义一个常量作为编号的开始*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Employee.h&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> Records<br>&#123;<br> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kFirstEmployeeNumber = <span class="hljs-number">1000</span>;<br> <span class="hljs-comment">/*数据库可根据提供的姓名方便地添加一个新雇员。为方便起见，这个方法返回一个新雇员的引用。</span><br><span class="hljs-comment"> 外部代码也可通过调用 getEmployee() 方法来获得雇员的引用。</span><br><span class="hljs-comment"> 为这个方法声明了两个版本，一个允许按雇员号进行检索，另一个要求提供雇员的姓名。*/</span><br> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Database</span><br> &#123;<br> <span class="hljs-keyword">public</span>:<br>     <span class="hljs-function">std::shared_ptr&lt;Employee&gt;&amp; <span class="hljs-title">addEmployee</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; firstName,</span></span><br><span class="hljs-params"><span class="hljs-function">                                            <span class="hljs-type">const</span> std::string&amp; lastName)</span></span>;<br>     <span class="hljs-function">std::shared_ptr&lt;Employee&gt;&amp; <span class="hljs-title">getEmployee</span><span class="hljs-params">(<span class="hljs-type">int</span> employeeNumber)</span></span>;<br>     <span class="hljs-function">std::shared_ptr&lt;Employee&gt;&amp; <span class="hljs-title">getEmployee</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; firstName,</span></span><br><span class="hljs-params"><span class="hljs-function">                                            <span class="hljs-type">const</span> std::string&amp; lastName)</span></span>;<br>		<span class="hljs-comment">/*由于数据库是所有雇员记录的中心存储库，因此具有输出所有雇员、当前在职雇员以及己离职雇员的方法。*/</span><br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">displayAll</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">displayCurrent</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">displayFormer</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>     <span class="hljs-comment">/*mEmployees 包含 Employee 对象。</span><br><span class="hljs-comment">     数据成员 mNextEmployeeNumber 跟踪新雇员的雇员号，使用 kFirstEmployeeNumber 常量进行初始化*/</span><br> <span class="hljs-keyword">private</span>:<br>     <span class="hljs-comment">// std::vector&lt;std::make_unique&lt;Employee&gt;()&gt; mEmployee;</span><br>     <span class="hljs-comment">// 上是最一开始写错的版本，下面给出正确版本</span><br>     std::vector&lt;std::shared_ptr&lt;Employee&gt;&gt; mEmployees;<br>     <span class="hljs-type">int</span> mNextEmployeeNumber = kFirstEmployeeNumber;<br> &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<hr>
<h5 id="2-Database-cpp"><a href="#2-Database-cpp" class="headerlink" title="2.Database.cpp"></a><strong>2.Database.cpp</strong></h5><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*addEmployeeo方法创建一个新的 Employee 对象，在其中填充信息并将其添加到 vector 中。</span><br><span class="hljs-comment">注意当使用了这个方法后，数据成员 mNextEmployeeNumber 的值会递增，因此下一个雇员将获得新编号*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Database.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-keyword">namespace</span> Records<br>&#123;<br> <span class="hljs-function">std::shared_ptr&lt;Employee&gt;&amp; <span class="hljs-title">Database::addEmployee</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; firstName,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                  <span class="hljs-type">const</span> std::string&amp; lastName)</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">auto</span> theEmployee = std::<span class="hljs-built_in">make_shared</span>&lt;Employee&gt;(firstName, lastName);<br>     theEmployee-&gt;<span class="hljs-built_in">setEmployeeNumber</span>(mNextEmployeeNumber++);<br>     theEmployee-&gt;<span class="hljs-built_in">hire</span>();<br>     mEmployees.<span class="hljs-built_in">push_back</span>(theEmployee);<br><br>     <span class="hljs-keyword">return</span> mEmployees[mEmployees.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br> &#125;<br><br> <span class="hljs-function">std::shared_ptr&lt;Employee&gt;&amp; <span class="hljs-title">Database::getEmployee</span><span class="hljs-params">(<span class="hljs-type">int</span> employeeNumber)</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; employee : mEmployees)<br>     &#123;<br>         <span class="hljs-keyword">if</span> (employee-&gt;<span class="hljs-built_in">getEmployeeNumber</span>() == employeeNumber)<br>         &#123;<br>             <span class="hljs-keyword">return</span> employee;<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">logic_error</span>(<span class="hljs-string">&quot;No employee found.&quot;</span>);<br> &#125;<br><br> <span class="hljs-function">std::shared_ptr&lt;Employee&gt;&amp; <span class="hljs-title">Database::getEmployee</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; firstName,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                  <span class="hljs-type">const</span> std::string&amp; lastName)</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; employee : mEmployees)<br>     &#123;<br>         <span class="hljs-keyword">if</span> (employee-&gt;<span class="hljs-built_in">getFirstName</span>() == firstName &amp;&amp; employee-&gt;<span class="hljs-built_in">getLastName</span>() == lastName)<br>         &#123;<br>             <span class="hljs-keyword">return</span> employee;<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">logic_error</span>(<span class="hljs-string">&quot;No employee found.&quot;</span>);<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Database::displayAll</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; employee : mEmployees)<br>     &#123;<br>         employee-&gt;<span class="hljs-built_in">display</span>();<br>     &#125;<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Database::displayCurrent</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; employee : mEmployees)<br>     &#123;<br>         <span class="hljs-keyword">if</span> (employee-&gt;<span class="hljs-built_in">isHired</span>() == <span class="hljs-literal">true</span>)<br>         &#123;<br>             employee-&gt;<span class="hljs-built_in">display</span>();<br>         &#125;<br>     &#125;<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Database::displayFormer</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; employee : mEmployees)<br>     &#123;<br>         <span class="hljs-keyword">if</span> (employee-&gt;<span class="hljs-built_in">isHired</span>() == <span class="hljs-literal">false</span>)<br>         &#123;<br>             employee-&gt;<span class="hljs-built_in">display</span>();<br>         &#125;<br>     &#125;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<h5 id="3-DatabaseTest-cpp"><a href="#3-DatabaseTest-cpp" class="headerlink" title="3.DatabaseTest.cpp"></a><strong>3.DatabaseTest.cpp</strong></h5><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*用于数据库基本功能的简单测试*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Database.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Records::Database myDB;<br>	<span class="hljs-keyword">auto</span>&amp; emp1 = myDB.<span class="hljs-built_in">addEmployee</span>(<span class="hljs-string">&quot;Greg&quot;</span>, <span class="hljs-string">&quot;Wallis&quot;</span>);<br>	emp1-&gt;<span class="hljs-built_in">fire</span>();<br>	<span class="hljs-keyword">auto</span> &amp; emp2 = myDB.<span class="hljs-built_in">addEmployee</span>(<span class="hljs-string">&quot;Marc&quot;</span>, <span class="hljs-string">&quot;White&quot;</span>);<br>	emp2-&gt;<span class="hljs-built_in">setSalary</span>(<span class="hljs-number">100000</span>);<br>	<span class="hljs-keyword">auto</span> &amp; emp3 = myDB.<span class="hljs-built_in">addEmployee</span>(<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;Doe&quot;</span>);<br>	emp3-&gt;<span class="hljs-built_in">setSalary</span>(<span class="hljs-number">10000</span>);<br>	emp3-&gt;<span class="hljs-built_in">promote</span>();<br>	cout &lt;&lt; <span class="hljs-string">&quot;all employees: &quot;</span> &lt;&lt; endl &lt;&lt; endl;<br>	myDB.<span class="hljs-built_in">displayAll</span>();<br>	cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;current employees: &quot;</span> &lt;&lt; endl &lt;&lt; endl;<br>	myDB.<span class="hljs-built_in">displayCurrent</span>();<br>	cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;former employees: &quot;</span> &lt;&lt; endl &lt;&lt; endl;<br>	myDB.<span class="hljs-built_in">displayFormer</span>();<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<hr>
<h5 id="4-std-unique-ptr版本"><a href="#4-std-unique-ptr版本" class="headerlink" title="4.std::unique_ptr版本"></a><strong>4.std::unique_ptr</strong>版本</h5><blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Database.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Employee.h&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> Records<br>&#123;<br> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kFirstEmployeeNumber = <span class="hljs-number">1000</span>;<br> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Database</span><br> &#123;<br> <span class="hljs-keyword">public</span>:<br>     <span class="hljs-function">std::unique_ptr&lt;Employee&gt;&amp; <span class="hljs-title">addEmployee</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; firstName,</span></span><br><span class="hljs-params"><span class="hljs-function">                                           <span class="hljs-type">const</span> std::string&amp; lastName)</span></span>;<br>     <span class="hljs-function">std::unique_ptr&lt;Employee&gt; <span class="hljs-title">getEmployee</span><span class="hljs-params">(<span class="hljs-type">int</span> employeeNumber)</span></span>;<br>     <span class="hljs-function">std::unique_ptr&lt;Employee&gt; <span class="hljs-title">getEmployee</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; firstName,</span></span><br><span class="hljs-params"><span class="hljs-function">                                           <span class="hljs-type">const</span> std::string&amp; lastName)</span></span>;<br><br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">displayAll</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">displayCurrent</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">displayFormer</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>     std::vector&lt;std::unique_ptr&lt;Employee&gt;&gt; mEmployees;<br>     <span class="hljs-type">int</span> mNextEmployeeNumber = kFirstEmployeeNumber;<br> &#125;;<br>&#125;<br><br><span class="hljs-comment">/*-----------------------------------------------------------------------------------*/</span><br><span class="hljs-comment">// Database.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Database.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-keyword">namespace</span> Records<br>&#123;<br> <span class="hljs-function">std::unique_ptr&lt;Employee&gt;&amp; <span class="hljs-title">Database::addEmployee</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; firstName,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                 <span class="hljs-type">const</span> std::string&amp; lastName)</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">auto</span> theEmployee = std::<span class="hljs-built_in">make_unique</span>&lt;Employee&gt;(firstName, lastName);<br>     theEmployee-&gt;<span class="hljs-built_in">setEmployeeNumber</span>(mNextEmployeeNumber++);<br>     theEmployee-&gt;<span class="hljs-built_in">hire</span>();<br>     mEmployees.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(theEmployee));<br><br>     <span class="hljs-keyword">return</span> mEmployees[mEmployees.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br> &#125;<br><br> <span class="hljs-function">std::unique_ptr&lt;Employee&gt; <span class="hljs-title">Database::getEmployee</span><span class="hljs-params">(<span class="hljs-type">int</span> employeeNumber)</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; employee : mEmployees)<br>     &#123;<br>         <span class="hljs-keyword">if</span> (employee-&gt;<span class="hljs-built_in">getEmployeeNumber</span>() == employeeNumber)<br>         &#123;<br>             <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">move</span>(employee);<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">logic_error</span>(<span class="hljs-string">&quot;No employee found.&quot;</span>);<br> &#125;<br><br> <span class="hljs-function">std::unique_ptr&lt;Employee&gt; <span class="hljs-title">Database::getEmployee</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; firstName,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                 <span class="hljs-type">const</span> std::string&amp; lastName)</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; employee : mEmployees)<br>     &#123;<br>         <span class="hljs-keyword">if</span> (employee-&gt;<span class="hljs-built_in">getFirstName</span>() == firstName &amp;&amp; employee-&gt;<span class="hljs-built_in">getLastName</span>() == lastName)<br>         &#123;<br>             <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">move</span>(employee);<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">logic_error</span>(<span class="hljs-string">&quot;No employee found.&quot;</span>);<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Database::displayAll</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; employee : mEmployees)<br>     &#123;<br>         employee-&gt;<span class="hljs-built_in">display</span>();<br>     &#125;<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Database::displayCurrent</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; employee : mEmployees)<br>     &#123;<br>         <span class="hljs-keyword">if</span> (employee-&gt;<span class="hljs-built_in">isHired</span>() == <span class="hljs-literal">true</span>)<br>         &#123;<br>             employee-&gt;<span class="hljs-built_in">display</span>();<br>         &#125;<br>     &#125;<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Database::displayFormer</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; employee : mEmployees)<br>     &#123;<br>         <span class="hljs-keyword">if</span> (employee-&gt;<span class="hljs-built_in">isHired</span>() == <span class="hljs-literal">false</span>)<br>         &#123;<br>             employee-&gt;<span class="hljs-built_in">display</span>();<br>         &#125;<br>     &#125;<br> &#125;<br>&#125;<br><br><span class="hljs-comment">/*-----------------------------------------------------------------------------------*/</span><br><span class="hljs-comment">// DatabaseTest.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Database.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Records::Database myDB;<br>	<span class="hljs-keyword">auto</span>&amp; emp1 = myDB.<span class="hljs-built_in">addEmployee</span>(<span class="hljs-string">&quot;Greg&quot;</span>, <span class="hljs-string">&quot;Wallis&quot;</span>);<br>	emp1-&gt;<span class="hljs-built_in">fire</span>();<br>	<span class="hljs-keyword">auto</span> &amp; emp2 = myDB.<span class="hljs-built_in">addEmployee</span>(<span class="hljs-string">&quot;Marc&quot;</span>, <span class="hljs-string">&quot;White&quot;</span>);<br>	emp2-&gt;<span class="hljs-built_in">setSalary</span>(<span class="hljs-number">100000</span>);<br>	<span class="hljs-keyword">auto</span> &amp; emp3 = myDB.<span class="hljs-built_in">addEmployee</span>(<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;Doe&quot;</span>);<br>	emp3-&gt;<span class="hljs-built_in">setSalary</span>(<span class="hljs-number">10000</span>);<br>	emp3-&gt;<span class="hljs-built_in">promote</span>();<br>	cout &lt;&lt; <span class="hljs-string">&quot;all employees: &quot;</span> &lt;&lt; endl &lt;&lt; endl;<br>	myDB.<span class="hljs-built_in">displayAll</span>();<br>	cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;current employees: &quot;</span> &lt;&lt; endl &lt;&lt; endl;<br>	myDB.<span class="hljs-built_in">displayCurrent</span>();<br>	cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;former employees: &quot;</span> &lt;&lt; endl &lt;&lt; endl;<br>	myDB.<span class="hljs-built_in">displayFormer</span>();<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<hr>
<h4 id="6-4用户界面-UI"><a href="#6-4用户界面-UI" class="headerlink" title="6.4	用户界面(UI)**"></a><em><em>6.4	用户界面</em>(UI)</em>**</h4><blockquote>
<p><strong>程序的最后一部分是基于菜单的用户界面，可让用户方便地使用雇员数据库。main()函数是一个显示菜单的循环，执行被选中的操作，然后重新开始循环。对于大多数的操作都定义了独立的函数。对于显示雇员之类的简单操作，则将实际代码放在对应的情况(case)中。</strong></p>
</blockquote>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Display.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;exception&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;limits&gt;</span>           <span class="hljs-comment">// 用于清除输入缓冲区</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Database.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><span class="hljs-keyword">using</span> std::string;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">displayMenu</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doHire</span><span class="hljs-params">(Records::Database&amp; db)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doFire</span><span class="hljs-params">(Records::Database&amp; db)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doPromote</span><span class="hljs-params">(Records::Database&amp; db)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doDemote</span><span class="hljs-params">(Records::Database&amp; db)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> Records::Database employeeDB;<br> <span class="hljs-type">bool</span> done = <span class="hljs-literal">false</span>;<br> <span class="hljs-keyword">while</span> (!done)<br> &#123;<br>     <span class="hljs-type">int</span> selection = <span class="hljs-built_in">displayMenu</span>();<br>     <span class="hljs-keyword">switch</span> (selection)<br>     &#123;<br>     <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>         done = <span class="hljs-literal">true</span>;<br>         <span class="hljs-keyword">break</span>;<br>     <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>         <span class="hljs-built_in">doHire</span>(employeeDB);<br>         <span class="hljs-keyword">break</span>;<br>     <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>         <span class="hljs-built_in">doFire</span>(employeeDB);<br>         <span class="hljs-keyword">break</span>;<br>     <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>         <span class="hljs-built_in">doPromote</span>(employeeDB);<br>         <span class="hljs-keyword">break</span>;<br>     <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>         employeeDB.<span class="hljs-built_in">displayAll</span>();<br>         <span class="hljs-keyword">break</span>;<br>     <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>         employeeDB.<span class="hljs-built_in">displayCurrent</span>();<br>         <span class="hljs-keyword">break</span>;<br>     <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>         employeeDB.<span class="hljs-built_in">displayFormer</span>();<br>         <span class="hljs-keyword">break</span>;<br>     <span class="hljs-keyword">default</span>:<br>         std::cerr &lt;&lt; <span class="hljs-string">&quot;Unknown command.&quot;</span> &lt;&lt; endl;<br>         <span class="hljs-keyword">break</span>;<br>     &#125;<br> &#125;<br><br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* displayMenu() 函数输出菜单获取用户输入。</span><br><span class="hljs-comment">在此假定用户能够“正确地输入”，当需要一个数字时就输入一个数字，这一点很重要。</span><br><span class="hljs-comment">在阅读了第 13 章有关 I / O 的内容后，你就会知道如何防止输入错误信息*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">displayMenu</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-type">int</span> selection;<br> cout &lt;&lt; endl;<br> cout &lt;&lt; <span class="hljs-string">&quot;Employee Database&quot;</span> &lt;&lt; endl;<br> cout &lt;&lt; <span class="hljs-string">&quot;-----------------&quot;</span> &lt;&lt; endl;<br> cout &lt;&lt; <span class="hljs-string">&quot;1) Hire a new employee&quot;</span> &lt;&lt; endl;<br> cout &lt;&lt; <span class="hljs-string">&quot;2) Fire an employee&quot;</span> &lt;&lt; endl;<br> cout &lt;&lt; <span class="hljs-string">&quot;3) Promote an employee&quot;</span> &lt;&lt; endl;<br> cout &lt;&lt; <span class="hljs-string">&quot;4) List all employees&quot;</span> &lt;&lt; endl;<br> cout &lt;&lt; <span class="hljs-string">&quot;5) List all current employee&quot;</span> &lt;&lt; endl;<br> cout &lt;&lt; <span class="hljs-string">&quot;6) List all former employee&quot;</span> &lt;&lt; endl;<br> cout &lt;&lt; <span class="hljs-string">&quot;0) Quit&quot;</span> &lt;&lt; endl;<br> cout &lt;&lt; <span class="hljs-string">&quot;---&gt;   &quot;</span>;<br><br> <span class="hljs-comment">// 循环，直到得到有效的输入</span><br> <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br> &#123;<br>     <span class="hljs-comment">// 尝试读取用户输入</span><br>     <span class="hljs-keyword">try</span><br>     &#123;<br>         std::cin &gt;&gt; selection;<br><br>         <span class="hljs-comment">// 检查输入流的状态</span><br>         <span class="hljs-keyword">if</span> (std::cin.<span class="hljs-built_in">fail</span>())<br>         &#123;<br>             <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Invalid input. Please enter a number.&quot;</span>);<br>         &#125;<br><br>         <span class="hljs-comment">// 如果程序能够执行到这里，说明输入是有效的</span><br>         <span class="hljs-keyword">break</span>;<br>     &#125;<br>     <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::invalid_argument&amp; exception)<br>     &#123;<br>         std::cerr &lt;&lt; <span class="hljs-string">&quot;Error: &quot;</span> &lt;&lt; exception.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br><br>         <span class="hljs-comment">// 清除错误状态</span><br>         std::cin.<span class="hljs-built_in">clear</span>();<br><br>         <span class="hljs-comment">// 忽略缓冲区中的无效字符，直到遇到换行符</span><br>         std::cin.<span class="hljs-built_in">ignore</span>(std::numeric_limits&lt;std::streamsize&gt;::<span class="hljs-built_in">max</span>(), <span class="hljs-string">&#x27;\n&#x27;</span>);<br>     &#125;<br> &#125;<br><br> <span class="hljs-keyword">return</span> selection;<br>&#125;<br><br><span class="hljs-comment">/* doHire() 函数获取用户输入的新雇员的姓名，并通知数据库添加这个雇员*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doHire</span><span class="hljs-params">(Records::Database&amp; db)</span></span><br><span class="hljs-function"></span>&#123;<br> string firstName;<br> string lastName;<br><br> cout &lt;&lt; <span class="hljs-string">&quot;First name? input: &quot;</span>;<br> std::cin &gt;&gt; firstName;<br><br> cout &lt;&lt; <span class="hljs-string">&quot;Last name? input: &quot;</span>;<br> std::cin &gt;&gt; lastName;<br><br> db.<span class="hljs-built_in">addEmployee</span>(firstName, lastName);<br>&#125;<br><br><span class="hljs-comment">/* doFire() 、doPromote() 以及 doDemote() 函数都要求数据库根据雇员号找到雇员，然后使用 Employee 对象的 public 方法进行修改*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doFire</span><span class="hljs-params">(Records::Database&amp; db)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-type">int</span> employeeNumber;<br><br> cout &lt;&lt; <span class="hljs-string">&quot;Employee number? input: &quot;</span>;<br> std::cin &gt;&gt; employeeNumber;<br><br> <span class="hljs-comment">// 将 try 遇到的问题抛出，并继续执行程序</span><br> <span class="hljs-keyword">try</span><br> &#123;<br>     std::unique_ptr&lt;Records::Employee&gt; emp = db.<span class="hljs-built_in">getEmployee</span>(employeeNumber);<br>     emp-&gt;<span class="hljs-built_in">fire</span>();<br>     cout &lt;&lt; <span class="hljs-string">&quot;Employee &quot;</span> &lt;&lt; employeeNumber &lt;&lt; <span class="hljs-string">&quot; terminated.&quot;</span> &lt;&lt; endl;<br> &#125;<br> <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::logic_error&amp; exception)<br> &#123;<br>     std::cerr &lt;&lt; <span class="hljs-string">&quot;Unable to terminate employee: &quot;</span> &lt;&lt; exception.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br> &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doPromote</span><span class="hljs-params">(Records::Database&amp; db)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-type">int</span> employeeNumber;<br> <span class="hljs-type">int</span> raiseAmount;<br><br> cout &lt;&lt; <span class="hljs-string">&quot;Employee number? input: &quot;</span>;<br> std::cin &gt;&gt; employeeNumber;<br><br> cout &lt;&lt; <span class="hljs-string">&quot;How much of a raise? input: &quot;</span>;<br> std::cin &gt;&gt; raiseAmount;<br><br> <span class="hljs-keyword">try</span><br> &#123;<br>     std::unique_ptr&lt;Records::Employee&gt; emp = db.<span class="hljs-built_in">getEmployee</span>(employeeNumber);<br>     emp-&gt;<span class="hljs-built_in">promote</span>(raiseAmount);<br> &#125;<br> <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::logic_error&amp; exception)<br> &#123;<br>     std::cerr &lt;&lt; <span class="hljs-string">&quot;Unable to promote employee: &quot;</span> &lt;&lt; exception.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br> &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doDemote</span><span class="hljs-params">(Records::Database&amp; db)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-type">int</span> employeeNumber;<br> <span class="hljs-type">int</span> demeritAmount;<br><br> cout &lt;&lt; <span class="hljs-string">&quot;Employee number? input: &quot;</span>;<br> std::cin &gt;&gt; employeeNumber;<br><br> cout &lt;&lt; <span class="hljs-string">&quot;How much of a demerit? input: &quot;</span>;<br> std::cin &gt;&gt; demeritAmount;<br><br> <span class="hljs-keyword">try</span><br> &#123;<br>     std::unique_ptr&lt;Records::Employee&gt; emp = db.<span class="hljs-built_in">getEmployee</span>(employeeNumber);<br>     emp-&gt;<span class="hljs-built_in">demote</span>(demeritAmount);<br> &#125;<br> <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::logic_error&amp; exception)<br> &#123;<br>     std::cerr &lt;&lt; <span class="hljs-string">&quot;Unable to promote employee: &quot;</span> &lt;&lt; exception.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<hr>
<h4 id="6-5评估程序"><a href="#6-5评估程序" class="headerlink" title="6.5	评估程序"></a><strong>6.5	评估程序</strong></h4><blockquote>
<p>前面的程序涵盖了许多主题，从最简单的到较复杂的都有。可采用多种方法扩展这个程序。例如，用户界面(UI)没有公开 Database 或 Employee 类的全前功能。可修改 UL 以包含这些特性。还可修改 Database 类，以从 mEmployees 中删除被解雇的雇员。</p>
<p>如果不理解程序的某些部分，参考前面的内容以回顾这些主题。如果仍不甚明了，最好的学习方法是编写代码并查看结果。例如，如果不确定如何使用条件运算符，可编写一个简单的 main()函数进行测试。  </p>
</blockquote>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Employee.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> Records<br>&#123;<br> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kDefaultStartingSalary = <span class="hljs-number">30000</span>;<br><br> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span><br> &#123;<br> <span class="hljs-keyword">public</span>:<br>     <span class="hljs-built_in">Employee</span>() = <span class="hljs-keyword">default</span>;<br>     <span class="hljs-built_in">Employee</span>(<span class="hljs-type">const</span> std::string&amp; firstName,<br>         <span class="hljs-type">const</span> std::string&amp; lastNmae);<br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">promote</span><span class="hljs-params">(<span class="hljs-type">int</span> raiseAmount = <span class="hljs-number">1000</span>)</span></span>;<br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demote</span><span class="hljs-params">(<span class="hljs-type">int</span> demeritAmount = <span class="hljs-number">1000</span>)</span></span>;<br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hire</span><span class="hljs-params">()</span></span>;			<span class="hljs-comment">// Hires or rehires the employee</span><br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fire</span><span class="hljs-params">()</span></span>;			<span class="hljs-comment">// Dissmisses the employee</span><br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;	 <span class="hljs-comment">// Output employee info to console</span><br><br>     <span class="hljs-comment">// Getters and setters</span><br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setFirstName</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; firstName)</span></span>;<br>     <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getFirstName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setLastName</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; lastName)</span></span>;<br>     <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getLastName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setEmployeeNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> employeeNumber)</span></span>;<br>     <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getEmployeeNumber</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setSalary</span><span class="hljs-params">(<span class="hljs-type">int</span> newSalary)</span></span>;<br>     <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getSalary</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>     <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isHired</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>     std::string mFirstName;<br>     std::string mLastName;<br>     <span class="hljs-type">int</span> mEmployeeNumber = <span class="hljs-number">-1</span>;		   <span class="hljs-comment">// 雇员编号而非雇员数量</span><br>     <span class="hljs-type">int</span> mSalary = kDefaultStartingSalary;	<span class="hljs-comment">// 默认起始薪资</span><br>     <span class="hljs-type">bool</span> mHired = <span class="hljs-literal">false</span>;			   <span class="hljs-comment">// 受雇状态</span><br> &#125;;<br>&#125;<br><br><span class="hljs-comment">/*--------------------------------------------分隔符---------------------------------------------------*/</span><br><br><span class="hljs-comment">// Employee.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Employee.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-keyword">namespace</span> Records<br>&#123;<br> Employee::<span class="hljs-built_in">Employee</span>(<span class="hljs-type">const</span> std::string&amp; firstName,<br>     <span class="hljs-type">const</span> std::string&amp; lastName)<br>     : <span class="hljs-built_in">mFirstName</span>(firstName), <span class="hljs-built_in">mLastName</span>(lastName)<br> &#123;<br><br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Employee::promote</span><span class="hljs-params">(<span class="hljs-type">int</span> raiseAmount)</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-built_in">setSalary</span>(<span class="hljs-built_in">getSalary</span>() + raiseAmount);<br> &#125;<br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Employee::demote</span><span class="hljs-params">(<span class="hljs-type">int</span> demeritAmount)</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-built_in">setSalary</span>(<span class="hljs-built_in">getSalary</span>() - demeritAmount);<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Employee::hire</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123;<br>     mHired = <span class="hljs-literal">true</span>;<br> &#125;<br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Employee::fire</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123;<br>     mHired = <span class="hljs-literal">false</span>;<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Employee::display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"> </span>&#123;<br>     cout &lt;&lt; <span class="hljs-string">&quot;Employee: &quot;</span> &lt;&lt; <span class="hljs-built_in">getLastName</span>() &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; <span class="hljs-built_in">getFirstName</span>() &lt;&lt; endl;<br>     cout &lt;&lt; <span class="hljs-string">&quot;-------------------------&quot;</span> &lt;&lt; endl;<br>     cout &lt;&lt; (<span class="hljs-built_in">isHired</span>() ? <span class="hljs-string">&quot;Current Employee&quot;</span> : <span class="hljs-string">&quot;Former Employee&quot;</span>) &lt;&lt; endl;<br>     cout &lt;&lt; <span class="hljs-string">&quot;Employee Number : &quot;</span> &lt;&lt; <span class="hljs-built_in">getEmployeeNumber</span>() &lt;&lt; endl;<br>     cout &lt;&lt; <span class="hljs-string">&quot;Salary: $&quot;</span> &lt;&lt; <span class="hljs-built_in">getSalary</span>() &lt;&lt; endl;<br>     cout &lt;&lt; std::endl;<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Employee::setFirstName</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; firstName)</span></span><br><span class="hljs-function"> </span>&#123;<br>     mFirstName = firstName;<br> &#125;<br> <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">Employee::getFirstName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">return</span> mFirstName;<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Employee::setLastName</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; lastName)</span></span><br><span class="hljs-function"> </span>&#123;<br>     mLastName = lastName;<br> &#125;<br> <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">Employee::getLastName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">return</span> mLastName;<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Employee::setEmployeeNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> employeeNumber)</span></span><br><span class="hljs-function"> </span>&#123;<br>     mEmployeeNumber = employeeNumber;<br> &#125;<br> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Employee::getEmployeeNumber</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">return</span> mEmployeeNumber;<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Employee::setSalary</span><span class="hljs-params">(<span class="hljs-type">int</span> newSalary)</span></span><br><span class="hljs-function"> </span>&#123;<br>     mSalary = newSalary;<br> &#125;<br> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Employee::getSalary</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">return</span> mSalary;<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Employee::isHired</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">return</span> mHired;<br> &#125;<br>&#125;<br><br><span class="hljs-comment">/*--------------------------------------------分隔符---------------------------------------------------*/</span><br><br><span class="hljs-comment">// Database.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Employee.h&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> Records<br>&#123;<br> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kFirstEmployeeNumber = <span class="hljs-number">1000</span>;<br> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Database</span><br> &#123;<br> <span class="hljs-keyword">public</span>:<br>     <span class="hljs-function">std::unique_ptr&lt;Employee&gt;&amp; <span class="hljs-title">addEmployee</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; firstName,</span></span><br><span class="hljs-params"><span class="hljs-function">                                           <span class="hljs-type">const</span> std::string&amp; lastName)</span></span>;<br>     <span class="hljs-function">std::unique_ptr&lt;Employee&gt;&amp; <span class="hljs-title">getEmployee</span><span class="hljs-params">(<span class="hljs-type">int</span> employeeNumber)</span></span>;<br>     <span class="hljs-function">std::unique_ptr&lt;Employee&gt;&amp; <span class="hljs-title">getEmployee</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; firstName,</span></span><br><span class="hljs-params"><span class="hljs-function">                                           <span class="hljs-type">const</span> std::string&amp; lastName)</span></span>;<br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeEmployee</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; firstName,</span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-type">const</span> std::string&amp; lastName)</span></span>;<br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeEmployee</span><span class="hljs-params">(<span class="hljs-type">int</span> employeeNumber)</span></span>;<br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeUnhiredEmployee</span><span class="hljs-params">()</span></span>;<br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">displayAll</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">displayCurrent</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">displayFormer</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>     std::vector&lt;std::unique_ptr&lt;Employee&gt;&gt; mEmployees;<br>     <span class="hljs-type">int</span> mNextEmployeeNumber = kFirstEmployeeNumber;<br> &#125;;<br>&#125;<br><br><span class="hljs-comment">/*--------------------------------------------分隔符---------------------------------------------------*/</span><br><br><span class="hljs-comment">// Database.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Database.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-keyword">namespace</span> Records<br>&#123;<br> <span class="hljs-function">std::unique_ptr&lt;Employee&gt;&amp; <span class="hljs-title">Database::addEmployee</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; firstName,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                 <span class="hljs-type">const</span> std::string&amp; lastName)</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">auto</span> theEmployee = std::<span class="hljs-built_in">make_unique</span>&lt;Employee&gt;(firstName, lastName);<br>     theEmployee-&gt;<span class="hljs-built_in">setEmployeeNumber</span>(mNextEmployeeNumber++);<br>     theEmployee-&gt;<span class="hljs-built_in">hire</span>();<br>     mEmployees.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(theEmployee));<br><br>     <span class="hljs-keyword">return</span> mEmployees[mEmployees.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br> &#125;<br><br> <span class="hljs-function">std::unique_ptr&lt;Employee&gt;&amp; <span class="hljs-title">Database::getEmployee</span><span class="hljs-params">(<span class="hljs-type">int</span> employeeNumber)</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">if</span> (!mEmployees.<span class="hljs-built_in">empty</span>())<br>     &#123;<br>         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; employee : mEmployees)<br>         &#123;<br>             <span class="hljs-keyword">if</span> (employee-&gt;<span class="hljs-built_in">getEmployeeNumber</span>() == employeeNumber)<br>             &#123;<br>                 <span class="hljs-keyword">return</span> employee;<br>             &#125;<br>         &#125;<br>         <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">logic_error</span>(<span class="hljs-string">&quot;No employee found.&quot;</span>);<br>     &#125;<br>     <span class="hljs-keyword">else</span><br>     &#123;<br>         std::cerr &lt;&lt; <span class="hljs-string">&quot;No employees in the database.&quot;</span> &lt;&lt; std::endl;<br>         <span class="hljs-comment">// 返回一个空指针或者抛出异常，具体取决于你的需求</span><br>         <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">logic_error</span>(<span class="hljs-string">&quot;No employees in the database.&quot;</span>);<br>     &#125;<br> &#125;<br><br><br><span class="hljs-function">std::unique_ptr&lt;Employee&gt;&amp; <span class="hljs-title">Database::getEmployee</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; firstName,</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-type">const</span> std::string&amp; lastName)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">if</span> (!mEmployees.<span class="hljs-built_in">empty</span>())<br> &#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; employee : mEmployees)<br>     &#123;<br>         <span class="hljs-keyword">if</span> (employee-&gt;<span class="hljs-built_in">getFirstName</span>() == firstName &amp;&amp; employee-&gt;<span class="hljs-built_in">getLastName</span>() == lastName)<br>         &#123;<br>             <span class="hljs-keyword">return</span> employee;<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">logic_error</span>(<span class="hljs-string">&quot;No employee found.&quot;</span>);<br> &#125;<br> <span class="hljs-keyword">else</span><br> &#123;<br>     std::cerr &lt;&lt; <span class="hljs-string">&quot;No employees in the database.&quot;</span> &lt;&lt; std::endl;<br>     <span class="hljs-comment">// 返回一个空指针或者抛出异常，具体取决于你的需求</span><br>     <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">logic_error</span>(<span class="hljs-string">&quot;No employees in the database.&quot;</span>);<br> &#125;<br>&#125;<br><br><br> <span class="hljs-comment">//void Database::removeEmployee(const std::string&amp; firstName,</span><br> <span class="hljs-comment">//                              const std::string&amp; lastName) </span><br> <span class="hljs-comment">//&#123;</span><br> <span class="hljs-comment">//    auto item = std::find(mEmployees.begin(), mEmployees.end(), getEmployee(firstName, lastName));</span><br> <span class="hljs-comment">//    if (item != mEmployees.end() || ((*mEmployees.end())-&gt;getFirstName() == firstName &amp;&amp; (*mEmployees.end())-&gt;getFirstName() == lastName))</span><br> <span class="hljs-comment">//    &#123;</span><br> <span class="hljs-comment">//        mEmployees.erase(item);</span><br> <span class="hljs-comment">//    &#125;</span><br> <span class="hljs-comment">//    else </span><br> <span class="hljs-comment">//    &#123;</span><br> <span class="hljs-comment">//        std::cerr &lt;&lt; &quot;Element not found.&quot; &lt;&lt; std::endl;</span><br> <span class="hljs-comment">//    &#125;</span><br> <span class="hljs-comment">//&#125;</span><br><br> <span class="hljs-comment">//void Database::removeEmployee(int employeeNumber)</span><br> <span class="hljs-comment">//&#123;</span><br> <span class="hljs-comment">//    auto item = std::find(mEmployees.begin(), mEmployees.end(), getEmployee(employeeNumber));</span><br> <span class="hljs-comment">//        if ((*item)-&gt;getEmployeeNumber() == employeeNumber)</span><br> <span class="hljs-comment">//        &#123;</span><br> <span class="hljs-comment">//            mEmployees.erase(item);</span><br> <span class="hljs-comment">//        &#125;</span><br> <span class="hljs-comment">//&#125;</span><br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Database::removeEmployee</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; firstName, <span class="hljs-type">const</span> std::string&amp; lastName)</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">if</span> (!mEmployees.<span class="hljs-built_in">empty</span>())<br>     &#123;<br>         mEmployees.<span class="hljs-built_in">erase</span>(<br>             std::<span class="hljs-built_in">remove_if</span>(mEmployees.<span class="hljs-built_in">begin</span>(), mEmployees.<span class="hljs-built_in">end</span>(), [&amp;firstName, &amp;lastName](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; employee) &#123;<br>                 <span class="hljs-keyword">return</span> employee-&gt;<span class="hljs-built_in">getFirstName</span>() == firstName &amp;&amp; employee-&gt;<span class="hljs-built_in">getLastName</span>() == lastName;<br>                 &#125;),<br>             mEmployees.<span class="hljs-built_in">end</span>()<br>         );<br>         cout &lt;&lt; <span class="hljs-string">&quot;This employee is removed&quot;</span> &lt;&lt; endl;<br>     &#125;<br>     <span class="hljs-keyword">else</span><br>     &#123;<br>         std::cerr &lt;&lt; <span class="hljs-string">&quot;No employees in the database.&quot;</span> &lt;&lt; std::endl;<br>     &#125;<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Database::removeEmployee</span><span class="hljs-params">(<span class="hljs-type">int</span> employeeNumber)</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">if</span> (!mEmployees.<span class="hljs-built_in">empty</span>())<br>     &#123;<br>         mEmployees.<span class="hljs-built_in">erase</span>(<br>             std::<span class="hljs-built_in">remove_if</span>(mEmployees.<span class="hljs-built_in">begin</span>(), mEmployees.<span class="hljs-built_in">end</span>(), [employeeNumber](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; employee) &#123;<br>                 <span class="hljs-keyword">return</span> employee-&gt;<span class="hljs-built_in">getEmployeeNumber</span>() == employeeNumber;<br>                 &#125;),<br>             mEmployees.<span class="hljs-built_in">end</span>()<br>         );<br>         cout &lt;&lt; <span class="hljs-string">&quot;This employee is removed&quot;</span> &lt;&lt; endl;<br>     &#125;<br>     <span class="hljs-keyword">else</span><br>     &#123;<br>         std::cerr &lt;&lt; <span class="hljs-string">&quot;No employees in the database.&quot;</span> &lt;&lt; std::endl;<br>     &#125;<br> &#125;<br><br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Database::removeUnhiredEmployee</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">if</span> (!mEmployees.<span class="hljs-built_in">empty</span>())<br>     &#123;<br>         mEmployees.<span class="hljs-built_in">erase</span><br>         (std::<span class="hljs-built_in">remove_if</span>(mEmployees.<span class="hljs-built_in">begin</span>(),<br>             mEmployees.<span class="hljs-built_in">end</span>(),<br>             [](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; employee)<br>             &#123;<br>                 <span class="hljs-keyword">return</span> !employee-&gt;<span class="hljs-built_in">isHired</span>(); <span class="hljs-comment">// 移除所有未雇佣的员工</span><br>             &#125;),<br>             mEmployees.<span class="hljs-built_in">end</span>()<br>         );<br>         cout &lt;&lt; <span class="hljs-string">&quot;Fired employees are removed&quot;</span> &lt;&lt; endl;<br>     &#125;<br>     <span class="hljs-keyword">else</span><br>     &#123;<br>         std::cerr &lt;&lt; <span class="hljs-string">&quot;No employees in the database.&quot;</span> &lt;&lt; std::endl;<br>     &#125;<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Database::displayAll</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">if</span> (!mEmployees.<span class="hljs-built_in">empty</span>())<br>     &#123;<br>         <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; employee : mEmployees)<br>         &#123;<br>             employee-&gt;<span class="hljs-built_in">display</span>();<br>         &#125;<br>         cout &lt;&lt; <span class="hljs-string">&quot;All employees are printed above&quot;</span> &lt;&lt; endl;<br>     &#125;<br>     <span class="hljs-keyword">else</span><br>     &#123;<br>         std::cerr &lt;&lt; <span class="hljs-string">&quot;No employees in the database.&quot;</span> &lt;&lt; std::endl;<br>     &#125;<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Database::displayCurrent</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">if</span> (!mEmployees.<span class="hljs-built_in">empty</span>())<br>     &#123;<br>         <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; employee : mEmployees)<br>         &#123;<br>             <span class="hljs-keyword">if</span> (employee-&gt;<span class="hljs-built_in">isHired</span>() == <span class="hljs-literal">true</span>)<br>             &#123;<br>                 employee-&gt;<span class="hljs-built_in">display</span>();<br>             &#125;<br>         &#125;<br>         cout &lt;&lt; <span class="hljs-string">&quot;Current employees are printed above&quot;</span> &lt;&lt; endl;<br>     &#125;<br>     <span class="hljs-keyword">else</span><br>     &#123;<br>         std::cerr &lt;&lt; <span class="hljs-string">&quot;No employees in the database.&quot;</span> &lt;&lt; std::endl;<br>     &#125;<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Database::displayFormer</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">if</span> (!mEmployees.<span class="hljs-built_in">empty</span>()) <br>     &#123;<br>         <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; employee : mEmployees)<br>         &#123;<br>             <span class="hljs-keyword">if</span> (employee-&gt;<span class="hljs-built_in">isHired</span>() == <span class="hljs-literal">false</span>)<br>             &#123;<br>                 employee-&gt;<span class="hljs-built_in">display</span>();<br>             &#125;<br>         &#125;<br>         cout &lt;&lt; <span class="hljs-string">&quot;Former employees are printed above&quot;</span> &lt;&lt; endl;<br>     &#125;<br>     <span class="hljs-keyword">else</span> <br>     &#123;<br>         std::cerr &lt;&lt; <span class="hljs-string">&quot;No employees in the database.&quot;</span> &lt;&lt; std::endl;<br>     &#125;<br> &#125;<br>&#125;<br><br><span class="hljs-comment">/*--------------------------------------------分隔符---------------------------------------------------*/</span><br><br><span class="hljs-comment">// UItest.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;exception&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;limits&gt;</span>           <span class="hljs-comment">// 用于清除输入缓冲区</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Database.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><span class="hljs-keyword">using</span> std::string;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">displayMenu</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doHire</span><span class="hljs-params">(Records::Database&amp; db)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doFire</span><span class="hljs-params">(Records::Database&amp; db)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doPromote</span><span class="hljs-params">(Records::Database&amp; db)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doDemote</span><span class="hljs-params">(Records::Database&amp; db)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> Records::Database employeeDB;<br> <span class="hljs-type">bool</span> done = <span class="hljs-literal">false</span>;<br> <span class="hljs-keyword">while</span> (!done)<br> &#123;<br>     <span class="hljs-type">int</span> selection = <span class="hljs-built_in">displayMenu</span>();<br>     <span class="hljs-keyword">switch</span> (selection)<br>     &#123;<br>     <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>         done = <span class="hljs-literal">true</span>;<br>         <span class="hljs-keyword">break</span>;<br>     <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>         <span class="hljs-built_in">doHire</span>(employeeDB);<br>         <span class="hljs-keyword">break</span>;<br>     <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>         <span class="hljs-built_in">doFire</span>(employeeDB);<br>         <span class="hljs-keyword">break</span>;<br>     <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>         <span class="hljs-built_in">doPromote</span>(employeeDB);<br>         <span class="hljs-keyword">break</span>;<br>     <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>         employeeDB.<span class="hljs-built_in">displayAll</span>();<br>         <span class="hljs-keyword">break</span>;<br>     <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>         employeeDB.<span class="hljs-built_in">displayCurrent</span>();<br>         <span class="hljs-keyword">break</span>;<br>     <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>         employeeDB.<span class="hljs-built_in">displayFormer</span>();<br>         <span class="hljs-keyword">break</span>;<br>     <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<br>         employeeDB.<span class="hljs-built_in">removeUnhiredEmployee</span>();<br>         <span class="hljs-keyword">break</span>;<br>     <span class="hljs-keyword">default</span>:<br>         std::cerr &lt;&lt; <span class="hljs-string">&quot;Unknown command.&quot;</span> &lt;&lt; endl;<br>         <span class="hljs-keyword">break</span>;<br>     &#125;<br> &#125;<br><br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* displayMenu() 函数输出菜单获取用户输入。</span><br><span class="hljs-comment">在此假定用户能够“正确地输入”，当需要一个数字时就输入一个数字，这一点很重要。</span><br><span class="hljs-comment">在阅读了第 13 章有关 I / O 的内容后，你就会知道如何防止输入错误信息*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">displayMenu</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-type">int</span> selection;<br> cout &lt;&lt; endl;<br> cout &lt;&lt; <span class="hljs-string">&quot;Employee Database&quot;</span> &lt;&lt; endl;<br> cout &lt;&lt; <span class="hljs-string">&quot;-----------------&quot;</span> &lt;&lt; endl;<br> cout &lt;&lt; <span class="hljs-string">&quot;1) Hire a new employee&quot;</span> &lt;&lt; endl;<br> cout &lt;&lt; <span class="hljs-string">&quot;2) Fire an employee&quot;</span> &lt;&lt; endl;<br> cout &lt;&lt; <span class="hljs-string">&quot;3) Promote an employee&quot;</span> &lt;&lt; endl;<br> cout &lt;&lt; <span class="hljs-string">&quot;4) List all employees&quot;</span> &lt;&lt; endl;<br> cout &lt;&lt; <span class="hljs-string">&quot;5) List all current employee&quot;</span> &lt;&lt; endl;<br> cout &lt;&lt; <span class="hljs-string">&quot;6) List all former employee&quot;</span> &lt;&lt; endl;<br> cout &lt;&lt; <span class="hljs-string">&quot;7) Remove all unhired employees&quot;</span> &lt;&lt; endl;<br> cout &lt;&lt; <span class="hljs-string">&quot;0) Quit&quot;</span> &lt;&lt; endl;<br> cout &lt;&lt; <span class="hljs-string">&quot;---&gt;   &quot;</span>;<br><br> <span class="hljs-comment">// 循环，直到得到有效的输入</span><br> <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br> &#123;<br>     <span class="hljs-comment">// 尝试读取用户输入</span><br>     <span class="hljs-keyword">try</span><br>     &#123;<br>         std::cin &gt;&gt; selection;<br><br>         <span class="hljs-comment">// 检查输入流的状态</span><br>         <span class="hljs-keyword">if</span> (std::cin.<span class="hljs-built_in">fail</span>())<br>         &#123;<br>             <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Invalid input. Please enter a number.&quot;</span>);<br>         &#125;<br><br>         <span class="hljs-comment">// 如果程序能够执行到这里，说明输入是有效的</span><br>         <span class="hljs-keyword">break</span>;<br>     &#125;<br>     <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::invalid_argument&amp; exception)<br>     &#123;<br>         std::cerr &lt;&lt; <span class="hljs-string">&quot;Error: &quot;</span> &lt;&lt; exception.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br><br>         <span class="hljs-comment">// 清除错误状态</span><br>         std::cin.<span class="hljs-built_in">clear</span>();<br><br>         <span class="hljs-comment">// 忽略缓冲区中的无效字符，直到遇到换行符</span><br>         std::cin.<span class="hljs-built_in">ignore</span>(std::numeric_limits&lt;std::streamsize&gt;::<span class="hljs-built_in">max</span>(), <span class="hljs-string">&#x27;\n&#x27;</span>);<br>     &#125;<br> &#125;<br><br> <span class="hljs-keyword">return</span> selection;<br>&#125;<br><br><span class="hljs-comment">/* doHire() 函数获取用户输入的新雇员的姓名，并通知数据库添加这个雇员*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doHire</span><span class="hljs-params">(Records::Database&amp; db)</span></span><br><span class="hljs-function"></span>&#123;<br> string firstName;<br> string lastName;<br><br> cout &lt;&lt; <span class="hljs-string">&quot;First name? input: &quot;</span>;<br> std::cin &gt;&gt; firstName;<br><br> cout &lt;&lt; <span class="hljs-string">&quot;Last name? input: &quot;</span>;<br> std::cin &gt;&gt; lastName;<br><br> db.<span class="hljs-built_in">addEmployee</span>(firstName, lastName);<br>&#125;<br><br><span class="hljs-comment">/* doFire() 、doPromote() 以及 doDemote() 函数都要求数据库根据雇员号找到雇员，然后使用 Employee 对象的 public 方法进行修改*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doFire</span><span class="hljs-params">(Records::Database&amp; db)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-type">int</span> employeeNumber;<br><br> cout &lt;&lt; <span class="hljs-string">&quot;Employee number? input: &quot;</span>;<br> std::cin &gt;&gt; employeeNumber;<br><br> <span class="hljs-comment">// 将 try 遇到的问题抛出，并继续执行程序</span><br> <span class="hljs-keyword">try</span><br> &#123;<br>     <span class="hljs-keyword">if</span> (db.<span class="hljs-built_in">getEmployee</span>(employeeNumber)-&gt;<span class="hljs-built_in">isHired</span>())<br>     &#123;<br>         db.<span class="hljs-built_in">getEmployee</span>(employeeNumber)-&gt;<span class="hljs-built_in">fire</span>();<br>         cout &lt;&lt; <span class="hljs-string">&quot;Employee &quot;</span> &lt;&lt; employeeNumber &lt;&lt; <span class="hljs-string">&quot;is terminated.&quot;</span> &lt;&lt; endl;<br>     &#125;<br>     <span class="hljs-keyword">else</span><br>     &#123;<br>         std::cerr &lt;&lt; <span class="hljs-string">&quot;Employee has been fired&quot;</span> &lt;&lt; endl;<br>     &#125;<br> &#125;<br> <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::logic_error&amp; exception)<br> &#123;<br>     std::cerr &lt;&lt; <span class="hljs-string">&quot;Unable to terminate employee: &quot;</span> &lt;&lt; exception.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br> &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doPromote</span><span class="hljs-params">(Records::Database&amp; db)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-type">int</span> employeeNumber;<br> <span class="hljs-type">int</span> raiseAmount;<br><br> cout &lt;&lt; <span class="hljs-string">&quot;Employee number? input: &quot;</span>;<br> std::cin &gt;&gt; employeeNumber;<br><br> cout &lt;&lt; <span class="hljs-string">&quot;How much of a raise? input: &quot;</span>;<br> std::cin &gt;&gt; raiseAmount;<br><br> <span class="hljs-keyword">try</span><br> &#123;<br>     <span class="hljs-keyword">if</span> (db.<span class="hljs-built_in">getEmployee</span>(employeeNumber)-&gt;<span class="hljs-built_in">isHired</span>())<br>     &#123;<br>         db.<span class="hljs-built_in">getEmployee</span>(employeeNumber)-&gt;<span class="hljs-built_in">promote</span>(raiseAmount);<br>         cout &lt;&lt; <span class="hljs-string">&quot;Employee &quot;</span> &lt;&lt; employeeNumber &lt;&lt; <span class="hljs-string">&quot;is promoted.&quot;</span> &lt;&lt; endl;<br>     &#125;<br>     <span class="hljs-keyword">else</span><br>     &#123;<br>         std::cerr &lt;&lt; <span class="hljs-string">&quot;Employee has been fired&quot;</span> &lt;&lt; endl;<br>     &#125;<br> &#125;<br> <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::logic_error&amp; exception)<br> &#123;<br>     std::cerr &lt;&lt; <span class="hljs-string">&quot;Unable to promote employee: &quot;</span> &lt;&lt; exception.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br> &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doDemote</span><span class="hljs-params">(Records::Database&amp; db)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-type">int</span> employeeNumber;<br> <span class="hljs-type">int</span> demeritAmount;<br><br> cout &lt;&lt; <span class="hljs-string">&quot;Employee number? input: &quot;</span>;<br> std::cin &gt;&gt; employeeNumber;<br><br> cout &lt;&lt; <span class="hljs-string">&quot;How much of a demerit? input: &quot;</span>;<br> std::cin &gt;&gt; demeritAmount;<br><br> <span class="hljs-keyword">try</span><br> &#123;<br>     db.<span class="hljs-built_in">getEmployee</span>(employeeNumber)-&gt;<span class="hljs-built_in">demote</span>(demeritAmount);<br> &#125;<br> <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::logic_error&amp; exception)<br> &#123;<br>     std::cerr &lt;&lt; <span class="hljs-string">&quot;Unable to promote employee: &quot;</span> &lt;&lt; exception.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<hr>
<h3 id="1-7-本章小结"><a href="#1-7-本章小结" class="headerlink" title="1.7    本章小结"></a><strong>1.7    本章小结</strong></h3><hr>
<ul>
<li>我上面所书写的代码并不是按照书上的格式写的，我使用了智能指针来实现这个工程，而不是书上说书写的 Employee 类的 vector，而是它的智能指针的 vector； </li>
<li>现在已经了解了 C++的基本知识，为成为专业 C++程序员做好了准备。在开始深入学习本书后面的 C++ 语言知识时，可查阅本章以回顾需要复习的内容。为了回顾那些被遗忘的概念，只需要查看本章的一些示例代码。</li>
<li>编写的每个程序都必须以这样或那样的方式使用字符串。为此，下一章将深入讲解如何在 C++ 中处理字符串。</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E7%BC%96%E7%A8%8B/" class="print-no-link">#编程</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>C++ 复习教程第一章（C++ 和标准库速成）</div>
      <div>http://example.com/2024/03/14/C++ 复习教程第一章（高级编程）/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>yanhuigang</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年3月14日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/03/14/C++%20%E5%A4%8D%E4%B9%A0%E6%95%99%E7%A8%8B%E7%AC%AC%E4%B9%9D%E7%AB%A0%EF%BC%88%E7%B2%BE%E9%80%9A%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%89/" title="C++ 复习教程第九章（精通类与对象）">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">C++ 复习教程第九章（精通类与对象）</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/03/10/%E4%BD%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%B0%88%E6%81%8B%E7%88%B1%EF%BC%9F/" title="你为什么不谈恋爱？">
                        <span class="hidden-mobile">你为什么不谈恋爱？</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
