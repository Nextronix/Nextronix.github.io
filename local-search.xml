<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++ 复习教程第七章（内存管理）</title>
    <link href="/2024/03/14/C++%20%E5%A4%8D%E4%B9%A0%E6%95%99%E7%A8%8B%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/"/>
    <url>/2024/03/14/C++%20%E5%A4%8D%E4%B9%A0%E6%95%99%E7%A8%8B%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="第7章-——-内存管理"><a href="#第7章-——-内存管理" class="headerlink" title="第7章 —— 内存管理"></a>第7章 —— 内存管理</h2><blockquote><p>C++ 十分灵活，为了保证这一点，是对程序员采取不干预策略的，即，C++假定程序员知道自己在做什么，即使程序员没有意识到自己做错了什么，也就是说它允许采用一些可能出错的领域。总之，C++ 为了灵活性，而牺牲了部分安全性。内存的分配和管理是 C++ 编程中最容易出错的一个领域，接下来，我们将对它的内存幕后工作原理进行了解，以写出高质量 C++ 程序。</p><p>本章讨论底层内存处理，因为专业的 C++ 程序员将遇到此类代码。<strong>但在现代 C++  中，应尽可能避免底层内存操作。</strong>例如：</p><ul><li><strong>不应使用动态分配内存的 C 风格数组，而应使用标准库容器，例如 vector, 它会自动处理所有内存分配操作。</strong>  </li><li><strong>不应使用裸指针，而应使用智能指针，例如 unique_ptr 和 shared_ptr, 它们会自动释放不再需要的底层资源，例如内存。</strong></li></ul><p><strong>基本上，应尝试避免在代码中调用内存分配例程，例如new&#x2F;new[]和 delete&#x2F;delete[]。当然，这并不总是可行的，在现有的代码中，很可能并非如此，所以专业 C++程序员仍需要了解内存在幕后的工作原理。</strong>  </p><p><strong>警告：</strong></p><p><strong>在现代 C++中，应尽可能避免底层内存操作，而使用现代结构，例如容器和智能指针。</strong></p></blockquote><hr><h3 id="7-1使用动态内存"><a href="#7-1使用动态内存" class="headerlink" title="7.1使用动态内存"></a>7.1使用动态内存</h3><blockquote><p>内存是计算机的低级组件，遗憾的是，即使在 C++这样的高级语言中也仍要面对内存的问题。<strong>很多程序员只是对动态内存有基本的了解。他们回避使用动态内存的数据结构，或通过试错法让程序能正常工作。</strong>扎实理解 C++动态内存的工作原理对于成为一名专业的 C++程序员至关重要。  </p></blockquote><hr><h4 id="1-1如何描绘内存"><a href="#1-1如何描绘内存" class="headerlink" title="1.1如何描绘内存"></a>1.1如何描绘内存</h4><blockquote><p><strong>堆栈（Stack）和堆（Heap）是计算机内存中用于存储数据的两个主要区域</strong>，它们有一些关键的区别：</p><ol><li><strong>分配方式：</strong><ul><li><strong>堆栈：</strong> 数据在堆栈上分配，以一种后进先出（LIFO）的方式进行管理。当一个函数被调用时，其局部变量和函数调用信息被压入堆栈，函数执行结束时，这些数据从堆栈中弹出。这样的分配和释放是自动进行的。</li><li><strong>堆：</strong> 堆上的内存分配和释放是手动进行的。在堆上分配内存需要明确的请求和释放过程。通常使用<code>new</code>（C++）或<code>malloc</code>（C语言）来在堆上分配内存，而使用<code>delete</code>（C++）或<code>free</code>（C语言）来释放堆上的内存。</li></ul></li><li><strong>大小：</strong><ul><li><strong>堆栈：</strong> 通常较小，其大小受限于系统设置的栈大小。堆栈主要用于存储函数调用和局部变量等较小的数据。</li><li><strong>堆：</strong> 可以比较大，通常受限于系统总体内存大小。堆主要用于存储动态分配的数据，例如通过<code>new</code>或<code>malloc</code>分配的对象。</li></ul></li><li><strong>生存期：</strong><ul><li><strong>堆栈：</strong> 数据的生存期与其所在函数的执行周期相关。当函数执行结束时，堆栈上的数据被自动释放。</li><li><strong>堆：</strong> 数据的生存期可以长于其分配它的函数执行周期，因为堆上的数据需要手动释放。</li></ul></li><li><strong>管理：</strong><ul><li><strong>堆栈：</strong> 由编译器自动管理，无需手动干预。</li><li><strong>堆：</strong> 开发人员需要手动管理内存，确保在不再需要时释放分配的内存，以防止内存泄漏。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span>* ptr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>; <span class="hljs-comment">// 在堆上分配内存</span><br><br>    <span class="hljs-comment">// 假设这里有一些代码，然后我们忘记释放 ptr 指向的内存</span><br><br>    <span class="hljs-comment">// 当 main 函数结束时，ptr 指针变量会被销毁，但指向的堆内存没有被释放</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 内存泄漏发生</span><br>&#125;<br><br><span class="hljs-comment">// 对就是这样使得这个指针丢失，然后那个堆上内存没释放的</span><br></code></pre></td></tr></table></figure><p><strong>警告：</strong></p><p><strong>作为经验法则，每次声明一个指针变量时，务必立即用适当的指针或 nullptr 进行初始化！</strong></p><p>下一个例子展示了指针既可以在堆栈中，也可在堆中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span>** handle = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-comment">// (int*)* handle = nullptr;</span><br><span class="hljs-comment">// 这样就很好理解，指向 int 型指针的指针 handle 了</span><br><span class="hljs-comment">// handle 是在堆栈中的</span><br>handle = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>*;<br><span class="hljs-comment">// 给它分配出来一个 指向 int 型变量指针 的空间</span><br>*handle = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br><span class="hljs-comment">// 对 handle 进行解引用，也就是得到了当初 handle 所指空间中的那个 指向 int 型变量的指针，再为它分配空间</span><br></code></pre></td></tr></table></figure><ol><li><code>int** handle = nullptr;</code>：声明了一个指向指针的指针变量 <code>handle</code>，并将其初始化为 <code>nullptr</code>，即空指针。<code>int**</code> 表示指向 <code>int</code> 类型指针的指针。</li><li><code>handle = new int*;</code>：在堆上分配了一个 <code>int*</code> 类型的内存，并将其地址赋给 <code>handle</code>。这个 <code>int*</code> 类型指针用来存储 <code>int</code> 类型的地址。</li><li><code>*handle = new int;</code>：在堆上分配了一个 <code>int</code> 类型的内存，并将其地址存储在 <code>handle</code> 指向的位置（<code>*handle</code>）。现在，<code>handle</code> 指向的是一个 <code>int*</code> 类型的指针，而这个指针指向的是一个动态分配的 <code>int</code> 类型的内存。</li></ol><p><img src="https://bu.dusays.com/2024/03/15/65f4467e6e68b.png" alt="image-20240220143956527"></p></blockquote><hr><h4 id="1-2分配和释放"><a href="#1-2分配和释放" class="headerlink" title="1.2分配和释放"></a>1.2分配和释放</h4><blockquote><ol><li><p>使用 new 和 delete</p><blockquote><p>由于堆栈和栈的区别，那么就代表着可能在指针失效，而其所指空间未释放，这叫做内存泄漏。</p><p>经验：</p><ul><li>一个 new 对应后面一个 delete;</li><li>ptr &#x3D; nullptr 将上述 一个 new 和 一个 delelte 包裹起来；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span>* prt = <span class="hljs-literal">nullptr</span>;<br>ptr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br>...<br><span class="hljs-keyword">delete</span> ptr;<br>ptr = <span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>关于 malloc() 函数</p><blockquote><p>虽然 C++  中也存在 malloc()，但应该避免使用它，new 相比 malloc() 的主要好处式：new 不仅分配内存，还构建对象；例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">Foo* myFoo = (Foo*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Foo));<br><span class="hljs-comment">// 只分配空间，不创建对象</span><br>Foo* myOtherFoo = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Foo</span>();<br><span class="hljs-comment">// 分配空间，也创建对象</span><br></code></pre></td></tr></table></figure><p>执行这些代码行后，myFoo 和 myOtherFoo 将指向堆中足以保存 Foo 对象的内存区域。通过这两个指针可访问 Foo 的数据成员和方法。不同之处在于，myFoo 指向的 Foo 对象不是一个正常的对象，因为这个对象从未构建。malloco函数只负责留出一块一定大小的内存。它不知道或关心对象本身。相反，调用 new 不仅会分配正确大小的内存，还会调用相应的构造函数以构建对象。</p></blockquote></li><li><p>当内存分配失败时</p><blockquote><p>很多程序员会假设 new 总是会成功。他们的理由是，如果 new 失败了，则意味着内存量非常低，情况就非常糟糕了。这是一个无法预知的状态，因为不知道程序在这种情况下可能做什么。</p><p>默认情况下，如果 new 失败了，程序会终止。在许多程序中，这种行为是可以接受的。当 new 因为没有足以满足请求的内存而抛出异常失败时，程序退出。第 14 章将讲解如何在内存不足的情况下正常地恢复。</p><p>也有不抛出异常的 new 版本。相反，它会返回 nullptr, 这类似于 C 语言中 malloc()的行为。使用这个版本的语法如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span>* ptr = <span class="hljs-built_in">new</span>(nothrow) <span class="hljs-type">int</span>;<br></code></pre></td></tr></table></figure><p>当然，仍然要面对与抛出异常的版本同样的问题——如果结果是 nullptr, 怎么办？编译器不要求检查结果，因此 new 的 nothrow 版本可能导致除了抛出异常的版本遇到的 bug 之外的其他 bug。下面给出示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;new&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span>* ptr = <span class="hljs-built_in">new</span>(std::nothrow) <span class="hljs-type">int</span>;<br><span class="hljs-keyword">if</span> (ptr == <span class="hljs-literal">nullptr</span>) &#123;<br>  <span class="hljs-comment">// 处理内存分配失败的情况</span><br>  std::cerr &lt;&lt; <span class="hljs-string">&quot;Memory allocation failed!&quot;</span> &lt;&lt; std::endl;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 继续执行程序</span><br>  *ptr = <span class="hljs-number">42</span>;<br>  <span class="hljs-comment">// 其他代码依赖于 ptr 不为空</span><br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Value at ptr: &quot;</span> &lt;&lt; *ptr &lt;&lt; std::endl; <span class="hljs-comment">// 这里依赖于 ptr 不为空</span><br>  <span class="hljs-keyword">delete</span> ptr; <span class="hljs-comment">// 注意：确保在不再需要时释放内存</span><br>&#125;<br><br><span class="hljs-comment">// 其他代码，继续依赖于 ptr 不为空</span><br><span class="hljs-type">int</span> result = *ptr; <span class="hljs-comment">// 这里依赖于 ptr 不为空，但实际上 ptr 是空指针</span><br><span class="hljs-comment">// 这里的解引用，如果是 nullptr 的话，是错误的</span><br><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，建议使用标准版本的 new。如果内存不足的恢复对程序非常重要，请参阅第 14 章，该章给出了需要的所有工具。</p></blockquote></li></ol></blockquote><hr><h4 id="1-3数组"><a href="#1-3数组" class="headerlink" title="1.3数组"></a>1.3数组</h4><blockquote><p>数组将多个同一类型的变量封装在一个通过索引访问的变量中。</p><ol><li><p>基本类型的数组</p><ul><li>大小不变。区分动态数组和动态分配的数组。</li><li><strong>在 C++ 中有一个继承自 C 的函数 realloc()。不要使用它！</strong>在 C 中，realloc() 用于改变数组的大小，采用的方式是分配新大小的新内存块，然后将所有旧数据内存块复制到新位置，再删除就内存块。在 C++ 中这是极为危险的，因为用户定义的对象不能很好地适应按位复制。</li></ul></li><li><p>对象的数组</p><ul><li><pre><code class="c++">class Simple&#123;public:    Simple() &#123;std::cout &lt;&lt; &quot;Simple constructor called!&quot; &lt;&lt; std::endl;&#125;    ~Simple() &#123;std::cout &lt;&lt; &quot;Simple destructor called!&quot; &lt;&lt; std::endl;&#125;&#125;;// 给出这个类，后面会用<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br>   - 与 简单类型 的数组没什么区别。<br><br>   - 通过 <span class="hljs-keyword">new</span>[N]分配 N 个对象的数组时，实际上分配了 N 个连续的内存块，每一块足以容纳单个对象。使用 <span class="hljs-keyword">new</span>[] 时，每个对象的无参构造函数(= <span class="hljs-keyword">default</span>)会自动调用。这样，通过 <span class="hljs-keyword">new</span>[] 分配对象数组时，会返回一个指向数组的指针，这个数组中的所有对象都被初始化了。  <br><br>   - 当然在数组元素是对象的时候，才调用析构函数。<br><br><span class="hljs-number">3.</span> 删除数组<br><br>   - 和上面说的一样，先用 <span class="hljs-keyword">delete</span>，再将指针指向 <span class="hljs-literal">nullptr</span>。<br><br>   - <span class="hljs-keyword">new</span> &lt;---&gt; <span class="hljs-keyword">delete</span>;<br><br>   - <span class="hljs-keyword">new</span> [] &lt;---&gt; <span class="hljs-keyword">delete</span> []<br><br>   - 总是使得上面这两个对应。<br><br>   - ```c++<br>     <span class="hljs-comment">// 为指向 Simple指针 的数组分配空间，来存储 Simple指针</span><br>     <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> size = <span class="hljs-number">4</span>;<br>     Simple** mySimplePtrArray = <span class="hljs-keyword">new</span> Simple*[size];<br>         <br>     <span class="hljs-comment">// Allocate an object for each pointer.</span><br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) <br>     &#123; <br>         mySimplePtrArray[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Simple</span>(); <br>     &#125;<br>     <span class="hljs-comment">// Use mySimplePtrArray...</span><br>         <br>     <span class="hljs-comment">// Delete each allocated object.</span><br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) <br>     &#123; <br>         <span class="hljs-keyword">delete</span> mySimplePtrArray[i]; <br>     &#125;<br>         <br>     <span class="hljs-comment">// Delete the array itself.</span><br>     <span class="hljs-keyword">delete</span> [] mySimplePtrArray;<br>     mySimplePtrArray = <span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></table></figure></code></pre></li><li><p>注意：</p><p><strong>在现代 C++中，应避免使用 C 风格的裸指针。</strong>所以，不要在 C 风格的数组中保存旧式的普通指针，而应在现代的标准库容器中保存智能指针。本章后面讨论这些智能指针，并且会在适当时候自动释放与其关联的内存。</p></li></ul></li><li><p>多维堆栈数组【array[] []】</p><ul><li>额，复杂，随便吧，反正我不用，书上也没讲得很仔细。</li><li>就是区分数组的级数吧，就是：array[0] 和 array[0] [0] 的区别。</li></ul></li><li><p>多维堆数组【new array[] []】</p><ul><li><p>如果需要在运行时确定多维数组的维数，可以使用堆数组。正如动态分配的一维数组是通过指针访问一样,动态分配的多维数组也通过指针访问。唯一的区别在于，在二维数组中，需要使用指针的指针：在 N 维数组中，需要使用 N 级指针。下面这种声明并动态分配多维数组的方式初看上去是正确的： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span>** board = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[i][j];<br></code></pre></td></tr></table></figure></li><li><p><strong>这段代码无法成功编译，因为堆数组和堆栈数组的工作方式不一样。多维数组的内存布局是不连续的，所以为基于堆栈的多维数组分配足够内存的方法是不正确的。</strong></p></li><li><p><strong>可以首先为堆数组的第一个下标分配一个连续的数组。</strong></p></li><li><p><strong>该数组的每个元素实际上是指向另一个数组的指针，另一个数组保存的是第二个下标维度的元素。</strong>  </p></li><li><p>上述代码只能分配第一层指针，还必须显式地分配第二层指针，如下：</p><p><img src="https://bu.dusays.com/2024/03/15/65f4467fda895.png" alt="image-20240222224018635"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">char</span>** <span class="hljs-title">allocateCharacterBoard</span><span class="hljs-params">(<span class="hljs-type">size_t</span> xDimension,<span class="hljs-type">size_t</span> yDimension)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span>** myArray = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>*[xDimension];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; xDimension; i++)<br>    &#123;<br>        myArray[i] = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[yDimension];<br>    &#125;<br>    <span class="hljs-keyword">return</span> myArray;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>释放多维堆数组的内存，也必须类似与分配数组时的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">releaseCharacterBoard</span><span class="hljs-params">(<span class="hljs-type">char</span>** myArray, <span class="hljs-type">size_t</span> xDimension)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> = <span class="hljs-number">0</span>; i &lt; xDimension; i++)<br>    &#123;<br>        <span class="hljs-keyword">delete</span> [] myArray[i];<br>    &#125;<br>    <span class="hljs-keyword">delete</span> [] myArray;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ol></blockquote><blockquote><p>知道了使用数组的细节后，我们就知道了 C 风格的数组是多么不应该受欢迎。因为这种数组完全没有提供任何安全性。这里解释它们是因为可能在旧代码中会遇到。在新代码中，应该用 C++ 的标准库容器，例如 std::array、std::vector 等。例如，用  vector<T> 表示一维动态数组，用 vector&lt;vector<T>&gt;表示二维动态数组等。当然，直接使用诸如 vector&lt;vector<T>&gt;的数据结构仍然是繁杂的，构建时尤其如此。<strong>如果应用程序中需要 N 维动态数组，建议编写帮助类，以方便使用接口。</strong>例如，要使用行长相等的二维数据，应当考虑编写(也可以重用) Matrix <T> 或 Table <T> 类模板，该模板在内部使用 vector&lt;vector<T>&gt; 数据结构。有关编写类模板的信息，请参阅第 12 章。</p><p>警告：</p><p>​不要 TM 闲的蛋疼使用 C 风格。</p><p>​可是，我真贱死了……C 语言好像用的地方真不少，可是我就是更喜欢 C++，因为它太优雅了，什么 Python，真垃圾，真疯了。</p></blockquote><hr><h4 id="1-4使用指针"><a href="#1-4使用指针" class="headerlink" title="1.4使用指针"></a>1.4使用指针</h4><blockquote><p>因为指针很容易被滥用，所以名声不佳。因为指针只是一个内存地址，所以理论上可以手动修改那个地址,甚至像下面这行代码一样做一些很可怕的事情：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span>* scaryPointer = (<span class="hljs-type">char</span>* )<span class="hljs-number">7</span>;<br></code></pre></td></tr></table></figure><p>为什么可怕？因为它在一个地址为 7 的地方，构建了一个 char 类型指针，这个地方可能时内存随机垃圾，或其他应用程序中使用的内存。如果开始使用为通过 new 分配的内存区域，那么最终将损坏与对象相关联的内存，或者破坏堆管理相关的内存，使得程序无法正常工作。这种故障可体现在几个方面：例如，可表现为无效结果，因为数据已损坏，或因为访问不存在的内存或写入受保护的内存而引发硬件异常。重则得到错误结果，轻则出现严重错误，导致操作系统或 C++运行时库终止程序。  </p><p>指针理解方式：</p><ul><li>数学头脑下：看作地址，将其理解为 内存位置的数字；</li><li>空间表示法下：看作一个“箭头”，一个间接层，告诉程序“看向那个地方”；</li><li>通过 * 运算符解除对一个指针的引用时，实际上让程序在内存中更深一步，即，从地址角度看指针：把解除引用想象为跳到与那个指针表示的地址相对应的内存。使用 图形视图 时，每次解引用都对应从针尾到针头的过程；</li><li>通过 &amp; 运算符取一个位置的地址时，在内存中添加了一个间接层，即，从地址的角度看：程序只不过是表示那个位置的数值，这个数值可保存为指针形式。在 图形视图 中，&amp; 运算符创建了一个新箭头，其头部终止于表达式表示的位置，其尾部可以保存为一个指针。</li></ul><p>指针的类型转换：</p><ul><li><p>指针的类型事实上是比较弱的，这是什么意思？意思是说，例如，指向 XML 文档的指针和指向 整数 的指针大小完全相同。这就可能造成错误转换。</p></li><li><p>编译器允许通过使用 C 风格的类型转换将任意指针类型方便地转换为任意类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">Document* documentPtr = <span class="hljs-built_in">getDocument</span>();<br><span class="hljs-type">char</span>* myCharPtr = (<span class="hljs-type">char</span>*)documentPtr;<br></code></pre></td></tr></table></figure><p>静态类型转换的安全性更高。编译器将拒绝执行不同数据类型的指针的静态类型转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">Document* documentPtr = <span class="hljs-built_in">getDocument</span>();<br><span class="hljs-type">char</span>* myCharPtr = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">char</span>*&gt;(documentPtr);<span class="hljs-comment">// Bug! Won&#x27;t compile!</span><br></code></pre></td></tr></table></figure><p>静态类型转换的安全性体现在：两个完全无关的指针不能被转换；而两个指针值之间如果存在“是一个”，也就是继承关系，那么这种转换是可以执行的。然而，在继承层次中完成转换的更安全方式是动态类型转换。那么这里就不扯淡了，之后再详细说明。</p></li></ul></blockquote><hr><h3 id="7-2数组-指针的对偶性"><a href="#7-2数组-指针的对偶性" class="headerlink" title="7.2数组-指针的对偶性"></a>7.2数组-指针的对偶性</h3><blockquote><p>正如我们所看到的，尤其在 C 中，我们会混淆(准确说，不是混淆，而是看作相同的事物)数组和指针。它们在功能和用法上，存在着重叠性。在堆上分配的数组通过指向该数组中第一个元素的指针来引用。基于堆栈的指针通过数组语法 ([]) 和普通的变量声明来引用。然而，它们之间的关系不止于此，见下。</p></blockquote><hr><h4 id="2-1数组就是指针"><a href="#2-1数组就是指针" class="headerlink" title="2.1数组就是指针"></a>2.1数组就是指针</h4><blockquote><p>通过指针不仅能指向基于堆的数组，也可以通过指针语法来访问基于堆栈的数组的元素。数组的地址就是第一个元素(索引 0 )的地址。</p><p>上面这段话说明了——数组上的每个元素都能用它的指针寻访到。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> myIntArray[<span class="hljs-number">10</span>] = &#123;&#125;;<br><span class="hljs-type">int</span>* myIntPtr = myIntArray;<br><br><span class="hljs-comment">// Access the array through the pointer.</span><br>myIntPtr[<span class="hljs-number">4</span>] = <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><p>向函数传递数组时，通过指针引用用基于堆栈的数组的能力非常有用。下面的函数以指针的方式接收一个整数数组。请注意，调用者需要显式地传入数组的大小，因为指针没有包含于大小有关的信息。事实上，任何形式的 C++ 数组，不论是不是指针，都没有内涵大小信息。这是应使用现代容器(例如，标准库中提供的容器)的另一个原因：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doubleInts</span><span class="hljs-params">(<span class="hljs-type">int</span>* theArray, <span class="hljs-type">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br> &#123;<br>     theArray[i] *= <span class="hljs-number">2</span>;<br> &#125;<br>&#125;<br><br>等价于：<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doubleInts</span><span class="hljs-params">(<span class="hljs-type">int</span> theArray[], <span class="hljs-type">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; size; i++)<br> &#123;<br>     theArray[i] *= <span class="hljs-number">2</span>;<br> &#125;<br>&#125;<br><br>都代表输入整数数组<br></code></pre></td></tr></table></figure><p><strong>请记住，指针本身就意味着传引用，但传引用不代表着就是指针：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 对于一维数组存在以下三种方式：</span><br><span class="hljs-type">size_t</span> arrSize = <span class="hljs-number">4</span>;<br><span class="hljs-type">int</span>* heapArray = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[arrSize]&#123; <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span> &#125;;<br><span class="hljs-built_in">doublelnts</span>(heapArray, arrSize);<br><span class="hljs-keyword">delete</span> [] heapArray;<br>heapArray = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-type">int</span> stackArray[] = &#123; <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">11</span> &#125;;<br>arrSize = std::<span class="hljs-built_in">size</span>(stackArray); <span class="hljs-comment">// Since C++17, requires &lt;array&gt;</span><br><span class="hljs-comment">// arrSize = sizeof(stackArray) / sizeof(stackArray[0]); // Pre-C++17, see Chi</span><br><span class="hljs-built_in">doublelnts</span>(stackArray, arrSize);<br><span class="hljs-built_in">doublelnts</span>(&amp;stackArray[<span class="hljs-number">0</span>], arrSize);<br><br><span class="hljs-comment">/*在函数原型中，theArray的后面方括号中数字被忽略，原因在于只强调是数组(指针)，其他都不关心。下面的 3 个版本是等价的：*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doublelnts</span><span class="hljs-params">(<span class="hljs-type">int</span>* theArray, <span class="hljs-type">size_t</span> size)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doublelnts</span><span class="hljs-params">(<span class="hljs-type">int</span> theArray[], <span class="hljs-type">size_t</span> size)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doublelnts</span><span class="hljs-params">(<span class="hljs-type">int</span> theArray[<span class="hljs-number">2</span>], <span class="hljs-type">size_t</span> size)</span></span>;<br><span class="hljs-comment">/* 在 C 和 C++ 中，函数参数中的数组声明经常会退化（decay）为指向数组第一个元素的指针，这种退化让人可能一开始很难接收，可是不要这样去想，因为最后一种可能会引起人疑问的用法，只有有毛病的人才会用，完全是无用功，仅此而已*/</span><br></code></pre></td></tr></table></figure><p>其背后机理在于，传入的参数是一个指针(如果传入的是数组，那么就会将其指针化)。</p><p>可“按引用”给函数传递长度已知的基于堆栈的数组，但其语法并不明显。它不适用于基于堆的数组。例如，下面示例中的 doubleIntsStack() 仅接收大小为 4 的基于堆栈的数组：</p><p><strong>引用（Reference）:</strong></p><ul><li>引用是一个别名，一旦引用被初始化，它就一直引用同一个对象。</li><li>引用在声明时必须初始化，之后不能再引用其他对象。</li><li>引用本身没有”重新绑定”的语法，因此无法修改引用指向的对象。</li><li>引用无法直接进行内存管理的操作，如释放内存。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x = <span class="hljs-number">42</span>;<br><span class="hljs-type">int</span>&amp; ref = x; <span class="hljs-comment">// ref 是 x 的引用</span><br></code></pre></td></tr></table></figure><p>在C++中，引用和指针是两种不同的语言特性，它们有着不同的语法和语义。</p><ol><li>引用（Reference）:<ul><li>引用是一个别名，一旦引用被初始化，它就一直引用同一个对象。</li><li>引用在声明时必须初始化，之后不能再引用其他对象。</li><li>引用本身没有”重新绑定”的语法，因此无法修改引用指向的对象。</li><li>引用无法直接进行内存管理的操作，如释放内存。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">cppCopy codeint x = <span class="hljs-number">42</span>;<br><span class="hljs-type">int</span>&amp; ref = x; <span class="hljs-comment">// ref 是 x 的引用</span><br></code></pre></td></tr></table></figure><ol start="2"><li><p>指针（Pointer）:</p><ul><li><p>指针是一个变量，用来存储某个对象的地址。</p></li><li><p>指针可以在初始化后指向不同的对象，可以通过赋值修改指针所指的对象。</p></li><li><p>指针提供了直接的内存管理操作，例如使用 <code>delete</code> 或 <code>free</code> 释放内存。</p></li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span>* ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">42</span>); <span class="hljs-comment">// ptr 是指向动态分配的整数的指针</span><br><span class="hljs-keyword">delete</span> ptr; <span class="hljs-comment">// 释放内存</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 传引用</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doubleIntsStack</span><span class="hljs-params">(<span class="hljs-type">int</span> (&amp;theArray)[<span class="hljs-number">4</span>])</span></span>;<br><span class="hljs-comment">// 传指针</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doubleIntsStack</span><span class="hljs-params">(<span class="hljs-type">int</span> theArray[<span class="hljs-number">4</span>])</span></span>;<br><br><span class="hljs-comment">/*一定有人想知道这两者为啥不一样，我一开始也感觉这不就是一样吗，但是，仔细观察，理解定义就可以知道——传引用意味着一切都不变；传指针则意味着可以透过这个间接层作用于原本位置的元素。是不是这样一说，就很清楚了：前者是作为一个整体传入的；后者是传入一个地址来用于穿透到原始数据位置的*/</span><br><br><span class="hljs-comment">// 传引用</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doubleIntsStack</span><span class="hljs-params">(<span class="hljs-type">int</span> (&amp;theArray)[<span class="hljs-number">4</span>])</span></span>;<br><span class="hljs-comment">/* 至于为什么可以起到限定数组大小的作用：</span><br><span class="hljs-comment">首先看括号内(&amp;theArray)，传入了一个数组的引用；</span><br><span class="hljs-comment">然后限定这个传引用数组的大小为 4；</span><br><span class="hljs-comment">然后这个数组，作为一个整体被视为参数引用式传入；</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 传引用</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doubleIntsStack</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;(theArray[<span class="hljs-number">4</span>]);</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-comment">/* 首先，将(theArray[4])传入，这是将第五个元素引用式传入，后来退化为第五个元素的指针传入；</span></span></span><br><span class="hljs-comment"><span class="hljs-params"><span class="hljs-function">*/</span></span></span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 作为防御性编程的一种保险手段，使用以下方法限定引用式传入数组长度：</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">function</span><span class="hljs-params">(<span class="hljs-type">int</span> (&amp;theArray)[N])</span></span>;<br><span class="hljs-comment">// N 为限定长度</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 模板尝试：</span><br><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-type">size_t</span> N&gt;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doubleIntsStack</span><span class="hljs-params">(<span class="hljs-type">int</span> (&amp;theArray)[N])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>    &#123;<br>        theArray[i] *= <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><hr><h4 id="2-2并非所有指针都是数组"><a href="#2-2并非所有指针都是数组" class="headerlink" title="2.2并非所有指针都是数组"></a>2.2并非所有指针都是数组</h4><blockquote><p>额，没什么说的，就是标题所代表的意思，指针只有确定是有效的才能访问它的值，虽然可以很勉强地理解为数组，但是不要这样做，这样可能会导致 bug.</p><p>警告：</p><p>​通过指针可自动引用数组，但并非所有指针都是数组；</p></blockquote><hr><h3 id="7-3低级内存操作"><a href="#7-3低级内存操作" class="headerlink" title="7.3低级内存操作"></a>7.3低级内存操作</h3><blockquote><p>额，这东西就了解就行，因为啊，C++ 之所以是 C++ 就是不需要像 C 那样考虑那样底层的事情，通过构造和析构从理论来说，内存管理就被隐藏在类中得到极大的可用性的实现。</p></blockquote><hr><h4 id="3-1指针运算"><a href="#3-1指针运算" class="headerlink" title="3.1指针运算"></a>3.1指针运算</h4><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span>* myArray = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">8</span>];<br>myArray[<span class="hljs-number">2</span>] = <span class="hljs-number">33</span>;&lt;===等价于===&gt;*(myArray + <span class="hljs-number">2</span>) = <span class="hljs-number">3</span><br><span class="hljs-comment">// 这一开始似乎很不合理，但是看多，就没啥了</span><br></code></pre></td></tr></table></figure><p>宽字符串将在第 19 章讨论，但此时不必了解其细节。此处只需要了解宽字符串支持 Unicode 字符来扩大表示范围(如表示日语字符串)。wchar_t 类型是字符类型，可容纳此类 Unicode 字符，而且通常比 char(1字节)更大。要告知编译器一个字符串字面量是宽字符串字面量，可加上前缀 L 。假设有以下宽字符串：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* myString = <span class="hljs-string">L&quot;Hello，World&quot;</span>;<br></code></pre></td></tr></table></figure><p>假设还有一个函数，这个函数接收一个宽字符串，然后返回一个新字符串，新字符串是输入字符串的大写版本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">wchar_t</span>* <span class="hljs-title">toCaps</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span>* inString)</span></span>;<br></code></pre></td></tr></table></figure><p>将 myString 传入这个函数，可将 myString 大写化。不过，如果只想大写化 myString 的一部分，可以通过指针运算引用这个字符串后面的一部分。下面的代码给指针加7, 对宽字符串中的 “World” 部分调用 toCaps(),但 wchar_t 通常超过 1 个字节。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">toCaps</span>(myString + <span class="hljs-number">7</span>);<br></code></pre></td></tr></table></figure><p>指针运算的另一个有用应用是减法运算。将一个指针减去另一个同类型的指针，得到的是两个指针之间指针指向的类型的元素个数，而不是两个指针之间字节数的绝对值。</p></blockquote><hr><h4 id="3-2自定义内存管理"><a href="#3-2自定义内存管理" class="headerlink" title="3.2自定义内存管理"></a>3.2自定义内存管理</h4><blockquote><p>在 99%的情况下(有人可能会说在 100%的情况下)，C++中内置的内存分配设施是足够使用的。new 和delete 在后台完成了所有相关工作：分配正确大小的内存块、管理可用的内存区域列表以及释放内存时将内存块释放回可用内存列表。</p><p>资源非常紧张时，或在非常特殊的情况下，例如管理共享内存时，实现自定义的内存管理是一个可行的方案。不必担心，实际没有听起来那样可怕。基本上，自己管理内存通常意味着编写一些分配大块内存，并在需要的情况下使用大块内存中片段的类。 </p><p>为什么这种方法更好？自行管理内存可能减少开销。当使用 new 分配内存时，程序还需要预留少量的空间来记录分配了多少内存。这样，当调用 delete 时，可以释放正确数量的内存。对于大多数对象，这个开销比实际分配的内存小得多，所以差别不大。然而，对于很小的对象或分配了大量对象的程序来说，这个开销的影响可能会很大。</p><p>当自行管理内存时，可事先了解每个对象的大小，因此可避免每个对象的开销。对于大量小对象而言，这个差别可能会很大。第 15 章将讲解自定义内存管理的语法。</p><p>对于上面内容，一句话，扯淡。。。</p></blockquote><hr><h4 id="3-3垃圾回收"><a href="#3-3垃圾回收" class="headerlink" title="3.3垃圾回收"></a>3.3垃圾回收</h4><blockquote><p>看不懂，什么东西，不关心，略过先。</p></blockquote><hr><h4 id="3-4对象池"><a href="#3-4对象池" class="headerlink" title="3.4对象池"></a>3.4对象池</h4><blockquote><p>略过。</p></blockquote><hr><h3 id="7-4智能指针"><a href="#7-4智能指针" class="headerlink" title="7.4智能指针"></a>7.4智能指针</h3><blockquote><blockquote><p>所以，思考智能指针的心理应该被视为 “一个带着编号的房产证”，这样我们就很容易理解所谓“所有权”的问题：</p><ul><li><p>unique_ptr 指针，相当于私有房产的房产证，房产证只限家人有；</p><ul><li><p><strong>创建房产证和房子：auto mySimpleSmartPtr &#x3D; std::make_unique<Simple>();</strong></p></li><li><p><strong>返回房屋的钥匙【房产证依旧有效】：mySimpleSmartPtr.get()</strong></p></li><li><p><strong>拆迁换房：</strong></p><p><strong>mySimpleSmartPtr.reset();mySimpleSmartPtr.reset(new Simple);</strong></p></li><li><p><strong>获取房屋钥匙并且销毁房产证【房产证不再具有法律效益】：mySimpleSmartPtr.release()</strong></p></li><li><p><strong>unique_ptr 代表唯一拥有权</strong></p></li><li><p><strong>房产证转移户主：move(mySimpleSmartPtr)</strong></p></li><li><p><strong>自定义拆迁方法 ：std::unique_ptr&lt;int, decltype(free)*&gt; myIntSmartPtr(malloc_int(), free);</strong></p></li></ul></li><li><p><strong>shared_ptr 指针，相当于公共场所的复数人拥有的房产证，公共的房产证可以相关负责人拥有</strong>；</p><ul><li><p><strong>创建房产证和房子：auto mySimpleSmartPtr &#x3D; std::make_shared<Simple>();</strong></p></li><li><p><strong>返回房屋的钥匙【房产证依旧有效】：mySimpleSmartPtr.get()</strong></p></li><li><p><strong>拆迁换房：</strong></p><p><strong>mySimpleSmartPtr.reset();mySimpleSmartPtr.reset(new Simple);</strong></p></li><li><p><strong>无法 获取房屋钥匙并且销毁房产证【房产证不再具有法律效益】：mySimpleSmartPtr.release()</strong></p></li><li><p><strong>房产证中的所有人数量：mySimpleSmartPtr.use_count()</strong></p></li><li><p><strong>房产证转义户主：move(mySimpleSmartPtr)</strong></p></li><li><p><strong>自定义拆迁方法 ：std::shared_ptr<int> myIntSmartPtr(malloc_int(42), free);</strong></p></li></ul></li></ul></blockquote><p>手动管理动态内存分配缺点：</p><ul><li>指针丢失</li><li>忘记释放内存</li><li>多次释放内存</li></ul><p>智能指针优点：</p><ul><li>避免内存泄漏</li><li>避免多次释放，但是可能会出现循环引用，即两个或多个对象之间相互持有对方的 <code>shared_ptr</code>，导致它们的引用计数永远不会减为零，对象永远不会被销毁的情况</li></ul><p>智能指针特性：</p><ul><li><p>可通过模板为任何指针类型编写类型安全的智能指针类</p></li><li><p>可使用运算重载为智能指针对象提供一个接口，使得智能指针对象的使用和普通指针一样。确切地讲，可重载 * 和 -&gt; 运算符，使得客户代码解除对智能指针对象的引用的方式和解除对普通指针的引用相同。</p></li><li><p>使用类似于 Python 的 “引用计数” 方法来跟踪指针资源的所有者，这样实现对资源的完全利用，以及利用完全后的释放。</p><hr></li><li><p><strong>使用智能指针需要引入 头文件 <memory>.</strong></p></li><li><p><strong>将 unique_ptr 视作默认智能指针，只有真正需要共享资源时再使用 shared_ptr.</strong></p></li><li><p><strong>永远不要把资源分配结果指定给普通指针。永远不要将资源分配结果指定给普通指针。无论使用哪种资源分配方法，都应当立即将资源指针存储在智能指针 unique_ptr 或 shared_ptr 中，或使用其他 RAII 类。</strong>RAII 代表 Resource Acquisition Is Initialization（资源获取即初始化）。 RAII 类获取某个资源的所有权，并在适当的时候进行释放。第 28 章将讨论这种设计技术。</p></li></ul></blockquote><hr><h4 id="4-1unique-ptr"><a href="#4-1unique-ptr" class="headerlink" title="4.1unique_ptr"></a>4.1unique_ptr</h4><blockquote><ol><li><p><strong>创建：auto mySimpleSmartPtr &#x3D; std::make_unique<Simple>();</strong></p></li><li><p><strong>返回裸指针：mySimpleSmartPtr.get()</strong></p></li><li><p><strong>利用 reset() 方法可释放 unique_ptr 的底层指针，并使用 reset() 根据需要将其改为另一个指针：</strong></p><p><strong>mySimpleSmartPtr.reset();mySimpleSmartPtr.reset(new Simple);</strong></p></li><li><p><strong>断开 unique_ptr 和 底层指针的连接：mySimpleSmartPtr.release()</strong></p></li><li><p><strong>unique_ptr 代表唯一拥有权，因此无法复制它！</strong></p></li><li><p><strong>使用 std::move() 方法进行移动语义：move(mySimpleSmartPtr)</strong></p></li><li><p><strong>自定义 deleter ：std::unique_ptr&lt;int, decltype(free)*&gt; myIntSmartPtr(malloc_int(), free);</strong></p></li></ol></blockquote><blockquote><ol><li><p><strong>创建 unique_ptrs</strong></p><p>考虑下面函数，这个函数在堆上分配了一个 Simple 对象，但是不释放这个对象，故意产生内存泄漏：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">leaky</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Simple* mySimplePtr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Simple</span>();<br>    mySimplePtr-&gt;<span class="hljs-built_in">go</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>有时，可能接下来你考虑了要内存释放，可是写出以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">leaky</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Simple* mySimplePtr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Simple</span>();<br>    mySimplePtr-&gt;<span class="hljs-built_in">go</span>();<br>    <span class="hljs-keyword">delete</span> mySimplePtr;<br>&#125;<br></code></pre></td></tr></table></figure><p>在正常情况下，这样的代码当然没什么问题，可是，一旦在调用 go() 方法时，抛出了一个异常，那么将永远不会调用 delete，从而导致了内存泄漏。</p><p>而使用了 unique_ptr 时，会将这两种情况都规避掉：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">leaky</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> mySimpleSmartPtr = std::<span class="hljs-built_in">make_unique</span>&lt;Simple&gt;();<br>    <span class="hljs-comment">// 注意，不使用 std::make_unique&lt;Simple()&gt;(); </span><br>    <span class="hljs-comment">// 注意，将创建好的类当作类型处理</span><br>    <span class="hljs-comment">// 尤其注意：类  &lt;==&gt;  (自定义的)类型   &lt;/=&gt; 构造函数</span><br>    mySimpleSmartPtr-&gt;<span class="hljs-built_in">go</span>();<br>    <span class="hljs-comment">// 或写作 (*mySimpleSmartPtr).go()</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当实例 mySimpleSmartPtr 离开作用域(函数结束或弹出异常)，不需要显式地删除，会自动调用其析构函数进行释放对象；</p><p><strong>这段代码使用 C++14 中的 make_unique()和 auto 关键字，所以只需要指定指针的类型，本例中是 Simple。如果 Simple 构造函数需要参数，就把它们放在 make_unique() 调用的圆括号中。</strong>  </p><p>在 C++ 17 之前，必须使用 make_unique()，一是因为只能将类型指定一次，二是出于安全考虑！考虑下面函数，对 foo() 函数的调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">foo</span>(std::<span class="hljs-built_in">unique_ptr</span>&lt;Simple&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Simple</span>()), std::<span class="hljs-built_in">unique_ptr</span>&lt;Bar&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Bar</span>(<span class="hljs-built_in">data</span>())));<br><br><span class="hljs-comment">/*这种形式的初始化是直接使用 new 运算符创建对象，并将其所有权转交给 std::unique_ptr。如果在这个过程中发生了异常（例如构造函数抛出异常），那么 std::unique_ptr 将无法获取对动态分配内存的控制权，从而导致内存泄漏。*/</span><br></code></pre></td></tr></table></figure><p>由于这种方式容易造成内存泄漏，所以不要使用，不是迫不得已绝对不要用！</p><p><strong>注意：</strong></p><p>​<strong>始终使用 make_unique() 来创建 unique_ptr.</strong></p></li><li><p><strong>使用 unique_ptrs</strong></p><p><strong>NB 之处在于：不用学习多少语法，就能享受很多好处。</strong></p><p><strong>利用 get() 方法可用于直接访问底层指针。</strong>这可将指针传递给需要普通指针的函数。例如，加入具有以下函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">processData</span><span class="hljs-params">(Simple* simple)</span></span>;<br></code></pre></td></tr></table></figure><p>可采用以下方法进行调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> mySimpleSmartPtr = std::<span class="hljs-built_in">make_unique</span>&lt;Simple&gt;();<br><span class="hljs-built_in">processData</span>(mySimpleSmartPtr.<span class="hljs-built_in">get</span>());<br><span class="hljs-comment">/* 为什么这里是 .get() ？</span><br><span class="hljs-comment">我在之前有这样的疑问，但是这样解释——我不是要对 mySimpleSmartPtr 所指对象进行取值运算，也就是 (*mySimpleSmartPtr).get()；而是将 mySimpleSmartPtr 看做一个整体或者说看成一个类，这个类内自带有的方法是将自己的智能指针转化为裸指针的方法 .get()</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><strong>利用 reset() 方法可释放 unique_ptr 的底层指针，并使用 reset() 根据需要将其改为另一个指针。</strong>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Free resourse and set to nullptr</span><br>mySimpleSmartPtr.<span class="hljs-built_in">reset</span>();<br><br><span class="hljs-comment">// Free resourse and set to a new Simple instance</span><br>mySimpleSmartPtr.<span class="hljs-built_in">reset</span>(<span class="hljs-keyword">new</span> Simple);<br></code></pre></td></tr></table></figure><p><strong>利用 release() 方法可断开 unique_ptr 和 底层指针 的连接。</strong> release() 方法返回资源的底层指针，然后将智能指针设置为 nullptr.实际上，智能指针失去对资源的所有权，负责在你用完资源时释放资源。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Release ownership</span><br>Simple* simple = mySimpleSmartPtr.<span class="hljs-built_in">release</span>();<br><br><span class="hljs-comment">// 此时 mySimpleSmartPtr 不再拥有资源的所有权</span><br><span class="hljs-comment">// 需要手动释放资源，否则可能会发生内存泄漏</span><br><span class="hljs-comment">// Use the simple pointer</span><br><span class="hljs-keyword">delete</span> simple;<br>simple = <span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></table></figure><p><strong>利用 std::move() 实现移动语义</strong>，实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Foo</span>(unique_ptr&lt;<span class="hljs-type">int</span>&gt; data<span class="hljs-comment">/*可以在这里设定默认值*/</span>): <span class="hljs-built_in">mData</span>(std::<span class="hljs-built_in">move</span>(data))&#123;&#125;;<br><span class="hljs-keyword">private</span>:<br>    unique_ptr&lt;<span class="hljs-type">int</span>&gt; mData;<br>&#125;;<br><br><span class="hljs-keyword">auto</span> myIntSmartPtr = <span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">42</span>);<br><span class="hljs-function">Foo <span class="hljs-title">f</span><span class="hljs-params">(std::move(myIntSmartPtr))</span></span>;<br><br><span class="hljs-comment">/* 我来复习一下，成员初始化列表执行：首先 auto myIntSmartPtr = make_unique&lt;int&gt;(42); 给了一个被初始化为 42 的整数型智能指针。然后 Foo f(std::move(myIntSmartPtr)); ，也就是说 std::move(myIntSmartPtr) 先被给了 unique_ptr&lt;int&gt; data ，接下来由于成员初始化列表，再把值给 mData(std::move(data)) ，最后赋给 private 中的mData, 然后执行后面的初始化构造程序*/</span><br></code></pre></td></tr></table></figure></li><li><p><strong>unique_ptr 和 C 风格数组</strong></p><p>unique_ptr 适用于存储动态分配的旧式 C 风格数组。下例创建了一个 unique_ptr 来保存动态分配的、包含 10 个整数的 C 风格数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> myVariableSizedArray = <span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>[]]&gt;(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><p>即使可使用 unique_ptr 存储动态分配的 C 风格数组，也建议改用标准库容器，例如 std::array 和 std::vector 等。</p></li><li><p><strong>自定义 deleter</strong></p><p>默认情况下，unique_ptr 使用标准的 new 和 delete 运算符来分配和释放内存。可将此行改为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">malloc_int</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span>* p = (*<span class="hljs-type">int</span>)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>    *p = value;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br>      <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>, <span class="hljs-title">decltype</span><span class="hljs-params">(free)</span>*&gt; <span class="hljs-title">myIntSmartPtr</span><span class="hljs-params">(malloc_int(<span class="hljs-number">42</span>), free)</span></span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>      <br><span class="hljs-comment">// 模板类型参数自定义 deleter：</span><br><span class="hljs-function">std::unique_ptr&lt;T, Deleter&gt; <span class="hljs-title">myPtr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> T, myCustomDeleter)</span></span>;<br><span class="hljs-comment">// T 是智能指针所管理资源的类型。</span><br><span class="hljs-comment">// Deleter 是一个类型，用于指定自定义的 deleter，可以是函数指针、函数对象等。</span><br><span class="hljs-comment">// myCustomDeleter 是一个实例，用于执行实际的资源释放操作。</span><br><span class="hljs-comment">// decltype(free)* 是一个表达式，用于获取 free 函数的类型，然后再声明一个指向该类型的函数指针。</span><br><span class="hljs-comment">// decltype(free): decltype 是一个C++关键字，用于获取一个表达式的类型而不实际计算其值。在这里，decltype(free) 获取了 free 函数的类型。</span><br><span class="hljs-comment">// decltype(free)*: 加上 *，表示声明一个指针，该指针指向 decltype(free) 所获得的函数类型。</span><br><span class="hljs-comment">// 这部分告诉编译器：我们正在声明一个指针，该指针指向 free 函数的类型。</span><br></code></pre></td></tr></table></figure><p>这段代码使用 malloc_int() 给整数分配内存。unique_ptr 调用标准的 free() 函数来释放内存。如前所述，在 C++ 中不应该使用 malloc()，而应该用 new。<strong>然而，unique_ptr 的这项特性时很有用的，因为还可管理其他类型的资源而不仅是内存。例如，当 unique_ptr 离开作用域时，可自动关闭文件或网络套接字以及岐然任何资源。</strong></p><p><strong>自定义 <code>deleter</code> 主要是为了让 <code>std::unique_ptr</code> 能够管理除了内存之外的其他资源，例如文件句柄、数据库连接、网络套接字等。通过使用自定义的 <code>deleter</code> 函数，你可以确保在释放 <code>std::unique_ptr</code> 持有的资源时执行特定的清理操作。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br>      <br><span class="hljs-comment">// 虚拟文件类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">VirtualFile</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">VirtualFile</span>(<span class="hljs-type">const</span> std::string&amp; filename) : <span class="hljs-built_in">filename</span>(filename) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Opening file: &quot;</span> &lt;&lt; filename &lt;&lt; std::endl;<br>    &#125;<br>      <br>    ~<span class="hljs-built_in">VirtualFile</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Closing file: &quot;</span> &lt;&lt; filename &lt;&lt; std::endl;<br>    &#125;<br>      <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; data)</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Writing to file: &quot;</span> &lt;&lt; filename &lt;&lt; std::endl;<br>        <span class="hljs-comment">// 写入操作</span><br>    &#125;<br>      <br><span class="hljs-keyword">private</span>:<br>    std::string filename;<br>&#125;;<br>      <br><span class="hljs-comment">// 自定义 deleter 函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">closeVirtualFile</span><span class="hljs-params">(VirtualFile* file)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (file) <br>    &#123;<br>        <span class="hljs-keyword">delete</span> file;<br>    &#125;<br>&#125;<br>      <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 使用自定义 deleter 的 unique_ptr</span><br>    <span class="hljs-function">std::unique_ptr&lt;VirtualFile, <span class="hljs-title">decltype</span><span class="hljs-params">(&amp;closeVirtualFile)</span>&gt; <span class="hljs-title">filePtr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> VirtualFile(<span class="hljs-string">&quot;example.txt&quot;</span>), &amp;closeVirtualFile)</span></span>;<br>      <br>    <span class="hljs-comment">// 使用文件句柄进行操作</span><br>    filePtr-&gt;<span class="hljs-built_in">write</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>      <br>    <span class="hljs-comment">// unique_ptr 离开作用域时，closeVirtualFile 将被调用</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是，unique_ptr 的自定义 deleter 的语法有些费解。需要将自定义 deleter 的类型指定为模板类型参数。在本例中，decltype(free) 用于返回 free() 类型。模板类型参数应当是函数指针的类型，因此另外附加一个 * ，如 decltype(free)*。使用shared_ptr 的自定义 deleter 就容易多了，下面将讨论这点。</p></li></ol></blockquote><hr><h4 id="4-2shared-ptr"><a href="#4-2shared-ptr" class="headerlink" title="4.2shared_ptr"></a>4.2shared_ptr</h4><blockquote><ol><li><p><strong>创建：auto mySimpleSmartPtr &#x3D; std::make_shared<Simple>();</strong></p></li><li><p><strong>返回裸指针：mySimpleSmartPtr.get()</strong></p></li><li><p><strong>利用 reset() 方法可释放 shared_ptr 的底层指针，并使用 reset() 根据需要将其改为另一个指针：</strong></p><p><strong>mySimpleSmartPtr.reset();mySimpleSmartPtr.reset(new Simple);</strong></p></li><li><p><strong>没有这种断开 shared_ptr 和 底层指针的连接的用法：mySimpleSmartPtr.release()</strong></p></li><li><p><strong>shared_ptr 的引用计数方法：mySimpleSmartPtr.use_count()</strong></p></li><li><p><strong>使用 std::move() 方法进行移动语义：move(mySimpleSmartPtr)</strong></p></li><li><p><strong>自定义 deleter ：std::shared_ptr<int> myIntSmartPtr(malloc_int(42), free);</strong></p></li></ol></blockquote><blockquote><p>shared_ptr 与 unique_ptr 类似。</p><p><strong>.get() 方法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br> std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; sharedPtr = std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">42</span>);<br><br> <span class="hljs-type">int</span>* rawPtr = sharedPtr.<span class="hljs-built_in">get</span>(); <span class="hljs-comment">// 获取裸指针</span><br><br> <span class="hljs-comment">// 使用 rawPtr 操作资源，但要注意生命周期</span><br> <span class="hljs-comment">// 不要对裸指针进行 delete 和 new 操作，这应当由智能指针自动进行，否则可能错误</span><br> std::cout &lt;&lt; <span class="hljs-string">&quot;Value through rawPtr: &quot;</span> &lt;&lt; *rawPtr &lt;&lt; std::endl;<br><br> <span class="hljs-comment">// sharedPtr 离开作用域，资源会被正确释放</span><br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>其余方法略。</strong></p><p><strong>.use_count引用计数获取方法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 实现资源共享</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br> <span class="hljs-comment">// 创建一个 shared_ptr，引用计数为1</span><br> std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptr1 = std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">42</span>);<br> std::cout &lt;&lt; <span class="hljs-string">&quot;ptr1 use count: &quot;</span> &lt;&lt; ptr1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br> <span class="hljs-comment">// 复制构造一个 shared_ptr，引用计数增加为2</span><br> std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptr2 = ptr1;<br> std::cout &lt;&lt; <span class="hljs-string">&quot;ptr1 use count: &quot;</span> &lt;&lt; ptr1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br> std::cout &lt;&lt; <span class="hljs-string">&quot;ptr2 use count: &quot;</span> &lt;&lt; ptr2.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br> <span class="hljs-comment">// 通过拷贝赋值操作符，引用计数继续增加为3</span><br> std::shared_ptr&lt;<span class="hljs-type">int</span>&gt; ptr3;<br> ptr3 = ptr1;<br> std::cout &lt;&lt; <span class="hljs-string">&quot;ptr1 use count: &quot;</span> &lt;&lt; ptr1.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br> std::cout &lt;&lt; <span class="hljs-string">&quot;ptr3 use count: &quot;</span> &lt;&lt; ptr3.<span class="hljs-built_in">use_count</span>() &lt;&lt; std::endl;<br><br> <span class="hljs-comment">// 当 shared_ptr 被销毁时，引用计数减少</span><br> <span class="hljs-comment">// 在 ptr2、ptr3 离开作用域时，引用计数减为1，然后在 ptr1 离开作用域时，引用计数降为0，资源被释放</span><br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>对比不可复制的 unique_ptr:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br> <span class="hljs-comment">// 创建一个 unique_ptr</span><br> std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; uniquePtr1 = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">42</span>);<br><br> <span class="hljs-comment">// 尝试复制，会导致编译错误</span><br> <span class="hljs-comment">// std::unique_ptr&lt;int&gt; uniquePtr2 = uniquePtr1; // 错误！</span><br><br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>自定义 deleter:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// Implementation of malloc_int() as before.</span><br><span class="hljs-function">shared_ptr&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">myIntSmartPtr</span><span class="hljs-params">(malloc_int(<span class="hljs-number">42</span>), free)</span></span>;<br></code></pre></td></tr></table></figure><p>下面示例使用 shared_ptr 存储文件指针。当 shared_ptr 脱离作用域时，会调用 CloseFile() 函数来自动关闭文件指针。回顾一下， C++ 由可操作文件的面向对象的类(详细在第 13 章)。这些类在脱离作用域会自动关闭文件。这个例子使用了旧式 C 语言的 fopen() 和 fclose() 函数，只是为了演示 shared_ptr 除了管理纯粹的内存之外还可以用于其他目的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CloseFile</span><span class="hljs-params">(FILE* filePtr)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">if</span> (filePtr == <span class="hljs-literal">nullptr</span>)<br> &#123;<br>     <span class="hljs-keyword">return</span>;<br> &#125;<br> <span class="hljs-built_in">fclose</span>(filePtr);<br> std::cout &lt;&lt; <span class="hljs-string">&quot;File closed!&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> FILE* f = <span class="hljs-built_in">fopen</span>(<span class="hljs-string">&quot;data.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br> <span class="hljs-function">shared_ptr&lt;FILE&gt; <span class="hljs-title">filePtr</span><span class="hljs-params">(f, CloseFile)</span></span>;<br> <span class="hljs-keyword">if</span> (filePtr = <span class="hljs-literal">nullptr</span>)<br> &#123;<br>     std::cerr &lt;&lt; <span class="hljs-string">&quot;Error opening file.&quot;</span> &lt;&lt; std::endl;<br> &#125;<br> <span class="hljs-keyword">else</span><br> &#123;<br>     std::cout &lt;&lt; <span class="hljs-string">&quot;File opened.&quot;</span> &lt;&lt; std::endl;<br>     <span class="hljs-comment">// Use filePtr</span><br> &#125;<br><br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p><strong>强制类型转化 shared_ptr：</strong><br>可用于强制转换的 shared_ptr 的函数是：</p><ul><li>const_pointer_cast()</li><li>dynamic_pointer_cast()</li><li>static_pointer_cast()</li><li>reinterpret_pointer_cast()</li></ul><p>它们的行为和工作方式类似于非智能指针转换函数:</p><ul><li>const_cast()</li><li>dynamic_cast()</li><li>static_cast()</li><li>reinterpret_cast()</li></ul><p>这里先不讲了，到第 11 章再仔细讨论这些方法。</p></li><li><p><strong>引用计数的必要性：</strong></p><p>作为一般概念，引用计数(reference counting)用于追踪正在使用的某个类的实例或特定对象的个数。引用计数的智能指针跟踪为引用一个真实指针(或某个对象)而建立的智能指针的数目。<strong>通过这种方法，智能指针可以避免双重删除。</strong></p><p>双重删除的问题很容易出现。考虑到前面引入的 Simple 类，这个类只是打印出创建或销毁一个对象的消息。如果要创建两个标准的 shared_ptrs，并将它们都指向同一个 Simple 对象，如下面代码所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 在销毁时，两个智能指针将尝试删除同一个对象</span><br><span class="hljs-comment">// 但是，创建此对象只调用了一次构造函数，但是要调用两次析构函数</span><br><span class="hljs-comment">// 根据编译器，这段代码可能导致崩溃！</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doubleDelete</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Simple* mySimple = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Simple</span>();<br>    <span class="hljs-function">std::shared_ptr&lt;Simple&gt; <span class="hljs-title">smartPtr1</span><span class="hljs-params">(mySimple)</span></span>;<br>    <span class="hljs-function">std::shared_ptr&lt;Simple&gt; <span class="hljs-title">smartPtr2</span><span class="hljs-params">(mySimple)</span></span>;<br>&#125;<br><br><span class="hljs-comment">// 如果没有崩溃，那么输出：</span><br>Simple constructor called！<br>Simple destructor called！<br>Simple destructor called！<br><br><span class="hljs-comment">// 上述情况对于 unique_ptr 也是一样的</span><br><span class="hljs-comment">// 但是 unique_ptr 难以提供出类似于 shared_ptr 的解决方案</span><br><span class="hljs-comment">// 也就是说，它不允许复制，也就不允许复制构造函数的存在</span><br></code></pre></td></tr></table></figure><p>所以，对于这种情况，应当使用:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doubleShare</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 创建一个 shared_ptr 对象，管理动态分配的 Simple 对象</span><br>    std::shared_ptr&lt;Simple&gt; smartPtr1 = std::<span class="hljs-built_in">make_shared</span>&lt;Simple&gt;();<br><br>    <span class="hljs-comment">// 通过拷贝构造函数创建另一个 shared_ptr，共享同一个 Simple 对象的所有权</span><br>    std::shared_ptr&lt;Simple&gt; smartPtr2 = smartPtr1;<br>    <span class="hljs-comment">// 或者使用拷贝构造函数：</span><br>    <span class="hljs-comment">// std::shared_ptr&lt;Simple&gt; smartPtr2(smartPtr1);</span><br>    <span class="hljs-comment">// 两者都是复制 原智能指针</span><br><br>    <span class="hljs-comment">// 在这里，smartPtr1 和 smartPtr2 共享对同一个 Simple 对象的所有权</span><br>    <span class="hljs-comment">// 当它们离开作用域时，将正确地释放 Simple 对象的内存</span><br>&#125;<br><br><span class="hljs-comment">// 输出：</span><br>Simple constructor called!<br>Simple destructor called!<br></code></pre></td></tr></table></figure><p><strong>之前，一直说共享所有权，但可能并不太明确，我在这里给出通常发挥作用的场景：</strong></p><ol><li><p><strong>多个对象需要访问和共享同一块资源：</strong> 如果有多个对象需要使用相同的资源，而不是每个对象都拥有独立的资源副本，那么 <code>shared_ptr</code> 是一种合适的选择。这种情况下，通过增加引用计数，可以确保资源在最后一个持有者释放它时才被销毁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">cppCopy codeclass Resource &#123;<br>    <span class="hljs-comment">// Resource class definition</span><br>&#125;;<br><br>std::shared_ptr&lt;Resource&gt; sharedResource1 = std::<span class="hljs-built_in">make_shared</span>&lt;Resource&gt;();<br>std::shared_ptr&lt;Resource&gt; sharedResource2 = sharedResource1;  <span class="hljs-comment">// 共享所有权</span><br></code></pre></td></tr></table></figure></li><li><p><strong>观察者模式：</strong> 当一个对象（被观察者）的状态变化需要通知多个其他对象（观察者）时，使用 <code>shared_ptr</code> 可以确保观察者不会在被观察者销毁后继续引用它。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 实现更新逻辑</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Observer updated&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> <br>&#123;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;std::shared_ptr&lt;Observer&gt;&gt; observers;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addObserver</span><span class="hljs-params">(std::shared_ptr&lt;Observer&gt; observer)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 添加观察者到列表</span><br>        observers.<span class="hljs-built_in">push_back</span>(observer);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">notifyObservers</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 通知所有观察者</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; observer : observers) <br>        &#123;<br>            observer-&gt;<span class="hljs-built_in">update</span>();<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 创建被观察者对象</span><br>    std::shared_ptr&lt;Subject&gt; subject = std::<span class="hljs-built_in">make_shared</span>&lt;Subject&gt;();<br><br>    <span class="hljs-comment">// 创建观察者对象</span><br>    std::shared_ptr&lt;Observer&gt; observer1 = std::<span class="hljs-built_in">make_shared</span>&lt;Observer&gt;();<br><br>    <span class="hljs-comment">// 共享所有权，observer2和observer1指向相同的对象</span><br>    std::shared_ptr&lt;Observer&gt; observer2 = observer1;  <br><br>    <span class="hljs-comment">// 注册观察者到被观察者</span><br>    subject-&gt;<span class="hljs-built_in">addObserver</span>(observer1);<br>    subject-&gt;<span class="hljs-built_in">addObserver</span>(observer2);<span class="hljs-comment">// 这句话事实上是多余的，因为上面它们是同一个智能指针。</span><br><br>    <span class="hljs-comment">// 通知所有观察者</span><br>    subject-&gt;<span class="hljs-built_in">notifyObservers</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p><strong>复杂资源管理：</strong> 当资源的生命周期不仅仅由一个对象的作用域决定，而是由多个对象协同管理时，<code>shared_ptr</code> 可以确保资源在所有引用都不再需要时才被释放。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++">cppCopy codeclass ComplexResource <br>&#123;<br>    <span class="hljs-comment">// ComplexResource class definition</span><br>&#125;;<br>      <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourceManager</span> <br>&#123;<br><span class="hljs-keyword">private</span>:<br>    std::shared_ptr&lt;ComplexResource&gt; sharedResource;<br>      <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">    </span>&#123;<br>        sharedResource = std::<span class="hljs-built_in">make_shared</span>&lt;ComplexResource&gt;();<br>    &#125;<br>      <br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">useResource</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 使用资源的逻辑</span><br>    &#125;<br>      <br>    <span class="hljs-comment">// 其他复杂的资源管理逻辑</span><br>&#125;;<br>      <br>ResourceManager manager1;<br>ResourceManager manager2 = manager1;  <span class="hljs-comment">// 共享所有权</span><br></code></pre></td></tr></table></figure></li></ol><p>这些场景中，<code>shared_ptr</code> 提供了一种方便且相对安全的方式来处理共享资源的所有权。但请注意，过度使用共享所有权可能导致循环引用，因此需要谨慎设计和管理。在某些情况下，还可以使用 <code>std::weak_ptr</code> 作为 <code>shared_ptr</code> 的辅助，以避免循环引用问题。</p></li><li><p>别名</p><p>shared_ptr 支持所谓的别名。这允许一个 shared_ptr 与另一个 shared_ptr 共享一个指针(拥有的指针)，但指向不同的对象(存储的指针)。例如，这可用于使用一个 shared_ptr 指向一个对象的成员，同时拥有该对象本身，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Foo</span>(<span class="hljs-type">int</span> value) : <span class="hljs-built_in">mData</span>(value) &#123;&#125;<br>    <span class="hljs-type">int</span> mData;<br>&#125;<br>      <br><span class="hljs-keyword">auto</span> foo = <span class="hljs-built_in">make_shared</span>&lt;Foo&gt;(<span class="hljs-number">42</span>);<br><span class="hljs-keyword">auto</span> aliasing = <span class="hljs-built_in">shared_ptr</span>&lt;<span class="hljs-type">int</span>&gt; (foo, &amp;foo-&gt;mData);<br></code></pre></td></tr></table></figure><p>我喜欢 chatGPT 的这种比喻，很好：</p><blockquote><p>当我们说 <code>foo</code> 和 <code>aliasing</code> 共享同一个对象的所有权时，我们可以把这个对象比喻成一个大房子，而 <code>foo</code> 和 <code>aliasing</code> 就是两个不同的人共同拥有这个房子的一种方式。</p><ul><li><code>foo</code> 有一把大钥匙，可以打开这个房子的门，而这个房子是 <code>Foo</code> 类型的。</li><li><code>aliasing</code> 也有一把特殊的钥匙，可以打开同一个房子的门，但是这个钥匙是专门打开房子里某个小房间（<code>mData</code>）的。</li></ul><p>虽然它们都能打开同一个房子，但是它们所关心的部分是不同的。<code>foo</code> 关心整个房子（<code>Foo</code> 对象），而 <code>aliasing</code> 关心房子里的一个小房间（<code>mData</code> 成员）。</p><p>那么，这里的比喻中，“共享同一个对象的所有权”表示这两个人都有权力进入这个房子，而它们所关心的部分不同，一个关心整个房子，另一个关心房子里的一个小房间。</p></blockquote><p>仅当两个 shared_ptr (foo 和 aliasing) 都销毁时，才销毁 Foo 对象；</p><p>“拥有的指针” 用于引用计数；当对指针解引用或调用它的 get() 时，将返回“存储的指针”。存储的指针用于大多数操作，如比较运算符。可以使用 owner_before() 方法 或 std::owner_less 类，基于拥有的指针执行比较。在某些情况下(例如在 std::set 中存储 shared_ptr)，这很有用。第 17 章将详细讨论 set 容器；</p></li></ol></blockquote><hr><h4 id="4-3weak-ptr"><a href="#4-3weak-ptr" class="headerlink" title="4.3weak_ptr"></a>4.3weak_ptr</h4><blockquote><ul><li><p><strong>获取 shared_ptr 的资源所有权，也就是将资源、状态等都可以拿来调用；</strong></p></li><li><p><strong>是一种引用，但是引用时又不造成原指针对象的引用计数增加。当然，引用计数不增加也说明了它不是创建了 shared_ptr 的副本，而是获取的它的引用权限，也仅仅是获取了引用权限，但是是一种弱弱的引用，很暧昧的那种。</strong></p><blockquote><p><strong>上面这句话我想强调一点：获取引用权限，但不获取所有权。</strong></p><p><strong>套在循环链表【拥有头结点】中是说：头节点拥有首元节点，首元结点拥有后继结点，… ，后继节点可以获取头结点的引用权限【进而使用头结点的相关内容】；</strong></p><p><strong>套在树结构上：根有孩子，孩子有它的孩子，… ，孩子可以使用双亲结点的引用权限【进而得到一种探查到双亲的能力】</strong></p><p><strong>这里我们看出，“有一个” 关系的维系指针【间接层】 是 要强于 “能知道” 的维系指针的；</strong></p></blockquote></li><li><p><strong>它跳出作用域时，并不会销毁原本的指针，因为上面都说了没有引用计数增加，也就是说它对原指针是否销毁不产生什么影响。</strong></p></li></ul></blockquote><blockquote><p><strong>在 C++ 中还有一个类与 shared_ptr 模板有关，那就是 weak_ptr。weak_ptr 可包括有 shared_ptr 管理的资源的引用。 weak_ptr 不拥有这个资源，所以不能阻止 shared_ptr 释放资源。weak_ptr 销毁时(例如离开作用域时)，不会销毁它指向的资源；然而，它可以用于判断资源是否已经被关联的 shared_ptr 释放了。weak_ptr 的构造函数要求将一个 shared_ptr 或另一个 weak_ptr 作为参数。为了访问 weak_ptr 中保护的指针，需要将 weak_ptr 转换为 shared_ptr。</strong>这有两种方法：</p><ol><li><strong>使用 weak_ptr 实例的 lock()方法，这个方法返回一个 shared_ptr。</strong>如果同时释放了与 weak_ptr 关联的 shared_ptr, 返回的 shared_ptr 是 nullptr。</li><li><strong>创建一个新的 shared_ptr 实例，将 weak_ptr 作为 shared_ptr 构造函数的参数。</strong>如果释放了与 weak_ptr 关联的 shared_ptr，将抛出 std::bad_weak_ptr 异常。</li></ol><p>下例演示了 weak_ptr 的用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Simple</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Simple</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Simple constructor called!&quot;</span> &lt;&lt; std::endl; &#125;<br>    ~<span class="hljs-built_in">Simple</span>() &#123; std::cout &lt;&lt; <span class="hljs-string">&quot;Simple destructor called.&quot;</span> &lt;&lt; std::endl; &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">useResource</span><span class="hljs-params">(std::weak_ptr&lt;Simple&gt;&amp; weakSimple)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> resource = weakSimple.<span class="hljs-built_in">lock</span>();<br>    <span class="hljs-keyword">if</span> (resource)<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Resource still alive.&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Resource has been freed!&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> sharedSimple = std::<span class="hljs-built_in">make_shared</span>&lt;Simple&gt;();<br>    <span class="hljs-function">std::weak_ptr&lt;Simple&gt; <span class="hljs-title">weakSimple</span><span class="hljs-params">(sharedSimple)</span></span>;<br><br>    <span class="hljs-comment">// Try to use the weak_ptr.</span><br>    <span class="hljs-built_in">useResource</span>(weakSimple);<br><br>    <span class="hljs-comment">// Reset the shared_ptr.</span><br>    <span class="hljs-comment">// Since there is only 1 shared_ptr to the Simple resource, this will</span><br>    <span class="hljs-comment">// free the resource, even though is still a weak_ptr alive.</span><br>    sharedSimple.<span class="hljs-built_in">reset</span>();<br><br>    <span class="hljs-comment">// Try to use the weak_ptr a second time.</span><br>    <span class="hljs-built_in">useResource</span>(weakSimple);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 上述代码的输出为：</span><br>Simple constructor called!<br>Resource still alive.<br>Simple destructor called.<br>Resource has been freed!<br></code></pre></td></tr></table></figure><p><code>std::weak_ptr</code> 在工程实践中有几个重要的用途：</p><ol><li><p><strong>避免循环引用：</strong> 一个常见的问题是循环引用，即两个或多个对象之间相互持有对方的 <code>shared_ptr</code>，导致它们的引用计数永远不会减为零，对象永远不会被销毁。使用 <code>std::weak_ptr</code> 可以打破这种循环引用，避免内存泄漏。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++">cppCopy codeclass Node <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    std::shared_ptr&lt;Node&gt; next;<br>&#125;;<br><br>std::shared_ptr&lt;Node&gt; node1 = std::<span class="hljs-built_in">make_shared</span>&lt;Node&gt;();<br>std::shared_ptr&lt;Node&gt; node2 = std::<span class="hljs-built_in">make_shared</span>&lt;Node&gt;();<br><br>node1-&gt;next = node2;<br>node2-&gt;next = node1;  <span class="hljs-comment">// 循环引用</span><br><br><span class="hljs-comment">// 解决方案：将其中一个改为 weak_ptr</span><br>node1-&gt;next = node2;<br>node2-&gt;next = std::<span class="hljs-built_in">weak_ptr</span>&lt;Node&gt;(node1);  <span class="hljs-comment">// 将其中一个改为 weak_ptr</span><br><br><span class="hljs-number">1.</span>node1 的后继指向 node2；<br><span class="hljs-number">2.</span>node2 的后继指向 node1；<br><span class="hljs-number">3.</span>如果两者均为<br></code></pre></td></tr></table></figure></li><li><p><strong>避免 <code>shared_ptr</code> 所有权影响对象生命周期：</strong> <code>std::weak_ptr</code> 不会增加对象的引用计数，因此它不会影响对象的生命周期。当对象的最后一个 <code>shared_ptr</code> 被释放时，即使有相关的 <code>weak_ptr</code>，对象也会被正确销毁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">cppCopy codestd::shared_ptr&lt;<span class="hljs-type">int</span>&gt; sharedPtr = std::<span class="hljs-built_in">make_shared</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">42</span>);<br>std::weak_ptr&lt;<span class="hljs-type">int</span>&gt; weakPtr = sharedPtr;<br><br>sharedPtr.<span class="hljs-built_in">reset</span>();  <span class="hljs-comment">// 释放最后一个 shared_ptr</span><br><span class="hljs-comment">// 在这里，weakPtr.lock() 会返回一个空的 shared_ptr，因为对象已被销毁</span><br></code></pre></td></tr></table></figure></li><li><p><strong>延迟初始化或加载：</strong> 在某些情况下，对象的创建或加载可能是昂贵的操作。使用 <code>std::weak_ptr</code> 可以实现延迟初始化或加载，只有在需要的时候才创建或加载对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++">cppCopy codeclass ResourceManager <br>&#123;<br><span class="hljs-keyword">private</span>:<br>    std::weak_ptr&lt;Resource&gt; cachedResource;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::shared_ptr&lt;Resource&gt; <span class="hljs-title">getResource</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">    </span>&#123;<br>        std::shared_ptr&lt;Resource&gt; resource = cachedResource.<span class="hljs-built_in">lock</span>();<br>        <span class="hljs-keyword">if</span> (!resource) <br>        &#123;<br>            <span class="hljs-comment">// 如果资源不存在，则创建一个新的</span><br>            resource = std::<span class="hljs-built_in">make_shared</span>&lt;Resource&gt;();<br>            cachedResource = resource;<br>        &#125;<br>        <span class="hljs-keyword">return</span> resource;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p><strong>观察者模式：</strong> 在观察者模式中，通常有一个被观察者和多个观察者。被观察者持有观察者的指针，而观察者持有被观察者的指针。使用 <code>std::weak_ptr</code> 可以避免观察者持有被观察者的强引用，从而防止循环引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++">cppCopy codeclass Observer;<br>      <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addObserver</span><span class="hljs-params">(std::weak_ptr&lt;Observer&gt; observer)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">notifyObservers</span><span class="hljs-params">()</span></span>;<br>&#125;;<br>      <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure><ol start="5"><li>缓存或资源管理：** 在某些情况下，你可能想要对对象的生命周期进行一些控制，但又不希望通过强引用导致对象一直存活。使用 <code>std::weak_ptr</code> 可以在需要时获取一个强引用，而不会影响对象的生命周期。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++">cppCopy codeclass ResourceManager <br>&#123;<br><span class="hljs-keyword">private</span>:<br>    std::weak_ptr&lt;Resource&gt; cachedResource;<br>      <br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::shared_ptr&lt;Resource&gt; <span class="hljs-title">getResource</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">    </span>&#123;<br>        std::shared_ptr&lt;Resource&gt; resource = cachedResource.<span class="hljs-built_in">lock</span>();<br>        <span class="hljs-keyword">if</span> (!resource) <br>        &#123;<br>            <span class="hljs-comment">// 如果资源不存在，则创建一个新的</span><br>            resource = std::<span class="hljs-built_in">make_shared</span>&lt;Resource&gt;();<br>            cachedResource = resource;<br>        &#125;<br>        <span class="hljs-keyword">return</span> resource;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><p>总的来说，<code>std::weak_ptr</code> 用于处理 <code>std::shared_ptr</code> 的循环引用问题，并提供一种不影响对象生命周期的方式来引用对象。</p><p>给出一个数据结构中的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>;<br><br><span class="hljs-comment">// 具体下方的这种用法见下面会有不太全面的解释：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> : <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;TreeNode&gt; <br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-comment">// 这里的双亲结点使用 弱(引用)指针，使得对双亲结点的引用不再计数</span><br>    std::weak_ptr&lt;TreeNode&gt; parent;<br>    std::vector&lt;std::shared_ptr&lt;TreeNode&gt;&gt; children;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">int</span> val) : <span class="hljs-built_in">data</span>(val) &#123;&#125;<br><br>    <span class="hljs-comment">// 设置父节点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setParent</span><span class="hljs-params">(std::shared_ptr&lt;TreeNode&gt; parentNode)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        parent = parentNode;<br>    &#125;<br><br>    <span class="hljs-comment">// 添加子节点</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addChild</span><span class="hljs-params">(std::shared_ptr&lt;TreeNode&gt; childNode)</span> </span><br><span class="hljs-function">    </span>&#123;<br>        children.<span class="hljs-built_in">push_back</span>(childNode);<br>        childNode-&gt;<span class="hljs-built_in">setParent</span>(<span class="hljs-built_in">shared_from_this</span>());<br>    &#125;<br><br>    <span class="hljs-comment">// 获取父节点</span><br>    <span class="hljs-function">std::shared_ptr&lt;TreeNode&gt; <span class="hljs-title">getParent</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> parent.<span class="hljs-built_in">lock</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 获取节点数据</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getData</span><span class="hljs-params">()</span> </span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> data;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取子节点列表</span><br>    <span class="hljs-type">const</span> std::vector&lt;std::shared_ptr&lt;TreeNode&gt;&gt;&amp; <span class="hljs-built_in">getChildren</span>() <span class="hljs-type">const</span> <br>    &#123;<br>        <span class="hljs-keyword">return</span> children;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 创建树形结构</span><br>    <span class="hljs-keyword">auto</span> root = std::<span class="hljs-built_in">make_shared</span>&lt;TreeNode&gt;(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">auto</span> child1 = std::<span class="hljs-built_in">make_shared</span>&lt;TreeNode&gt;(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">auto</span> child2 = std::<span class="hljs-built_in">make_shared</span>&lt;TreeNode&gt;(<span class="hljs-number">3</span>);<br><br>    root-&gt;<span class="hljs-built_in">addChild</span>(child1);<br>    root-&gt;<span class="hljs-built_in">addChild</span>(child2);<br><br>    <span class="hljs-comment">// 上述代码可以用以下代码替代：</span><br>    <span class="hljs-comment">// child1-&gt;setParent(root);</span><br>    <span class="hljs-comment">// child2-&gt;setParent(root);</span><br><br>    <span class="hljs-comment">// 获取子节点的父节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; child : root-&gt;<span class="hljs-built_in">getChildren</span>()) <br>    &#123;<br>        std::shared_ptr&lt;TreeNode&gt; parent = child-&gt;<span class="hljs-built_in">getParent</span>();<br>        <span class="hljs-keyword">if</span> (parent) <br>        &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;子节点 &quot;</span> &lt;&lt; child-&gt;<span class="hljs-built_in">getData</span>() &lt;&lt; <span class="hljs-string">&quot; 的父节点是 &quot;</span> &lt;&lt; parent-&gt;<span class="hljs-built_in">getData</span>() &lt;&lt; std::endl;<br>        &#125; <br>        <span class="hljs-keyword">else</span> <br>        &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;子节点 &quot;</span> &lt;&lt; child-&gt;<span class="hljs-built_in">getData</span>() &lt;&lt; <span class="hljs-string">&quot; 没有父节点。&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><hr><h4 id="4-4移动语义"><a href="#4-4移动语义" class="headerlink" title="4.4移动语义"></a>4.4移动语义</h4><blockquote><p>shared_ptr、unique_ptr 和 weak_ptr 都支持移动语义，使得它们特别高效。第 9 章将详细讲解移动语义，此处不详细叙述。这里只需要了解，从函数返回此类指针也很高效。例如，可编写以下函数 create(),并像在 main() 函数中演示的那样使用这个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Simple</span> &#123;<br> <span class="hljs-comment">// Simple class definition...</span><br>&#125;;<br><br><span class="hljs-function">std::unique_ptr&lt;Simple&gt; <span class="hljs-title">create</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">auto</span> ptr = std::<span class="hljs-built_in">make_unique</span>&lt;Simple&gt;();<br> <span class="hljs-comment">// Do something with ptr...</span><br> <span class="hljs-keyword">return</span> ptr;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-comment">// 对于临时对象的所有权转移不需要 std::move</span><br> std::unique_ptr&lt;Simple&gt; mySmartPtr1 = <span class="hljs-built_in">create</span>();<br> <span class="hljs-keyword">auto</span> mySmartPtr2 = <span class="hljs-built_in">create</span>();<br><br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 区别</span><br><span class="hljs-function">std::unique_ptr&lt;Simple&gt; <span class="hljs-title">create</span><span class="hljs-params">(std::unique_ptr&lt;Simple&gt; ptr)</span> </span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-comment">// 在这里对 ptr 进行一些操作...</span><br> <span class="hljs-keyword">return</span> ptr; <span class="hljs-comment">// 返回 ptr，发生所有权的转移</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> std::unique_ptr&lt;Simple&gt; mySmartPtr1 = std::<span class="hljs-built_in">make_unique</span>&lt;Simple&gt;();<br><br> <span class="hljs-comment">// 传递 mySmartPtr1 给 create 函数，并接收返回值</span><br> std::unique_ptr&lt;Simple&gt; mySmartPtr2 = <span class="hljs-built_in">create</span>(std::<span class="hljs-built_in">move</span>(mySmartPtr1));<br><br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><hr><h4 id="4-5enable-shared-from-this"><a href="#4-5enable-shared-from-this" class="headerlink" title="4.5enable_shared_from_this"></a>4.5enable_shared_from_this</h4><blockquote><p>std::enable_shared_from_this 混入类 允许对象上的方法给自身安全地返回 shared_ptr 或 weak_ptr。第 28 章将讨论混合类，这里先不详述。enable_shared_from_this 混合类给类添加了以下两个方法：</p><ul><li>shared_form_this() : 返回一个 shared_ptr，它共享对象的所有权。</li><li>weak_from_this() : 返回一个 weak_ptr，它跟踪对象的所有权。</li></ul><p>这是一项高级功能，此处不做详述，下面的代码简单地演示了它的用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span> : <span class="hljs-keyword">public</span> std::enable_shared_form_this&lt;Foo&gt;<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::shared_ptr&lt;Foo&gt; <span class="hljs-title">getPointer</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">shared_from_this</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">auto</span> ptr1 = std::<span class="hljs-built_in">make_shared</span>&lt;Foo&gt;();<br>    <span class="hljs-keyword">auto</span> ptr2 = ptr-&gt;<span class="hljs-built_in">getPointer</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，仅当对象的指针已经储存在 shared_ptr 时，才能使用对象上的 shared_from_this()。意思如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> : <span class="hljs-keyword">public</span> std::enable_shared_from_this&lt;MyClass&gt; <br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::shared_ptr&lt;MyClass&gt; <span class="hljs-title">getShared</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">shared_from_this</span>();<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 在栈上创建对象，不由 shared_ptr 管理</span><br>    MyClass myObject;<br><br>    <span class="hljs-comment">// 尝试调用 shared_from_this()，这是不安全的</span><br>    <span class="hljs-comment">// std::shared_ptr&lt;MyClass&gt; sharedPtr = myObject.getShared(); // 这行代码会导致运行时错误</span><br><br>    <span class="hljs-comment">// 在堆上创建对象，由 shared_ptr 管理</span><br>    std::shared_ptr&lt;MyClass&gt; sharedPtr = std::<span class="hljs-built_in">make_shared</span>&lt;MyClass&gt;();<br>    <span class="hljs-comment">// 写成下面的方式更好：</span><br>    <span class="hljs-comment">// auto sharedPtr = std::make_shared&lt;MyClass&gt;();</span><br><br>    <span class="hljs-comment">// 调用 shared_from_this()，这是安全的</span><br>    std::shared_ptr&lt;MyClass&gt; sharedPtr2 = sharedPtr-&gt;<span class="hljs-built_in">getShared</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这就让我们有了一个疑问为什么要大费周章地使用 enable_shared_from_this?一定很令人疑惑吧？因为貌似我们可以复写上面的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">shared_ptr&lt;Foo&gt; <span class="hljs-title">getPointer</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">shared_ptr</span>&lt;Foo&gt;(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    MyClass myObject;<br>    <span class="hljs-keyword">auto</span> sharedPtr = std::<span class="hljs-built_in">make_shared</span>&lt;MyClass&gt;();<br><br>    std::shared_ptr&lt;MyClass&gt; sharedPtr2 = sharedPtr-&gt;<span class="hljs-built_in">getShared</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 这样写貌似才是一种自然的写法，但是注意：我们在之前说过的重复删除错误</span><br><span class="hljs-comment">// 为了提醒，我把那段代码再贴过来：</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doubleDelete</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    Simple* mySimple = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Simple</span>();<br>    <span class="hljs-function">std::shared_ptr&lt;Simple&gt; <span class="hljs-title">smartPtr1</span><span class="hljs-params">(mySimple)</span></span>;<br>    <span class="hljs-function">std::shared_ptr&lt;Simple&gt; <span class="hljs-title">smartPtr2</span><span class="hljs-params">(mySimple)</span></span>;<br>&#125;<br><span class="hljs-comment">// 这样我们可以看出 Foo 类内成员函数 getPointer() 返回的是一个临时的 shared_ptr&lt;Foo&gt;，它使用传递给构造函数的裸指针（this）来创建一个 shared_ptr，我们就遇到了双重析构问题。</span><br><span class="hljs-comment">// 有两个完全独立的 shared_ptr(ptrl 和 ptr2)指向同 一对象，在超出作用域时，它们都会尝试删除该对象。</span><br><span class="hljs-comment">// 所以，使用 enable_shared_from_this 的里有就有了，用于返回一个临时的原智能指针副本，而不是一个单纯的临时智能指针。</span><br></code></pre></td></tr></table></figure></blockquote><hr><h4 id="4-6旧的、过时的-取消的-auto-ptr"><a href="#4-6旧的、过时的-取消的-auto-ptr" class="headerlink" title="4.6旧的、过时的&#x2F;取消的 auto_ptr"></a>4.6旧的、过时的&#x2F;取消的 auto_ptr</h4><blockquote><p>知道有这疙瘩事，就行了。</p><p>没犯病的话，别用。</p></blockquote><hr><h3 id="7-5常见的内存陷阱"><a href="#7-5常见的内存陷阱" class="headerlink" title="7.5常见的内存陷阱"></a>7.5常见的内存陷阱</h3><blockquote><p>一句话，错误往往很微妙，但有常见类型的问题是可以检测和解决的。</p></blockquote><hr><h4 id="5-1分配不足的字符串"><a href="#5-1分配不足的字符串" class="headerlink" title="5.1分配不足的字符串"></a>5.1分配不足的字符串</h4><blockquote><p>与 C 风格字符串相关的最常见问题是分配不足。大多数情况下，都是因为程序员没有分配尾部的’(T终止字符。当程序员假设某个固定的最大大小时，也会发生字符串分配不足的情况。基本的内置 C 风格字符串函数不会针对固定的大小操作一而是有多少写多少，如果超出字符串的末尾，就写入未分配的内存。  </p><p>以下代码演示了字符串分配不足的情况。它从网络连接读取数据，然后写入一个 C 风格的字符串。这个过程在一个循环中完成，因为网络连接一次只接收少量的数据。在每个循环中调用 getMoreData()。函数，这个函数返回一个指向动态分配内存的指针。当 getMoreData() 返回 nullptr 时，表示己收到所有数据。strcat() 是一个C 函数，它把第二个参数的C 风格字符串连接到第一个参数的 C 风格字符串的尾部。它要求目标缓存区足够大。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> buffer[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// Allocate a whole bunch of memory.</span><br><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) <br>&#123;<br><span class="hljs-type">char</span>* nextChunk = <span class="hljs-built_in">getMoreData</span>();<br><span class="hljs-keyword">if</span> (nextChunk == <span class="hljs-literal">nullptr</span>) <br>&#123;<br><span class="hljs-keyword">break</span>;<br>&#125; <br> <span class="hljs-keyword">else</span> <br> &#123;<br><span class="hljs-built_in">strcat</span>(buffer, nextChunk); <span class="hljs-comment">// BUG! No guarantees against buffer overrun!</span><br><span class="hljs-keyword">delete</span> [] nextChunk;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有三种方法解决这个问题，按优解级排序：</p><ul><li>使用 string；</li><li>使用动态的堆存储追加长度；</li><li>创建另一个版本的 getMoreData()，这个版本接收一个最大计数值(包括 ‘\0’ 字符)，返回的字符不多于这个值；然后跟踪剩余的空间数以及缓冲区中当前的位置；</li></ul></blockquote><hr><h4 id="5-2访问内存越界"><a href="#5-2访问内存越界" class="headerlink" title="5.2访问内存越界"></a>5.2访问内存越界</h4><blockquote><p>本章前面提到，指针只不过是一个内存地址，因此指针可能指向内存中的任何一个位置。这种情况很容易出现。例如，考虑一个 C 风格的字符串，它不小心丢失了 (V终止字符。下面这个函数试图将字符串填满 m 字符，但实际上可能会继续在字符串后面填充 m：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fillWithM</span><span class="hljs-params">(<span class="hljs-type">char</span>* inStr)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (inStr[i] != <span class="hljs-string">&#x27;\0&#x27;</span>) <br> &#123;<br>inStr[i] = <span class="hljs-string">&#x27;m&#x27;</span>;<br>i++；<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：如果把不正确的终止字符串传入这个函数，那么内存的重要部分被改写而导致程序崩溃只是时间问题。考虑到如果程序中与对象关联的内存突然被 m 改写那么会发生什么？这很糟糕！！！</strong></p><p><strong>写入数组尾部的内存而产生的 bug 被称为 缓冲区溢出错误。这种 bug 已经被一些高危的恶意程序使用，例如病毒和蠕虫。狡猾的黑客可利用改写部分内存的能力，来将代码注入正在运行的程序中。【我们看到它也不完全是废物，也可以用于别的地方】</strong></p><p><strong>许多内存检测工具也能检测缓存区溢出。使用像 C++ string 和 vector 这样的高级结构有助于避免产生一些和 C 风格字符串和数组相关的 bug.</strong></p><p><strong>其实就一句话，用 string 和 vector。</strong></p></blockquote><hr><h4 id="5-3内存泄漏"><a href="#5-3内存泄漏" class="headerlink" title="5.3内存泄漏"></a>5.3内存泄漏</h4><blockquote><p><strong>C 和 C++ 编程中遇到的另一个令人沮丧的问题是找到和修复内存泄漏。</strong>程序终于开始工作，看上去能给出正确结果。然后，随着程序的运行，吞掉的内存越来越多。这是因为程序有内存泄漏。<strong>通过智能指针避免内存泄漏是解决这个问题的首选方法。</strong></p><p>分配了内存，但没有释放，就会发生内存泄漏。起初，这听上来好像是粗心编程的结果，应该很容易避免。毕竟，如果在编写的每个类中，每个 new 都对应一个 delete，那么应该不会出现内存泄漏，对不对？实际上，绝对不会这样简单啊！在下面的代码中，Simple 类编写正确，释放了每一处分配的内存。</p><p>当调用 doSomething() 函数时，outSimplePtr 指针修改为指向另一个 Simple 对象，但是没有释放原来 Simple 对象。为演示内存泄漏，doSomething() 函数故意没有删除旧的对象。一旦失去对象的指针，就几乎不可能删除它了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Simple</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br> <span class="hljs-built_in">Simple</span>() &#123; mIntPtr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;&#125;<br> ~<span class="hljs-built_in">Simple</span>() &#123; <span class="hljs-keyword">delete</span> mIntPtr;&#125;<br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123; *mIntPtr = value;&#125;<br><br><span class="hljs-keyword">private</span>:<br> <span class="hljs-type">int</span>* mIntPtr;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomthing</span><span class="hljs-params">(Simple*&amp; outSimplePtr)</span></span><br><span class="hljs-function"></span>&#123;<br> outSimplePtr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Simple</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-comment">// Allocate a Simple object.</span><br> Simple* simplePtr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Simple</span>();<br> <span class="hljs-built_in">dosomething</span>(simplePtr);<br> <span class="hljs-comment">// Only Clean up the second object.</span><br> <span class="hljs-keyword">delete</span> simplePtr;<br><br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>警告：</p><p>​记住，上述代码仅用于演示！在生产环境的代码中，应当使 mIntPtr 和 simplePtr 成为 unique_ptr，使 outSimplePtr 成为 unique_ptr 的引用。如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Simple</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br> <span class="hljs-built_in">Simple</span>() &#123; mIntPtr = std::<span class="hljs-built_in">make_unique</span>&lt;<span class="hljs-type">int</span>&gt;();&#125;<br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123; *mIntPtr = value;&#125;<br><br><span class="hljs-keyword">private</span>:<br> std::unique_ptr&lt;<span class="hljs-type">int</span>&gt; mIntPtr;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doSomething</span><span class="hljs-params">(std::unique_ptr&lt;Simple&gt;&amp; outSimplePtr)</span></span><br><span class="hljs-function"></span>&#123;<br> outSimplePtr = std::<span class="hljs-built_in">make_unique</span>&lt;Simple&gt;();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">auto</span> simplePtr = std::<span class="hljs-built_in">make_unique</span>&lt;Simple&gt;();<br> <span class="hljs-built_in">doSomthing</span>(simplePtr);<br><br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上例中的内存泄漏可能来自程序员之间的沟通不畅或糟糕的代码文档。 doSomething() 的调用者可能没有意识到该变量是通过传引用的，因此，没有理由期望该指针会重新赋值。如果他们没有注意到这个参数是一个指针的非 const 引用，就可能怀疑会发生奇怪的事情，但是 doSomething() 周围并没有说明这个行为的注释。</p><p>暂时略过 MFC 部分，之后专门学。</p></blockquote><hr><h4 id="5-4双重删除和无效指针"><a href="#5-4双重删除和无效指针" class="headerlink" title="5.4双重删除和无效指针"></a>5.4双重删除和无效指针</h4><blockquote><p><strong>通过 delete 释放某个指针关联的内存时，这个内存就可以被其他程序使用了。然而，无法禁止再次使用这个指针，这个指针就成为了悬空指针(dangling pointer)。双重释放也是如此，由于可能已被分配另一对象内存，所以可能会被删掉，崩溃。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">createInt</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-type">int</span>* ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">42</span>);<br> <span class="hljs-keyword">return</span> ptr;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-type">int</span>* myPointer = <span class="hljs-built_in">createInt</span>();  <span class="hljs-comment">// 创建一个动态分配的整数，并将其地址赋给指针</span><br><br> <span class="hljs-comment">// 假设在某个时刻释放了指针所指向的内存</span><br> <span class="hljs-keyword">delete</span> myPointer;<br><br> <span class="hljs-comment">// 在这之后，myPointer成为悬空指针，因为它仍然包含已释放的内存地址</span><br><br> <span class="hljs-comment">// 错误的使用悬空指针</span><br> std::cout &lt;&lt; *myPointer &lt;&lt; std::endl;  <span class="hljs-comment">// 这里可能导致未定义行为</span><br> <span class="hljs-comment">// 错误双重释放</span><br> <span class="hljs-comment">// delete myPointer;</span><br><br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>双重删除和使用已释放的内存都是很难追查的问题，因为症状可能不会立即显现。如果双重删除在较短的时间内发生，程序可能产生未定义的行为，因为关联的内存可能不会那么快重用。同样，如果删除的对象在删除后立即使用，这个对象很有可能仍然完好无缺。</p><p>当然，无法保证这种行为会继续出现。一旦删除对象，内存分配器就没有义务保存任何对象。即使程序能正常工作，使用已删除的对象也是极糟糕的编程风格。  </p><p>多内存泄漏检测程序(例如 Visual C++和 Valgrind), 也会检测双重删除和已释放对象的使用。  </p><p>如果不按推荐的方式使用智能指针而是使用普通指针，至少在释放指针关联的内存后，将指针设置为nullptro 这样能防止不小心两次删除同一个指针和使用无效的指针。注意，在 nullptr 指针上调用 delete 是允许的，只是这样没有任何效果。</p></blockquote><hr><h3 id="7-6本章小节"><a href="#7-6本章小节" class="headerlink" title="7.6本章小节"></a>7.6本章小节</h3><blockquote><p>总结起来：</p><ul><li>引入 <memory>，用 智能指针；</li><li>引入 <string>，用 string；</li><li>引入 <vector>，用 vector；</li></ul></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 复习教程第一章（C++ 和标准库速成）</title>
    <link href="/2024/03/14/C++%20%E5%A4%8D%E4%B9%A0%E6%95%99%E7%A8%8B%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%88%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%89/"/>
    <url>/2024/03/14/C++%20%E5%A4%8D%E4%B9%A0%E6%95%99%E7%A8%8B%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%88%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="C-高级编程"><a href="#C-高级编程" class="headerlink" title="C++ 高级编程"></a><em><strong>C++ 高级编程</strong></em></h1><hr><p>如果只想学习高级方法，那么就请看第 9 章的零规则，就可以知道，前面的努力很大程度上都只是在为了迁就一些较为落后的代码语法。前面的很重要但不必要！！！</p><p>2.7 和 8.1 &#x2F; 3 的区别，记住比较两个浮点数的大小仅关注极小误差量！！！</p><h2 id="第1章-——-C-和标准库速成"><a href="#第1章-——-C-和标准库速成" class="headerlink" title="第1章 —— C++ 和标准库速成"></a><strong>第1章 —— C++ 和标准库速成</strong></h2><hr><h3 id="1-1C-基础知识"><a href="#1-1C-基础知识" class="headerlink" title="1.1C++ 基础知识"></a><strong>1.1C++ 基础知识</strong></h3><hr><h4 id="1-1小程序-“hello-world”"><a href="#1-1小程序-“hello-world”" class="headerlink" title="1.1小程序 “hello world”"></a><strong>1.1小程序 “hello world”</strong></h4><hr><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// helloworld.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Hello, World!&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="1-注释"><a href="#1-注释" class="headerlink" title="1.注释"></a>1.注释</h5><blockquote><ul><li>单行注释，使用    <strong>&#x2F;&#x2F;</strong>    符；</li><li>多行注释，使用    <strong>&#x2F;*    *&#x2F;</strong>    符；</li></ul></blockquote><hr><h5 id="2-预处理指令"><a href="#2-预处理指令" class="headerlink" title="2.预处理指令"></a>2.预处理指令</h5><blockquote><ul><li><p>生成一个 C++ 程序共有三步：</p><blockquote><ul><li><p>首先，代码在预处理器中运行，预处理器会识别代码中的 <em><em>元信息</em>(meta-information)</em>**;</p></li><li><p>其次，代码被编译或转换为计算机可识别的目标文件；</p></li><li><p>最后，独立的目标文件被连接在一起变成一个目标文件；</p></li></ul></blockquote></li><li><p>预处理指令以    <strong>#</strong>    字符开始；</p></li><li><p><strong>include</strong> 指令告诉预处理器：提取    <strong><code>&lt;iostream&gt;</code></strong>    头文件中的所有内容并提供给当前文件；</p><blockquote><ul><li>头文件，最常见的用途是定义在其他位置的函数，<strong>函数声明</strong>会通知编译器如何调用这个函数，并声明函数中参数的个数和类型，以及函数的返回类型。而函数定义包含这个函数的实际代码；</li><li>在 C++ 中，<strong>声明</strong>通常放在扩展名为    <strong><code>.h</code></strong>    的文件中，称为头文件；</li><li>在 C++ 中，<strong>定义</strong>通常包含在扩展名为    <strong><code>.cpp</code></strong>    的文件中，称为源文件；</li><li><strong><code>&lt;iostream&gt;</code></strong>    头文件声明了 C++ 如何提供输入输出机制，如果程序没有包含这个头文件，甚至无法执行器仅需要完成的输入输出文本；</li></ul></blockquote></li><li><p>注意：</p><blockquote><ul><li><p>在 C 中，标准库头文件以    <strong><code>.h</code></strong>    结尾，如    <strong><code>&lt;stdio.h&gt;</code></strong>    ，不使用名称空间；</p></li><li><p>在 C++ 中，标准库头文件以    <strong><code>.h</code></strong>    结尾，如    <strong><code>&lt;iostream&gt;</code></strong>    ,所有文件都在 <strong><code>std</code></strong> 名称空间和 <strong><code>std</code></strong> 的子名称空间中定义；</p></li><li><p>C 中的标准库头文件在 C++ 中依然存在，但是使用以下两个版本：</p><ol><li><p>不使用    <strong><code>.h</code></strong>    后缀，改用前缀    **<code>c</code>**；</p><blockquote><p>这是新版本，也是推荐使用的版本。这些版本将一切放在     <strong><code>std</code></strong>    名称空间中，如    **<code>&lt;cstdio&gt;</code>**；</p></blockquote></li><li><p>使用    <strong><code>.h</code></strong>    后缀；</p><blockquote><p>这是旧版本，这些版本不使用名称空间，如    **<code>&lt;stdio.h&gt;</code>**；</p></blockquote></li></ol></li></ul></blockquote></li><li><p>常见预处理指令</p><blockquote><ul><li><pre><code class="C++">#include [filename]// 将指定的文件插入代码指令虽在的位置；// 几乎总是用来包含头文件，是代码可使用在其他位置定义的功能；<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><br><span class="hljs-selector-tag">-</span> ```<span class="hljs-selector-tag">c</span>++<br>  <span class="hljs-selector-id">#define</span> <span class="hljs-selector-attr">[key]</span> <span class="hljs-selector-attr">[value]</span><br>  <span class="hljs-comment">// 每个指定的 key 都被替换为指定的 value；</span><br>  <span class="hljs-comment">// 在 C 中，常用来定义常数值或宏；</span><br>  <span class="hljs-comment">// 在 C++ 中，提供了常数和大多数宏类型的更好机制，此外，宏的使用具有一定风险，故谨慎使用；</span><br></code></pre></td></tr></table></figure></code></pre></li><li><pre><code class="c++">#ifdef [key]#endif      #ifndef [key]#endif// ifdef(&quot;if defined&quot;) 块或 ifndef(&quot;if not defined&quot;) 块中的代码被有条件地包含或者舍弃；// 上述保留或舍弃取决于是否使用 #define 定义了指令的 key；<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><br>- ```C++<br>  pragma [<span class="hljs-built_in">xyz</span>]<br>  <span class="hljs-comment">// xyz 因编译器而异；</span><br>  <span class="hljs-comment">// 如果在预处理期间执行到这一指令通常会显示一条警告或错误信息；</span><br></code></pre></td></tr></table></figure></code></pre></li><li><p>下面是使用预处理指令避免重复包含的示例：</p><ul><li><pre><code class="c++">#ifndef MYHEADER_H#define MYHEADER_H// ... the contents of this header file#endif<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>- ```c++<br>  <span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br>  <span class="hljs-comment">// ... the contents of this header file</span><br></code></pre></td></tr></table></figure></code></pre></li><li><p>上述两段代码起到的效果相同；</p></li></ul></li></ul></blockquote></li></ul></blockquote><hr><h5 id="3-main-函数"><a href="#3-main-函数" class="headerlink" title="3.main() 函数"></a><strong>3.main()</strong> 函数</h5><blockquote><ul><li><p>main()    函数是程序的入口。</p></li><li><p>main()    函数返回一个    int    值以指示程序的最终执行状态。</p></li><li><p>main()    函数中，可忽略显式的    <strong><code>return</code></strong>    语句，此时，会自动返回    0；</p></li><li><p>main()    函数只有两种参数设置：</p><ol><li><pre><code class="c++">int main()<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-number">2.</span> ```c++<br>   <span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span><br></code></pre></td></tr></table></figure>&gt; **`argc`**    给出了传递给程序的实参数目，**`argv`**    包含了这些参数；&gt;&gt; 注意：&gt;&gt; ​**`argv[0]`**    可能是程序的名称，也可能是空字符串，但不应依赖它，相反，应当使用特定于平台的功能来检索程序名。重要是记住，实际参数从索引    1    开始；</code></pre></li></ol></li></ul></blockquote><hr><h5 id="4-输入输出流"><a href="#4-输入输出流" class="headerlink" title="4.输入输出流"></a>4.输入输出流</h5><blockquote><p>可以将输出流想象为针对数据的*<em>洗衣滑槽</em>(chute)***；</p><blockquote><p>放入其中的任何内容都可以被正确地输出</p></blockquote><ol><li><p><strong><code>std::cout</code></strong> </p><blockquote><p>对应用户控制台或标准输出的滑槽；</p><p>&lt;&lt;用于将信息放入滑槽中；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;There are &quot;</span> &lt;&lt; <span class="hljs-number">219</span> &lt;&lt; <span class="hljs-string">&quot; ways.&quot;</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><p><strong><code>std::cerr</code></strong></p><blockquote><p>对应输出错误信息的滑槽；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cerr &lt;&lt; <span class="hljs-string">&quot;Not right!&quot;</span>;<br><span class="hljs-comment">// 用于对错误信息的输出；</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><p><strong><code>std::endl</code></strong></p><blockquote><p>用于表示序列的结尾，相当于 \n</p><p>此外常见的转义字符有：</p><p>​\n换行</p><p>​\r回车</p><p>​\t制表符</p><p>​\\反斜杠字符</p><p>​\&quot;引号</p></blockquote></li><li><p><strong><code>std::cin</code></strong></p><blockquote><p>用于接收用户的输入，最简单的方法就是在输入流中使用    &gt;&gt;    运算符；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> value;<br>std::cin &gt;&gt; value;<br><span class="hljs-comment">// 由于永远不知道用户会输入什么类型的数据，因此需慎重对待用户的输入；</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><p>​在 C 中使用的    printf()    和    scanf()    未提供类型安全，虽然，在 C++ 中仍然使用    printf()，但，仍建议改用流库，更安全；</p></blockquote></li></ol></blockquote><hr><h4 id="1-2名称空间"><a href="#1-2名称空间" class="headerlink" title="1.2名称空间"></a><strong>1.2名称空间</strong></h4><hr><h5 id="1-名称空间"><a href="#1-名称空间" class="headerlink" title="1.名称空间"></a>1.名称空间</h5><p>​名称空间，用于处理不同代码之间的名称冲突问题；</p><blockquote><p>例如，用户自己编辑了一段代码，其中有一个名为    foo()    的函数，但是，有一天，用户决定使用第三方库中，其中也有一个函数名为    foo()，这时编辑器无法自行判断你的代码要使用哪个版本的的    foo()    函数，库名称无法改变，而改变自己代码中函数名称又十分麻烦；</p><p>上述情况，可以使用名称空间来解决，使用名称空间来指定定义名称的环境，为某段代码加入名称空间可使用    namespace    块将其包含其中。例如，可在    namespaces.h    声明函数示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// namespace.h</span><br><span class="hljs-keyword">namespace</span> mycode<br>&#123;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-comment">// 可以看到，这里的 mycode 实际上是 namespace 类的一个实例化</span><br></code></pre></td></tr></table></figure><p>在名称空间中还可以实现方法或函数，例如，foo()    函数可在    namespaces.cpp    中实现，下给出示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// namespaces.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;namespaces.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mycode::foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;foo() named in the mycode namespace.&quot;</span> &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>或者：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;namespaces.h&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> mycode<br>&#123;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;foo() called in the mycode namespace.&quot;</span> &lt;&lt; std::endl;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样，就能够将用户书写的    foo()    函数与第三方库的    foo()    函数区分，使用以下调用方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">mycode::<span class="hljs-built_in">foo</span>();<br><span class="hljs-comment">// 其中，    ::    符称为作用域解析运算符；</span><br><span class="hljs-comment">// mycode    名称空间中的任何代码都可以调用该名称空间中的其他代码，而不需要显式地说明该名称空间；</span><br><br><span class="hljs-comment">// 如果出现名称空间过长的情况，可使用以下方法：</span><br><span class="hljs-keyword">namespace</span> mynamespace = namespace_top::namespace_middle::naespace_bottom;<br>mynamespaces::<span class="hljs-built_in">foo</span>();<br><span class="hljs-comment">// 即，使用同名来化简</span><br></code></pre></td></tr></table></figure></blockquote><hr><h5 id="2-using-指令："><a href="#2-using-指令：" class="headerlink" title="2.using    指令："></a><strong>2.<code>using</code></strong>    指令：</h5><blockquote><ul><li><p>可以避免预先指明命名空间，使得代码清晰并且易于阅读；</p></li><li><p>该指令通知编译器，后面的代码将使用指定名称空间中的名称；</p><blockquote><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;namespaces.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> mycode</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">foo</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然，一个源文件中可以包含多条    <strong><code>using</code></strong>    指令，但是这种方法虽然便捷，但是注意不要过度使用！</p><p><strong>注意：</strong></p><p>​<strong>极端情况下，如果你使用了已知的所有名称空间，实际上，就是完全取消了名称空间；</strong></p><p>​<strong>如果使用了两个同名的名称空间，将再次出现名称冲突问题；</strong></p><p>​<strong>此外，应当知晓每段代码在哪个名称空间中运行，这样就不会无意中调用错误版本的函数；</strong></p></blockquote></li><li><p><strong>注意：切勿在头文件中使用    <code>using</code>    指令或    <code>using</code>    声明！</strong></p></li></ul></blockquote><h6 id="1-头文件中使用可能导致的问题"><a href="#1-头文件中使用可能导致的问题" class="headerlink" title="1.头文件中使用可能导致的问题"></a>1.头文件中使用可能导致的问题</h6><blockquote><blockquote><ol><li><p><strong>不允许在头文件中使用    <code>using</code>    指令，否则，可能会出现引入头文件的源文件中的全局命名空间被改变，从而可能引发命名冲突。</strong></p><blockquote><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 在头文件中避免这样的使用</span><br><span class="hljs-comment">// project_1.h</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">// 可能会出现引入头文件的源文件中的全局命名空间被改变，从而可能引发命名冲突</span><br></code></pre></td></tr></table></figure></blockquote></li><li><p><strong>使用    <code>using</code>    声明引入头文件的源文件中的特定名称，作用于每个引入文件，同样可能也会导致命名冲突。</strong></p><blockquote><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 在头文件中避免这样的使用</span><br><span class="hljs-comment">// project_1.h</span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-comment">// 作用于每个引入文件，同样可能也会导致命名冲突</span><br></code></pre></td></tr></table></figure></blockquote></li></ol></blockquote></blockquote><h6 id="2-解决方案："><a href="#2-解决方案：" class="headerlink" title="2.解决方案："></a><strong>2.解决方案：</strong></h6><ol><li><p><em>使用权限定名称</em>*</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 全限定名称示例</span><br><br>namespace_name::entity_name<br><span class="hljs-comment">// 即，在每次声明和定义函数的时候，都指明其命名空间</span><br></code></pre></td></tr></table></figure></blockquote></li><li><p><strong>在头文件中使用命名空间别名</strong></p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// example.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> EXAMPLE_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXAMPLE_H</span><br><br><span class="hljs-keyword">namespace</span> mynamespace <br>&#123;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunction</span><span class="hljs-params">()</span></span>;  <br><span class="hljs-comment">// 使用命名空间别名</span><br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> </span><br></code></pre></td></tr></table></figure></blockquote></li><li><p><strong>限制使用 using 的范围</strong></p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// example.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> EXAMPLE_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EXAMPLE_H</span><br><br><span class="hljs-keyword">namespace</span> mynamespace <br>&#123;<br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-comment">// 在特定的命名空间中使用using</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myFunction</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> </span><br></code></pre></td></tr></table></figure></blockquote></li></ol><h4 id="1-3字面量"><a href="#1-3字面量" class="headerlink" title="1.3字面量"></a><strong>1.3字面量</strong></h4><h5 id="1-字面量"><a href="#1-字面量" class="headerlink" title="1.字面量"></a>1.字面量</h5><p>字面量用于在代码中编写数字或字符串。C++ 支持大量标准字面量，可以使用以下字面量表示指定数字(列出的示例都表示数字 123)：</p><blockquote><ul><li>十进制字面量123</li><li>八进制字面量0173</li><li>十六进制字面量0x7B</li><li>二进制字面量0b1111011</li></ul></blockquote><h5 id="2-其他字面量："><a href="#2-其他字面量：" class="headerlink" title="2.其他字面量："></a>2.其他字面量：</h5><blockquote><ul><li>浮点值如：3.14f</li><li>双精度浮点值如：3.14</li><li>单个字符如：’a’</li><li>以零结尾的字符数组如：”character array”</li></ul></blockquote><h5 id="3-自定义自变量类型"><a href="#3-自定义自变量类型" class="headerlink" title="3.自定义自变量类型"></a>3.自定义自变量类型</h5><blockquote><p>自定义自变量类型，这是一种高级功能；</p></blockquote><h5 id="4-数字分隔符"><a href="#4-数字分隔符" class="headerlink" title="4.数字分隔符"></a>4.数字分隔符</h5><p>​数字分隔符,可以在数值字面量中使用数字分隔符，数字分隔符是一个单引号，例如：</p><blockquote><ul><li>23’456’789</li><li>0.123’456f</li></ul></blockquote><h5 id="5-十六进制浮点字面量"><a href="#5-十六进制浮点字面量" class="headerlink" title="5.十六进制浮点字面量"></a>5.十六进制浮点字面量</h5><p>​此外，C++17还增加了对十六进制浮点字面量的支持，例如：</p><blockquote><ul><li>0x3.ABCp-10</li><li>0Xb.cp121</li></ul></blockquote><hr><h4 id="1-4变量"><a href="#1-4变量" class="headerlink" title="1.4变量"></a><strong>1.4变量</strong></h4><blockquote><p>在 C++ 中，可以在任何位置声明变量，并且可以在声明一个变量所在行之后任意位置使用该变量。声明变量时可不指定值，这些未初始化的变量通常会被赋予一个半随机值，这个值取决于当前内存的内容(这是许多    bug    的来源)。在 C++ 中，也可以声明变量时为变量指定初始值。下面给出两种风格的变量声明方式，使用的都是代表整数的    int    类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> unintializedInt;<br><span class="hljs-type">int</span> initializedInt = <span class="hljs-number">7</span>;<br>cout &lt;&lt; uninitializedInt &lt;&lt; <span class="hljs-string">&quot; is a random value&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; initializedInt &lt;&lt; <span class="hljs-string">&quot; was assigned an initial value&quot;</span> &lt;&lt; endl;<br></code></pre></td></tr></table></figure><p>注意：</p><blockquote><p>当代码使用未初始化的变量时，多数编译器会给出警告或报错信息。当访问未初始化的变量时，某些 C++ 环境可能会报告运行时错误。</p></blockquote></blockquote><h5 id="1-整型-size-t："><a href="#1-整型-size-t：" class="headerlink" title="1.整型 &amp; size_t："></a>1.整型 &amp; size_t：</h5><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// (signed) int正整数或负整数，范围取决于编译器</span><br><span class="hljs-comment">// 通常占 4 字节</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">-7</span>;<br><span class="hljs-type">signed</span> <span class="hljs-type">int</span> i = <span class="hljs-number">-6</span>;<br><span class="hljs-type">signed</span> i = <span class="hljs-number">-5</span>;<br><br><span class="hljs-comment">// (signed) short (int)短整型整数</span><br><span class="hljs-comment">// 通常占 2 字节</span><br><span class="hljs-type">short</span> s = <span class="hljs-number">13</span>;<br><span class="hljs-type">short</span> <span class="hljs-type">int</span> s = <span class="hljs-number">14</span>;<br><span class="hljs-type">signed</span> <span class="hljs-type">short</span> s = <span class="hljs-number">15</span>;<br><span class="hljs-type">signed</span> <span class="hljs-type">short</span> <span class="hljs-type">int</span> s = <span class="hljs-number">16</span>;<br><br><span class="hljs-comment">// (signed) long (int)长整型整数</span><br><span class="hljs-comment">// 通常占 4 字节</span><br><span class="hljs-type">long</span> l = <span class="hljs-number">-7L</span>;<span class="hljs-comment">// L 可省略</span><br><br><span class="hljs-comment">// (signed) long long (int)超长整型整数，范围取决于编辑器，但不低于长整数</span><br><span class="hljs-comment">// 通常占 8 字节</span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ll = <span class="hljs-number">14LL</span>;<span class="hljs-comment">// LL 可省略</span><br><br><span class="hljs-comment">// unsigned (int / short int / long int / long long int)</span><br><span class="hljs-comment">// 对前面的类型加以限制，使其值 &gt;= 0</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">2U</span>;<br><span class="hljs-type">unsigned</span> j = <span class="hljs-number">5U</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> s = <span class="hljs-number">23U</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> l = <span class="hljs-number">5400UL</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> = <span class="hljs-number">140ULL</span>;<br><span class="hljs-comment">// 每个值的后缀单词都可以省略</span><br></code></pre></td></tr></table></figure><p><strong>关于 size_t 的使用优点</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 必须要引入以下头文件才可以使用：</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span><br></code></pre></td></tr></table></figure><ol><li><strong>无符号性质：</strong> <code>size_t</code> 是无符号整数类型，因此它只表示非负整数值。这有助于避免与负数相关的问题，特别是在处理数组索引和对象大小时。使用 <code>int</code> 可能导致符号错误，例如负索引或溢出。</li><li><strong>平台独立性：</strong> <code>size_t</code> 的大小足够大，可以容纳系统中最大可能的对象大小。在不同平台上，<code>int</code> 的大小可能会有所不同，因此在需要确保跨平台一致性时，使用 <code>size_t</code> 更为合适。</li><li><strong>与标准库的一致性：</strong> C++标准库和STL广泛使用 <code>size_t</code>，因此在与标准库交互时，使用 <code>size_t</code> 使得代码更一致，更容易集成。</li><li><strong>提高代码清晰度：</strong> 使用 <code>size_t</code> 作为大小和索引的类型，可以提高代码的可读性和表达能力。它传达了程序员的意图，即该值用于表示大小或索引，而不是一般性的整数。</li></ol></blockquote><h5 id="2-浮点型："><a href="#2-浮点型：" class="headerlink" title="2.浮点型："></a>2.<strong>浮点型：</strong></h5><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// float浮点型数字</span><br><span class="hljs-comment">// 通常占 4 字节</span><br><span class="hljs-type">float</span> f = <span class="hljs-number">7.2f</span>;<br><br><span class="hljs-comment">// double双精度浮点型数字</span><br><span class="hljs-comment">// 通常占 8 字节</span><br><span class="hljs-type">double</span> d = <span class="hljs-number">7.2</span>;<br><br><span class="hljs-comment">// long double长双精度浮点型数字</span><br><span class="hljs-comment">// 通常占 8、12、16 等字节，取决于编译器和平台</span><br><span class="hljs-type">long</span> <span class="hljs-type">double</span> d = <span class="hljs-number">16.78L</span>;<br></code></pre></td></tr></table></figure></blockquote><h5 id="3-字符型："><a href="#3-字符型：" class="headerlink" title="3.字符型："></a>3.<strong>字符型：</strong></h5><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// char单个字符</span><br><span class="hljs-comment">// 通常占 1 字节</span><br><span class="hljs-type">char</span> ch = <span class="hljs-string">&#x27;m&#x27;</span>;<br><br><span class="hljs-comment">// chat16_t单个 16 位字符</span><br><span class="hljs-comment">// 占 16 位字节</span><br><span class="hljs-type">char16_t</span> c16 = <span class="hljs-string">u&#x27;m&#x27;</span>;<span class="hljs-comment">// u 可省略</span><br><br><span class="hljs-comment">// chat32_t单个 32 位字符</span><br><span class="hljs-comment">// 占 32 位字节</span><br><span class="hljs-type">char32_t</span> c32 = <span class="hljs-string">U&#x27;m&#x27;</span>;<span class="hljs-comment">// U 可省略</span><br><br><span class="hljs-comment">// wchar_t单个宽字符</span><br><span class="hljs-comment">// 大小取决于编译器</span><br><span class="hljs-type">wchar_t</span> w = <span class="hljs-string">L&#x27;m&#x27;</span>;<br><br><span class="hljs-comment">// 后面三种类型主要用于处理 Unicode 字符</span><br><span class="hljs-comment">// Unicode 是一种字符编码标准，为每个字符都分配了一个唯一的数字码点，以便在计算机中进行统一字符表示</span><br></code></pre></td></tr></table></figure></blockquote><h5 id="4-布尔类型："><a href="#4-布尔类型：" class="headerlink" title="4.布尔类型："></a>4.<strong>布尔类型：</strong></h5><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// bool布尔类型，取值为 true 或 false</span><br><span class="hljs-comment">// 占 1 字节</span><br><span class="hljs-type">bool</span> b = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure></blockquote><h5 id="5-单字节：-需引入-头文件"><a href="#5-单字节：-需引入-头文件" class="headerlink" title="5.单字节：(需引入 &lt;cstddef&gt; 头文件)"></a>5.<strong>单字节：(需引入 <code>&lt;cstddef&gt;</code> 头文件)</strong></h5><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// std::byte单个字节</span><br><span class="hljs-comment">// 在 C++17 之前，字符或无符号字符用于表示一个字节，但那些类型使得像在处理字符。std::byte 却能指明意图，即内存中的单个字节</span><br><span class="hljs-comment">// std::byte 的初始化需要使用单元素列表进行直接列表初始化</span><br>std::byte b&#123;<span class="hljs-number">42</span>&#125;;<br><span class="hljs-comment">// 相当于是：00101010</span><br><br>std::byte buffer[<span class="hljs-number">1024</span>];<br><span class="hljs-comment">// 处理网络数据，读写字节流等</span><br><br>std::byte data[<span class="hljs-number">256</span>];<br><span class="hljs-comment">// 读取或写入字节数据到文件或设备</span><br><br>std::byte flags = std::byte&#123;<span class="hljs-number">0x0F</span>&#125;; <br><span class="hljs-comment">// 00001111 in binary</span><br><br>std::byte b&#123;<span class="hljs-number">42</span>&#125;;<br>std::byte mask&#123;<span class="hljs-number">0xF0</span>&#125;;<br>std::byte result = b &amp; mask;<br><span class="hljs-comment">// 相当于 按位与 </span><br></code></pre></td></tr></table></figure></blockquote><h5 id="6-类型转换："><a href="#6-类型转换：" class="headerlink" title="6.类型转换："></a>6.类型转换：</h5><p>C++ 提供<strong>三种</strong>方式来显式地转换变量类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> myFloat = <span class="hljs-number">3.14f</span>;<br></code></pre></td></tr></table></figure><ol><li><p>来自于 C，并且依然被广泛使用，但实际上，<strong>不推荐</strong>使用：</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i_1 = (<span class="hljs-type">int</span>)myFloat;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>初看上去肯自然，但<strong>很少使用</strong>：</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i_2 = <span class="hljs-built_in">int</span>(myFloat);<br></code></pre></td></tr></table></figure></blockquote></li><li><p>最复杂，却最整洁，也是<strong>推荐</strong>的方法，静态类型转换：</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i_3 = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(myFloat);<br></code></pre></td></tr></table></figure></blockquote></li></ol><p><strong>注意：</strong></p><blockquote><ul><li>得到的整数是去掉小数部分的浮点部分。在某些环境中，可自动执行类型转换或强制执行类型转换，例如，short    可自动转换为    long,因为    long    代表精度更高的相同数据类型；</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">long</span> someLong = someShort;<br></code></pre></td></tr></table></figure><ul><li>当自动类型转换变量的类型时，应当了解潜在的数据丢失情况，例如，float    类型转化为    int    类型会丢失掉一部分信息(数字的小数部分)。如果，将一个    float    类型赋给    int    类型而不显示执行类型转换，多数编译器会给出警告信息，如果确信左边的类型和右边的类型完全兼容，那么隐式地转换完全没有问题；</li></ul></blockquote><h5 id="7-获取类型及大小："><a href="#7-获取类型及大小：" class="headerlink" title="7.获取类型及大小："></a>7.<strong>获取类型及大小：</strong></h5><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::cout &lt;&lt; <span class="hljs-built_in">typeid</span>(element).<span class="hljs-built_in">name</span>();<br><span class="hljs-comment">// 为 type_info 类型   </span><br><br>或者<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeindex&gt;</span><span class="hljs-comment">// 必需 &lt;typeindex&gt;</span></span><br>std::cout &lt;&lt; std::<span class="hljs-built_in">type_index</span>(<span class="hljs-built_in">typeid</span>(element)).<span class="hljs-built_in">name</span>();<br><span class="hljs-comment">// 为与 type_info 类似的类，但提供了比 type_info 更好的比较和哈希功能</span><br><br><span class="hljs-comment">// 类型大小</span><br><span class="hljs-built_in">sizeof</span>()<span class="hljs-comment">// 获取内存所占比特数</span><br><span class="hljs-built_in">size</span>()<span class="hljs-comment">// 获取元素个数</span><br><span class="hljs-built_in">strlen</span>()<span class="hljs-comment">// 仅获取 C-string 字符串有效个数，不包括 NUL</span><br></code></pre></td></tr></table></figure></blockquote><h5 id="8-此外："><a href="#8-此外：" class="headerlink" title="8.此外："></a>8.<strong>此外：</strong></h5><blockquote><p>C++ 没有提供基本的字符串类型，但是作为标准库的一部分提供了字符串的标准实现；</p></blockquote><hr><h4 id="1-5运算符"><a href="#1-5运算符" class="headerlink" title="1.5运算符"></a><strong>1.5运算符</strong></h4><blockquote><p>在 C++ 中，运算符可以是一元的(操作一个表达式)、二元的(操作两个表达式)、三元的(操作三个表达式)。</p></blockquote><h5 id="1-一元运算符："><a href="#1-一元运算符：" class="headerlink" title="1.一元运算符："></a>1.<strong>一元运算符：</strong></h5><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">=<br><span class="hljs-comment">// 赋值符号</span><br><br>++<br>--<br><span class="hljs-comment">// 上述两自加加、自减减，仅对变量有效，对常量无效</span><br></code></pre></td></tr></table></figure></blockquote><h5 id="2-二元运算符："><a href="#2-二元运算符：" class="headerlink" title="2.二元运算符："></a>2.<strong>二元运算符：</strong></h5><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++">+<br>-<br>*<br>/<br><span class="hljs-comment">// 加、减、乘、除</span><br><br>%<br><span class="hljs-comment">// mod，取余运算</span><br><br>+=<br>-=<br>*=<br>/=<br>%=<br><span class="hljs-comment">// 简写</span><br><br>&amp;<br>|<br>&lt;&lt;<br>&gt;&gt;<br>^<br><span class="hljs-comment">// 按位与、按位或、左移、右移、按位异或</span><br><br>&amp;=<br>|=<br>&lt;&lt;=<br>&gt;&gt;=<br>^=<br><span class="hljs-comment">// 简写</span><br></code></pre></td></tr></table></figure></blockquote><h5 id="3-三元运算符-条件运算符-："><a href="#3-三元运算符-条件运算符-：" class="headerlink" title="3.三元运算符(条件运算符)："></a>3.<strong>三元运算符(条件运算符)：</strong></h5><blockquote><p>C++ 中有一个接收三个参数的运算符，称为三元运算符。可将其作为“如果【某事发生了】，那么【执行某个操作】；否则，【执行其他操作】”的条件表达式的简写。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">condition ? expression_if_true : expression_if_false;<br></code></pre></td></tr></table></figure><p>条件运算符的优点是几乎可以在任何环境中使用，而且是直接将结果用在代码中，而非执行代码块，这使得它是一个运算符，而非条件语句。</p></blockquote><h4 id="1-6类型"><a href="#1-6类型" class="headerlink" title="1.6类型"></a><strong>1.6类型</strong></h4><blockquote><p>在 C++ 中，可使用基本类型(int、bool 等)创建更复杂的自定义类型。一旦熟悉 C++ 程序，就会很少使用从 C 中沿袭来的技巧，因为类更强大。虽然如此，但是还是有必要学会以下两种创建类型的方法：</p></blockquote><h5 id="1-枚举类型："><a href="#1-枚举类型：" class="headerlink" title="1.枚举类型："></a>1.<strong>枚举类型：</strong></h5><blockquote><p>整数代表某个数字序列中的值，枚举类型允许用户定义自己的序列，这样声明的变量就只能使用这个序列中的值；</p><ul><li><p><strong>const    表示法：</strong></p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 当希望获取某些不变量的值的时候，使用以下方式并不是很好</span><br><span class="hljs-comment">// 以国际象棋为例，int 表示所有棋子</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> PieceTypeKing = <span class="hljs-number">0</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> PieceTypeQueen = <span class="hljs-number">1</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> PieceTypeRook = <span class="hljs-number">2</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> PieceTypePawn = <span class="hljs-number">3</span>;<br><span class="hljs-comment">// etc.</span><br><span class="hljs-type">int</span> myPiece = PieceTypeKing;<br><span class="hljs-comment">// 这种表示虽然正确，但是存在一定风险，因为，棋子是一个 int，如果另一个程序增加棋子的值，就可以让 King 变成 Queen，这实质上没有意义。更糟糕的是，有人可能将某个棋子的值设置成为 -1，而这个值并没有对应的常量</span><br></code></pre></td></tr></table></figure></blockquote></li><li><p><strong>枚举表示法：</strong></p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 利用以下代码生成一个新类型 PieceType</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">PieceType</span><br>&#123;<br>PieceTypeKing,<span class="hljs-comment">// 不显式设定，默认为 0</span><br>PieceTypeQueen,<span class="hljs-comment">// 不显式设定，默认为 1</span><br>PieceTypeRook,<span class="hljs-comment">// 不显式设定，默认为 2</span><br>PieceTypePawn<span class="hljs-comment">// 不显式设定，默认为 3</span><br>&#125;;<br>PieceType myPiece;<br>myPiece = PieceTypeQueen;<br>cout &lt;&lt; myPiece;<br><span class="hljs-comment">// 正常输出一个整型值</span><br><br>myPiece = <span class="hljs-number">0</span>;<br>cout &lt;&lt; myPiece;<br><span class="hljs-comment">// 出现类型不匹配报错</span><br></code></pre></td></tr></table></figure><p>由于实质上，enum    类型是一个整型值，但是由于它本身并不是    int    类型，所以能降低风险；</p><p>关于枚举类型语法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">PieceType</span><br>&#123;<br>PieceTypeKing = <span class="hljs-number">1</span>,<span class="hljs-comment">// 设定为 1</span><br>PieceTypeQueen,<span class="hljs-comment">// 为前驱 +1，为 2</span><br>PieceTypeRook = <span class="hljs-number">10</span>,<span class="hljs-comment">// 设定为 10</span><br>PieceTypePawn<span class="hljs-comment">// 为前驱 +1，为 11</span><br>&#125;;<br><span class="hljs-comment">// 即，某位置的值若未被设定，则，其值为前驱值 +1</span><br></code></pre></td></tr></table></figure></blockquote></li></ul></blockquote><h5 id="2-强类型枚举："><a href="#2-强类型枚举：" class="headerlink" title="2.强类型枚举："></a>2.<strong>强类型枚举：</strong></h5><blockquote><ul><li><p>上面给出的枚举并不是强类型的，这意味着并非是类型安全的，它们总被解释为整形数据，因此可以比较完全不同的枚举类型的枚举值；</p><blockquote><p>意思是说，虽然无法参与整型运算，但是，本质上，又被解释为整形变量，所以，可以参与到整型变量比较，这同样是一种不安全；</p></blockquote></li><li><p>强类型的 enum class 枚举解决了这些问题，例如，下面定义前述的 PieceType 枚举类型的安全版本：</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">PieceType</span><br>&#123;<br>King = <span class="hljs-number">1</span>,<br>Queen,<br>Rook = <span class="hljs-number">10</span>,<br>Pawn<br>&#125;;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>对于 enum class，枚举值名不会超出封闭的作用域，这代表总要使用作用域解析操作符：</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">PieceType piece = PieceType::King;<br></code></pre></td></tr></table></figure><p>这也意味着，枚举值可以指定更简短的名称，因为有作用域的限定，每次都要作用域解析；</p><p>因此，避免了枚举值自动类型转换为整数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 以下代码是不合法的</span><br><span class="hljs-keyword">if</span> (PieceType == <span class="hljs-number">2</span>) &#123;...&#125;<br></code></pre></td></tr></table></figure><p>此外，默认情况下，枚举值的基本类型是整型，但是可以采用以下方法加以改变：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">PieceType</span> : <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span><br>&#123;<br>King = <span class="hljs-number">1</span>,<br>Queen,<br>Rook = <span class="hljs-number">10</span>,<br>Pawn<br>&#125;;<br></code></pre></td></tr></table></figure></blockquote></li><li><p><strong>注意：</strong></p><blockquote><p>建议用类型安全的 enum class 枚举来代替类型不安全的 enum 枚举；</p></blockquote></li></ul></blockquote><h5 id="3-结构-struct-："><a href="#3-结构-struct-：" class="headerlink" title="3.结构(struct)："></a>3.<strong>结构(struct)：</strong></h5><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// employeestruct.h</span><br><span class="hljs-comment">// 在头文件中声明结构体 Employee</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Employee</span><br>&#123;<br><span class="hljs-type">char</span> firstInitial;<br><span class="hljs-type">char</span> lastInitial;<br><span class="hljs-type">int</span> employeeNumber;<br><span class="hljs-type">int</span> salary;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// employee.cpp</span><br><span class="hljs-comment">// 在头文件中实现结构体 Employee</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;employeestruct.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Employee anEmployee;<br>anEmployee.firstInitial = <span class="hljs-string">&#x27;M&#x27;</span>;<br>anEmployee.lastInitial = <span class="hljs-string">&#x27;G&#x27;</span>;<br>anEmployee.employeeNumber = <span class="hljs-number">42</span>;<br>anEmployee.salary = <span class="hljs-number">80000</span>;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;Employee: &quot;</span> &lt;&lt; anEmployee.firstInitial &lt;&lt; anEmployee.lastInitial &lt;&lt; emdl;<br>cout &lt;&lt; <span class="hljs-string">&quot;Number: &quot;</span> &lt;&lt; anEmployee.employeeNumber &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;Salary: $&quot;</span> &lt;&lt; anEmployee.salary &lt;&lt; endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><hr><h4 id="1-7条件语句"><a href="#1-7条件语句" class="headerlink" title="1.7条件语句"></a><strong>1.7条件语句</strong></h4><h5 id="1-if-else-语句"><a href="#1-if-else-语句" class="headerlink" title="1.if &#x2F; else 语句"></a>1.<strong>if &#x2F; else 语句</strong></h5><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (condition)<br>&#123;...&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (condition)<br>&#123;...&#125;<br><span class="hljs-keyword">else</span><br>&#123;...&#125;<br></code></pre></td></tr></table></figure><p>0&#x2F;false  都被视为 false；</p><p>非0&#x2F;true都被视为 true；</p></blockquote><h5 id="2-if-语句的初始化器"><a href="#2-if-语句的初始化器" class="headerlink" title="2.if 语句的初始化器"></a>2.<strong>if 语句的初始化器</strong></h5><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (&lt;initializer&gt;;&lt;conditional_expression&gt;) &#123;&lt;body&gt;&#125;<br></code></pre></td></tr></table></figure><p><strong><code>&lt;initializer&gt;</code></strong> 中引入的任何变量只能在**<code>&lt;conditional_expression&gt;</code>** 和 <strong><code>&lt;body&gt;</code></strong> 中可用，此类变量在 if 语句外不可用，是匿名变量；</p><p>示例：</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (Employee employee = <span class="hljs-built_in">GetEmployee</span>(); employee.salary &gt; <span class="hljs-number">1000</span>) &#123;...&#125;<br></code></pre></td></tr></table></figure></blockquote></blockquote><h5 id="3-switch-语句"><a href="#3-switch-语句" class="headerlink" title="3.switch 语句"></a>3.<strong>switch 语句</strong></h5><blockquote><p>switch 是另一种根据表达式值执行操作的语法。在 C++ 中，switch 语句的表达式必须是整型、能转化为整形的类型、枚举类型或强类型枚举，必须与一个常量比较，每个常量值代表一种“*<em>情况</em>(case)***”，如果表达式与这种情况匹配，随后的代码将会被执行，直到遇到 <strong><code>break</code></strong> 语句为止。此外，还提供 <strong><code>default</code></strong> 情况，如果没有其他情况与表达式匹配，表达式值将与 <strong><code>default</code></strong> 情况匹配；</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">switch</span> (menuItem)<br>&#123;<br><span class="hljs-keyword">case</span> OpenMenuItem:<br><span class="hljs-comment">// Code to open a file</span><br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> SaveMenuItem:<br><span class="hljs-comment">// Code to save a file</span><br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-comment">// Code to give an error message</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-comment">// 转化为相应的 if/else 语句</span><br><span class="hljs-keyword">if</span> (menuItem == OpenMenuItem)<br>&#123;<br><span class="hljs-comment">// Code to open a file</span><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (menuItem == SaveMenuItem)<br>&#123;<br><span class="hljs-comment">// Code to save a file</span><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">// Code to give an error message</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果要基于多个表达式的多个值(而非对表达式进行一些检测)执行操作 ，通常使用 switch 语句。此时，switch 语句可以避免级联使用 if-else 语句。</p><p><strong>注意：</strong></p><blockquote><p>一旦找到与 switch 条件匹配的 case 表达式，就执行其后的语句，知道遇到 break 语句为止。即使遇到另一个 case 表达式，执行也会继续，这种语法称为 fallthrough；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">switch</span> (backgroundColor)<br>&#123;<br><span class="hljs-keyword">case</span> Color::DarkBlue:<br><span class="hljs-keyword">case</span> Color::Black:<br>  <span class="hljs-comment">// Code to execute for both a dark blue or black background color</span><br>  <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> Color::Red:<br>  <span class="hljs-comment">// Code to excute for a red background color</span><br>  <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果是无意忘记 break 语句，fallthough 将成为 bug 的来源，因此如果在 switch 语句中，检测到 fallthough，编译器将会生成警告信息，除非像上例那样 case 为空。</p><p>此外，可以通过使用 <strong><code>[[fallthougn]]</code></strong> 特殊性，来告诉编辑器某个 fall though 是有意为之的；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">switch</span> (backgroundColor)<br>&#123;<br><span class="hljs-keyword">case</span> Color::DarkBlue:<br>  <span class="hljs-built_in">doSomethingForDarkBlue</span>();<br>  [[fallthough]];<br><span class="hljs-keyword">case</span> Color::Black:<br>  <span class="hljs-comment">// Code to execute for both a dark blue or black background color</span><br>  <span class="hljs-built_in">doSomethingForBlackOrDarkBlue</span>();<br>  <span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> Color::Red:<br><span class="hljs-keyword">case</span> Color::Green:<br>  <span class="hljs-comment">// Code to excute for a red or green background color</span><br>  <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></blockquote><h5 id="4-switch-语句的初始化器"><a href="#4-switch-语句的初始化器" class="headerlink" title="4.switch 语句的初始化器"></a>4.<strong>switch 语句的初始化器</strong></h5><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">switch</span> (&lt;initializer&gt;, &lt;expression&gt;) &#123;&lt;body&gt;&#125;<br></code></pre></td></tr></table></figure><p>与 if 语句一致，**<code>&lt;initializer&gt;</code>** 中引入的任何变量只能在**<code>&lt;conditional_expression&gt;</code>** 和 <strong><code>&lt;body&gt;</code></strong> 中可用，它们在 switch 语句外不可用；</p></blockquote><h5 id="5-条件运算符"><a href="#5-条件运算符" class="headerlink" title="5.条件运算符"></a>5.<strong>条件运算符</strong></h5><blockquote><p>略，详见三元运算符；</p></blockquote><hr><h4 id="1-8逻辑比较运算符"><a href="#1-8逻辑比较运算符" class="headerlink" title="1.8逻辑比较运算符"></a><strong>1.8逻辑比较运算符</strong></h4><blockquote><p><strong>逻辑比较运算符(conditional operator)：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">&lt;<br>&gt;<br>&lt;=<br>&gt;=<br>==<br>!=<br>!<br>&amp;&amp;<br>||<br></code></pre></td></tr></table></figure><ul><li><p>在 C++ 中，对表达式求值时，会采用短路逻辑，即，一旦发现最终结果可以确定，就不再对后面的表达式求值；</p></li><li><p>短路的做法对性能有好处：在使用逻辑短路时，可将代价更低的测试放在前面，以避免执行代价更高的测试。通过逻辑短路还可以避免在指针上下文中，避免指针无效时执行表达式的一部分的情况；</p></li></ul></blockquote><hr><h4 id="1-9函数"><a href="#1-9函数" class="headerlink" title="1.9函数"></a><strong>1.9函数</strong></h4><blockquote><ul><li><p>对于大型程序来说，将所有代码都放到 main() 函数中是无法管理的。为了使程序便于理解，需要将代码分解为简单明了的程序。</p></li><li><p>在 C++ 中，为了让其他代码能够使用某个函数，首先，应当声明该函数。如果函数在某个特定的文件内部被使用，通常会在源文件中声明并定义这个函数。如果函数是供其他模块或文件使用的，通常在<strong>头文件</strong>中声明函数，并在源文件中定义函数。</p></li><li><p>函数声明通常被称为<strong>“函数原型”</strong>或<strong>“函数头”</strong>，以强调这代表函数的访问方式，而不是具体代码，术语<strong>“函数签名”</strong>指将函数名和参数列表与形参列表组合在一起，但没有返回值。</p></li><li><p>当没有与函数声明匹配的函数定义时，在编译过程中，会出现<strong>链接阶段</strong>错误；</p></li><li><p>注意：与 C 不同，在 C++ 中没有形参的函数仅需要一个空的参数列表，不需要使用 void 指出此处没有形参；然而，如果没有返回值，那么仍需要 void 来指明这一点；</p><ol><li><p><strong>函数返回类型的推断：</strong></p><blockquote><p>C++14 允许要求编辑器自动推出函数的返回值，要使用这个功能，需要把 <strong><code>auto</code></strong> 指定为返回类型；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">addnumber</span><span class="hljs-params">(<span class="hljs-type">int</span> number1, <span class="hljs-type">int</span> number2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> number1 + number2;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：函数中可有多个 <strong><code>return</code></strong> 语句，但是它们应解析为<strong>相同的类型</strong>。这种函数甚至可以包含<strong>递归调用</strong>(调用自身)，但函数中的第一个 <strong><code>return</code></strong> 语句必须时非递归调用的；</p></blockquote></li><li><p><strong>当前函数的名称：</strong></p><blockquote><p>每个函数都有一个预定义的局部变量 **<code>_ _func_ _</code>**，其中包括当前函数的名称。这个变量的一个用途是用于日志记录：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">addNumbers</span><span class="hljs-params">(<span class="hljs-type">int</span> number1, <span class="hljs-type">int</span> number2)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Entering function &quot;</span> &lt;&lt; __func__ &lt;&lt; std::endl;<br> <span class="hljs-comment">// 左右两边各两个下划线，用于包括当前函数的名称</span><br> <span class="hljs-comment">// __func__ 为 const char[] 类型</span><br> <span class="hljs-comment">// __func__ 是编译器提供的宏，在编译时展开，而不是在运行时展开，这使得它在程序执行期间不会产生额外的运行开销，主要用于调试和日志记录，以便在运行时了解代码的执行流程，而不会影响实际的程序性能</span><br><span class="hljs-keyword">return</span> number1 + number2;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li></ol></li></ul></blockquote><hr><h4 id="1-10C-风格的数组"><a href="#1-10C-风格的数组" class="headerlink" title="1.10C 风格的数组"></a><strong>1.10C 风格的数组</strong></h4><blockquote><p>注意：在 C++ 中，尽量<strong>避免</strong>使用这种 C 风格的数组，而改用<strong>标准库</strong>功能，例如：**<code>std::array</code>** 和 **<code>std::vector</code>**；</p></blockquote><h5 id="1-一维数组："><a href="#1-一维数组：" class="headerlink" title="1.一维数组："></a>1.<strong>一维数组：</strong></h5><blockquote><p>数组具有一系列值，所有值的<strong>类型相同</strong>，每个值都可以根据它在数组中的位置进行访问。在 C++ 中声明数组时，必须声明<strong>数组大小</strong>。数组大小不能用变量表示——必须用<strong>常量</strong>或<strong>常量表示式</strong><em><strong>(coonstexpr)</strong></em> 表示数组大小；</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">int myArray[<span class="hljs-number">3</span>]<span class="hljs-comment">;</span><br>myArray[<span class="hljs-number">0</span>] <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>myArray[<span class="hljs-number">1</span>] <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>myArray[<span class="hljs-number">2</span>] <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>// Index 的起点始终是 <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><ul><li><strong>不使用循环的初始化机制：</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> myArray[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> myArray[<span class="hljs-number">3</span>] = &#123;&#125;;<br><span class="hljs-comment">// 都起到将所有列表中元素置零的作用</span><br><br><span class="hljs-type">int</span> myArray[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-comment">// 自动推导出列表长度，并初始化每个位置的值</span><br><br><span class="hljs-type">int</span> myArray[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">2</span>&#125;;<br><span class="hljs-comment">// 将数组第一个元素置为 2，其余置为 0</span><br><br><span class="hljs-type">int</span> myArray[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;;<br><span class="hljs-comment">// 将数组第一个元素置为 1，将数组第二个元素置为 2，其余置为 0</span><br></code></pre></td></tr></table></figure><ul><li><p><strong>获取数组大小(元素个数)：</strong></p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 遇到数组长度等，都使用 size_t 的方式来描述大小！！！</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span><span class="hljs-comment">// 必须 &lt;array&gt;</span></span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> arraySize = std::<span class="hljs-built_in">size</span>(myArray);<br><span class="hljs-comment">// 使用 unsigned int 接收数组大小</span><br>std::cout &lt;&lt; std::<span class="hljs-built_in">size</span>(myArray);<br><br>或者：<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> arraySize = <span class="hljs-built_in">sizeof</span>(myArray) / <span class="hljs-built_in">sizeof</span>(myArray[<span class="hljs-number">0</span>]);<br></code></pre></td></tr></table></figure></blockquote></li></ul></blockquote><h5 id="2-二维数组："><a href="#2-二维数组：" class="headerlink" title="2.二维数组："></a>2.<strong>二维数组：</strong></h5><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> ticTacToeBoard[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure></blockquote><h5 id="3-三维数组、更高维数组："><a href="#3-三维数组、更高维数组：" class="headerlink" title="3.三维数组、更高维数组："></a>3.<strong>三维数组、更高维数组：</strong></h5><blockquote><p>难以描绘，极少使用；</p></blockquote><hr><h4 id="1-11std-array"><a href="#1-11std-array" class="headerlink" title="1.11std::array"></a><strong>1.11<code>std::array</code></strong></h4><blockquote><p>在 C++ 中，有一种<strong>大小固定</strong>的特殊容器 <strong><code>std::array</code><strong>，这种容器在 <strong><code>&lt;array&gt;</code></strong> 头文件中定义。它详细用法在之后学习，但基本就是对 C 风格的数组进行</strong>简单包装</strong>：</p><p><strong>用 <code>std::array</code> 代替 C 风格的数组优点：</strong></p><blockquote><ol><li>它总是知道<strong>自身大小</strong>；</li><li><strong>不会自动转化为指针</strong>，从而避免了某些类型的 bug；</li><li>具有<strong>迭代器</strong>，可以方便地遍历元素；</li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::array&lt;<span class="hljs-type">int</span>, 3&gt; arr = &#123; <span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span> &#125;; <br>std::cout &lt;&lt; <span class="hljs-string">&quot;Array size = &quot;</span> &lt;&lt; arr.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;2nd element = &quot;</span> &lt;&lt; arr[<span class="hljs-number">1</span>] &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><blockquote><p><strong>C 风格和 std::array 的数组</strong>都具有<strong>固定的大小</strong>，在编译过程中不会改变；</p><p>如果希望数组的大小是动态的，推荐使用 <code>std::vector</code>，在 vector 中添加新元素时，vector 会自动增加其大小；</p></blockquote></blockquote></blockquote><hr><h4 id="1-12std-vector"><a href="#1-12std-vector" class="headerlink" title="1.12std::vector"></a><strong>1.12<code>std::vector</code></strong></h4><blockquote><ul><li>标准库提供了多个不同的<strong>非固定大小容器</strong>，可用于存储信息。**<code>std::vector</code>** 就是其中的一个示例。它在 <strong><code>&lt;vector&gt;</code></strong> 头文件中被声明，用一种更灵活更安全的机制取代 C 中的数组概念。用户不必担心内存的管理，因为 vector 将自动分配足够的内存来存放元素。vector 是动态的，意味着可以在运行时添加和删除元素,而且它的用法十分简单，示例：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Create a vector of integers</span><br>std::vector&lt;<span class="hljs-type">int</span>&gt; myVector = (<span class="hljs-number">11</span>, <span class="hljs-number">12</span>);<br><br><span class="hljs-comment">// Add some more integers to the vector using push_back()</span><br>myVector.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">33</span>);<br>myVector.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">44</span>);<br><br><span class="hljs-comment">// Delete some more integer to the vector using pop_back()</span><br><span class="hljs-comment">// 删除最后一个元素</span><br>myVector.<span class="hljs-built_in">pop_back</span>();<br><br><span class="hljs-comment">// 删除中间元素，后面元素顺位向前移动，使用 erase()</span><br>myVector.<span class="hljs-built_in">erase</span>(myVector.<span class="hljs-built_in">begin</span>());<span class="hljs-comment">// 删除索引为 0 元素</span><br>myVector.<span class="hljs-built_in">erase</span>(myVector.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">2</span>) <span class="hljs-comment">// 删除索引为 2 元素</span><br><br><span class="hljs-comment">// Access elements</span><br>std::cout &lt;&lt; <span class="hljs-string">&quot;1st element: &quot;</span> &lt;&lt; myVector[<span class="hljs-number">0</span>] &lt;&lt; endl;<br></code></pre></td></tr></table></figure><ul><li><p>vector 中尖括号用来指定模板函数，与之前的 <strong><code>std::array</code></strong> 一样，vector 时一个泛类容器，几乎可以容纳任何类型的对象；但是必须使用简括号指定要在 vector 中存放的对象类型；</p></li><li><p>为向 vector 中添加元素，可以使用 push_back() 方法；</p></li><li><p>为访问 vector 中各个元素，可使用类似于数组的语法，即，operator[]；</p></li></ul></blockquote><hr><h4 id="1-13结构化绑定"><a href="#1-13结构化绑定" class="headerlink" title="1.13结构化绑定"></a><strong>1.13结构化绑定</strong></h4><blockquote><p><strong>结构化绑定*(structured budings)*<strong>，允许声明多个变量，这些变量使用数组、结构、</strong><code>std::pair</code></strong> 关键词或 <strong><code>std::tuple</code></strong> 中的元素来初始化。它允许你以一种简洁的方式从复合类型（例上面所提的**<code>std::pair</code>** 或  **<code>std::tuple</code>**）或结构体中提取成员，并将其绑定到命名变量上。结构化绑定的主要目的是提高代码的可读性和简洁性，特别是在处理复杂数据结构时；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 基本语法：</span><br><span class="hljs-keyword">auto</span> [var1, var2, ...] = expression;<br></code></pre></td></tr></table></figure><p>使用特点：</p><blockquote><ul><li>假定有以下数组：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::array&lt;<span class="hljs-type">int</span>, 3&gt; values = &#123;<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>&#125;;<br></code></pre></td></tr></table></figure><ul><li>可声明三个变量 x、y、z，使用其后数组中的三个值进行初始化。注意，必须为结构化绑定使用 auto 关键字（例，不能用 int 替代 auto）：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> [x, y, z] = values;<br></code></pre></td></tr></table></figure><ul><li><p>注意：使用结构化绑定声明的变量数量必须与右侧表达式中的值数量匹配；</p></li><li><p>此外，如果所有非静态成员都是公有的，也可以将结构化绑定用于结构；</p></li><li><p>使用结构化绑定优点，示例：</p><blockquote><ol><li><p>简化**<code>std::pair</code>** 、  <strong><code>std::tuple</code></strong> 或结构体使用，无需显式地访问元素索引或成员变量;</p><blockquote><pre><code class="c++">std::tuple&lt;int, double, std::string&gt; myTuple = std::make_tuple(42, 3.14, &quot;Hello&quot;);auto [a, b, c] = myTuple;</code></pre></blockquote></li><li><p>提高代码可读性，直观显示内容；</p><blockquote><pre><code class="c++">struct Point&#123;    double mX;    double mY;    double mZ;&#125;;Point point;point.mX = 1.0;point.mY = 2.0;point.mZ = 3.0;auto [x, y, z] = point;</code></pre></blockquote></li><li><p>减少错误风险，减少手动索引或访问机构提而引起的错误；</p><blockquote><pre><code class="c++">std::pair&lt;int, std::string&gt; myPair = std::make_pair(42, &quot;Hello&quot;);auto [num, text] = myPair;</code></pre></blockquote></li></ol></blockquote></li></ul></blockquote></blockquote><hr><h4 id="1-14循环"><a href="#1-14循环" class="headerlink" title="1.14循环"></a><strong>1.14循环</strong></h4><blockquote><p>在 C++ 中，提供了 4 种循环结构：</p></blockquote><h5 id="1-while-循环"><a href="#1-while-循环" class="headerlink" title="1.while 循环"></a>1.<strong>while 循环</strong></h5><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (condition_expr)<br>&#123;...&#125;<br><span class="hljs-comment">// 在循环中使用 break 关键字立即跳出循环并执行之后程序</span><br><span class="hljs-comment">// 在循环中使用 continue 关键字可返回循环顶部并对 while 表达式重新求值</span><br><span class="hljs-comment">// 这两种风格都不提倡使用，因为它们会使程序的执行产生无规则的跳转，应该慎用</span><br></code></pre></td></tr></table></figure></blockquote><h5 id="2-do-while-循环"><a href="#2-do-while-循环" class="headerlink" title="2.do&#x2F;while 循环"></a>2.<strong>do&#x2F;while 循环</strong></h5><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">do</span><br>&#123;...&#125;<br><span class="hljs-keyword">while</span>(condition_expr);<br><span class="hljs-comment">// 使得程序至少执行一次</span><br></code></pre></td></tr></table></figure></blockquote><h5 id="3-for-循环"><a href="#3-for-循环" class="headerlink" title="3.for 循环"></a>3.<strong>for 循环</strong></h5><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (init_state; loop_conditon; iter_expr) <br>&#123;...&#125;<br></code></pre></td></tr></table></figure></blockquote><h5 id="4-基于区间的-for-循环-Range-Based-for-Loop"><a href="#4-基于区间的-for-循环-Range-Based-for-Loop" class="headerlink" title="4.基于区间的 for 循环(Range-Based for Loop)**"></a>4.<em><em>基于区间的 for 循环</em>(Range-Based for Loop)</em>**</h5><blockquote><p>这种循环类似于 Python，允许方便地迭代容器中的元素。这种循环可用于 C 风格的数组、初始化列表等，也可用于具有返回迭代器的 begin() 和 end() 函数的类型，例如， <strong><code>std::array</code></strong> 、 <strong><code>std::vector</code></strong> 等其他所有标准库容器；</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::array&lt;<span class="hljs-type">int</span>, 4&gt; arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : arr)<br>&#123;<br>std::cout &lt;&lt; i &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><hr><h4 id="1-15初始化列表"><a href="#1-15初始化列表" class="headerlink" title="1.15初始化列表"></a><strong>1.15初始化列表</strong></h4><blockquote><p>初始化列表在  <strong><code>initializer_list</code></strong>  头文件中定义；利用初始化列表，可以轻松地编写能接收<strong>可变数量参数</strong>的函数。  <strong><code>initializer_list</code></strong>  类是一个模板，要求在尖括号之间指定列表中的元素类型，这类似于指定 vector 中存储的对象类型；</p><p>示例：</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;initializer_list&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 定义可变数量参数累加函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">makeSun</span><span class="hljs-params">(initializer_list&lt;<span class="hljs-type">int</span>&gt; lst)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> total = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> value : lst)<br>&#123;<br>total += value;<br>&#125;<br><br><span class="hljs-keyword">return</span> total;<br>&#125;<br><br><span class="hljs-type">int</span> a = <span class="hljs-built_in">makeSun</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;);<br><span class="hljs-type">int</span> b = <span class="hljs-built_in">makeSun</span>(&#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>, <span class="hljs-number">60</span>&#125;);<br><br><span class="hljs-comment">// 初始化列表是类型安全的，会定义列表中允许的类型。对于此处的 makeSun() 函数，初始化列表所有元素必须都是整数。</span><br><span class="hljs-comment">// 尝试使用 double 数值进行调用，将会导致编译器生成错误或警告</span><br><span class="hljs-type">int</span> c = <span class="hljs-built_in">makeSun</span>(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3.0</span>&#125;);<br></code></pre></td></tr></table></figure></blockquote></blockquote><hr><h4 id="1-16小结"><a href="#1-16小结" class="headerlink" title="1.16小结"></a><strong>1.16小结</strong></h4><blockquote><p>至此，C++ 程序设计的基本要点已经复习完成，这些是很简单的内容；</p></blockquote><hr><h3 id="1-2-深入研究-C"><a href="#1-2-深入研究-C" class="headerlink" title="1.2    深入研究 C++"></a><strong>1.2    深入研究 C++</strong></h3><hr><h4 id="2-1C-中的字符串"><a href="#2-1C-中的字符串" class="headerlink" title="2.1C++ 中的字符串"></a><strong>2.1C++ 中的字符串</strong></h4><blockquote><p>在 C++ 中使用字符串有三种方法。</p></blockquote><h5 id="1-C-风格的字符串"><a href="#1-C-风格的字符串" class="headerlink" title="1.C 风格的字符串"></a>1.<strong>C 风格的字符串</strong></h5><blockquote><p>将字符看成字符数组；</p></blockquote><h5 id="2-C-风格的字符串"><a href="#2-C-风格的字符串" class="headerlink" title="2.C++ 风格的字符串"></a>2.<strong>C++ 风格的字符串</strong></h5><blockquote><p>将字符串封装到一种易于使用的 string 类型中，需要引入 <strong><code>&lt;string&gt;</code></strong> 头文件；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// C++ 中 string 的用法与基本类型几乎相同</span><br><span class="hljs-comment">// 与 I/O 流一样，string 类型位于 std 名称空间</span><br>std::string myString = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;The value of myString is &quot;</span> &lt;&lt; myString &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;The second letter is &quot;</span> &lt;&lt; myString[<span class="hljs-number">1</span>] &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure></blockquote><h5 id="3-非标准的普通类"><a href="#3-非标准的普通类" class="headerlink" title="3.非标准的普通类"></a>3.<strong>非标准的普通类</strong></h5><blockquote><p>略，详见第二章；</p></blockquote><hr><h4 id="2-2指针和动态内存"><a href="#2-2指针和动态内存" class="headerlink" title="2.2指针和动态内存"></a><strong>2.2指针和动态内存</strong></h4><blockquote><p>动态内存允许所创建的程序具有在编译时大小可变的数据，大多数复杂程序都会以某种方式使用动态内存；</p></blockquote><h5 id="1-堆栈和堆"><a href="#1-堆栈和堆" class="headerlink" title="1.堆栈和堆"></a>1.<strong>堆栈和堆</strong></h5><blockquote><p>在 C++ 的内存中，分为两部分：<strong>堆栈</strong> 和 <strong>堆</strong>。</p><ul><li><p><strong>堆栈</strong></p><blockquote><p><strong>堆栈</strong>就像一副扑克牌，当前顶部的牌代表程序当前的作用域，通常时当前正在执行的函数；当前函数中声明的所有变量将占用顶部<strong>堆栈帧</strong>(也就是最上面的那张牌)的内存。如果当前函数(将其称为 foo())调用了另一个函数 bar()，就会翻开一张新牌，这样 bar() 就会拥有自己的<strong>堆栈帧</strong>供其运行。任何从 foo() 传递给 bar() 的参数都会从 foo() <strong>堆栈帧</strong>复制到 bar() <strong>堆栈帧</strong>；</p><p><strong>堆栈帧</strong>很好，因为它为每个函数提供了独立的内存空间。如果在 foo() <strong>堆栈帧</strong> 中声明了一个变量，那么除非专门要求，否则调用 bar() 函数不会更改该变量。此外，foo() 函数执行完毕时，<strong>堆栈帧</strong> 就会消失，该函数声明的所有变量都不会再占用内存。堆栈上的分配内存的变量<strong>不需要</strong>程序员**释放内存(删除)**，这个过程是自动完成的；</p></blockquote></li><li><p><strong>堆</strong></p><blockquote><p><strong>堆</strong>是与当前函数与堆栈帧完全没有关系的内存区域。如果想在函数调用结束后仍保存其中声明的变量，可以将变量放到堆中。堆的结构并不复杂，可以将堆当作一个堆位。程序可在任何时候向堆中添加新位或修改堆中已有的位。**必须确保释放(删除)**在堆中分配的任何内存，这个过程不会自动完成，除非使用了智能指针；</p></blockquote></li></ul></blockquote><h5 id="2-使用指针"><a href="#2-使用指针" class="headerlink" title="2.使用指针"></a>2.<strong>使用指针</strong></h5><blockquote><ul><li><p><strong>在数据类型后加 <code>*</code></strong> ，将使之变为其类型的指针，但声明时，如果未初始化那么它可能指向一个随机的位置，而这时，这个指针很可能使得程序崩溃；所以，<strong>必须要在同时证明和初始化指针</strong>，如果不希望立即分配地址，则可以将它们<strong>初始化为空指针 nullptr</strong>；</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span>* myIntegerPointer = <span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>nullptr 是一个<strong>特殊默认值</strong>，可以在布尔表达式中被转化为 false;</p></li><li><p>使用 **new 操作符 **分配内存：</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">myIntegerPointer = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br></code></pre></td></tr></table></figure></blockquote></li><li><p><strong>指针的解除引用</strong></p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">*myIntegerPointer = <span class="hljs-number">8</span>;<br><span class="hljs-comment">// 这并不是将 myIntegerPointer 的值设定为 8，而是将 myIntegerPointer 指向的内存设为 int 类型的整型 8</span><br><span class="hljs-comment">// 而如果真不是解除引用，而是调整 myIntegerPointer 为 8 则很有可能是一个随机无用的内存单元，最终导致程序崩溃</span><br></code></pre></td></tr></table></figure><p>可将解除引用看成沿着指针箭头方向寻找堆中实际的值；</p><p><strong>使用完 new 动态分配后的内存，需要使用 delete 操作符进行释放内存，为防止在释放指针指向的内存后再使用指针，建议把指针设置为 nullptr;</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">delete</span> myIntegerPointer;<br>myIntegerPointer = <span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></table></figure><p><strong>警告：</strong></p><blockquote><p><strong>在解除引用前指针必须有效！对 NULL 或未初始化的指针解除引用会导致不可确定的行为</strong>，程序可能崩溃，也可能继续运行，但可能会给出奇怪的结果；</p></blockquote></blockquote></li><li><p>指针并被总是指向堆内存，可声明一个指向堆栈中变量甚至指向其他指针的指针。为让指针指向某个变量，**需要使用“取”址运算符 &amp;**；</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> i = <span class="hljs-number">8</span>;<br><span class="hljs-type">int</span>* myIntegerPointer = &amp;i;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>在 C++ 中，使用特殊语法来处理指向结构的指针。从技术角度上说，如果指针指向某个结构体，可以先<strong>用 * 对指针进行解除引用，然后使用普通的 . 语法来访问结构中的字段</strong>，以一个名为 getEmployee() 的函数作为示例：</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">Employee* anEmployee = <span class="hljs-built_in">getEmployee</span>();<br><span class="hljs-comment">// getEmployee() 是对 Employee 结构(类)的封装</span><br>std::cout &lt;&lt; (*anEmployee).salary &lt;&lt; endl;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>除此以外，还可以<strong>使用 -&gt; 运算符同时对指针进行解引用并访问字段</strong>：</p><blockquote><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust">Employee* amEmployee = <span class="hljs-title function_ invoke__">getEmployee</span>();<br>std::cout &lt;&lt; anEmployee<span class="hljs-punctuation">-&gt;</span>salary &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure></blockquote></li><li><p><strong>注意：</strong></p><blockquote><p>记住前面所提到的短路逻辑，示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">bool</span> isValidSalary = (anEmployee &amp;&amp; anEmployee-&gt;salary &gt; <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>还可以用以下详细的方式复写：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">bool</span> isValidSalary = (anEmlpoyee != <span class="hljs-literal">null</span>ptr &amp;&amp; anEmployee-&gt;salary &gt; <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>这样，<strong>可以使得仅当 anEmployee 指针有效的时候，才可对其进行解除引用以获取薪水。如果它是一个空指针，则逻辑运算短路，不再解除引用 anEmployee 指针</strong>；</p></blockquote></li></ul></blockquote><h5 id="3-动态分配的数组"><a href="#3-动态分配的数组" class="headerlink" title="3.动态分配的数组"></a>3.<strong>动态分配的数组</strong></h5><blockquote><p>堆也可以用于动态分配数组。<strong>使用 new[] 操作符给数组分配内存</strong>；</p><p><img src="https://bu.dusays.com/2024/03/15/65f44476d358d.png" alt="image-20240204093145571"></p><p>示例：</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> arraySize = <span class="hljs-number">8</span>;<br><span class="hljs-type">int</span>* myVariableSizeArray = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[arraySize];<br></code></pre></td></tr></table></figure><p>指针变量仍在堆栈中，但动态创建的数组在堆中；</p><p>完成这个数组后，应该将其堆中删除，这样其他变量就可以使用这块内存，在 C++ 中，可使用 <strong><code>delete[]</code></strong> 操作符完成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">delete</span> [] myVariableSizeArray;<br>myVariableSizeArray = <span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><blockquote><p>避免使用 C 中的 malloc() 和 free()，而使用 new 和 delete，或者使用 new[] 和 delete[];</p><p><strong><code>delete</code></strong> 后的方括号表明所删除的是一个数组；</p></blockquote></blockquote><p>注意：</p><blockquote><ul><li><p>在 C++ 中，每次调用 <strong><code>new</code></strong> 时，都必须相应地调用 delete；</p></li><li><p>在 C++ 中，每次调用 <strong><code>new []</code></strong> 时，必须相应地调用 **<code>delete []</code>**，以避免内存泄漏；</p></li><li><p>如果未调用 <strong><code>delete</code></strong> 或 **<code>delete []</code>**，或者调用不匹配，会导致内存泄漏。之后会详细讨论内存泄漏；</p></li></ul></blockquote></blockquote><h5 id="4-空指针常量"><a href="#4-空指针常量" class="headerlink" title="4.空指针常量"></a>4.<strong>空指针常量</strong></h5><blockquote><p>在 C++11 之前，常量 NULL 用于表示空指针。将 NULL 定义为常量 0，会导致一些问题，下面给出示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span> <span class="hljs-params">(<span class="hljs-type">char</span>* str)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;char* version&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span> <span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;int version&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">func</span>(<span class="hljs-literal">NULL</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述情况，由于使用的 NULL 指针等价于整数 0，所以调用的是 func 的整数版本，而非指针版本；</p><p>可引入真正的<strong>空指针常量 nullptr</strong> 来解决这个问题，给出代码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">func</span>(<span class="hljs-literal">nullptr</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h5 id="5-智能指针"><a href="#5-智能指针" class="headerlink" title="5.智能指针"></a>5.<strong>智能指针</strong></h5><blockquote><p>为避免常见的内存错误，应使用智能指针代替通常的 C 风格的 “裸” 指针，智能指针对象在<strong>超出作用域</strong>时(例如，在函数执行完毕后)，会<strong>自动释放内存</strong>，在 C++ 中，有两个最重要的智能指针；</p><p><strong>智能指针有时被视为右值引用，一般通过 std::move() 进行右值引用化。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 详见后面关于雇员记录系统设计的内容</span><br><span class="hljs-function">std::unique_ptr&lt;Employee&gt;&amp; <span class="hljs-title">Database::addEmployee</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; firstName,</span></span><br><span class="hljs-params"><span class="hljs-function">                                             <span class="hljs-type">const</span> std::string&amp; lastName)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">auto</span> theEmployee = std::<span class="hljs-built_in">make_unique</span>&lt;Employee&gt;(firstName, lastName);<br> theEmployee-&gt;<span class="hljs-built_in">setEmployeeNumber</span>(mNextEmployeeNumber++);<br> theEmployee-&gt;<span class="hljs-built_in">hire</span>();<br> mEmployees.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(theEmployee));<br><br> <span class="hljs-keyword">return</span> mEmployees[mEmployees.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-function">std::unique_ptr&lt;Employee&gt; <span class="hljs-title">Database::getEmployee</span><span class="hljs-params">(<span class="hljs-type">int</span> employeeNumber)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; employee : mEmployees)<br> &#123;<br>     <span class="hljs-keyword">if</span> (employee-&gt;<span class="hljs-built_in">getEmployeeNumber</span>() == employeeNumber)<br>     &#123;<br>         <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">move</span>(employee);<br>     &#125;<br> &#125;<br> <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">logic_error</span>(<span class="hljs-string">&quot;No employee found.&quot;</span>);<br>&#125;<br><br><span class="hljs-function">std::unique_ptr&lt;Employee&gt; <span class="hljs-title">Database::getEmployee</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; firstName,</span></span><br><span class="hljs-params"><span class="hljs-function">                                             <span class="hljs-type">const</span> std::string&amp; lastName)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; employee : mEmployees)<br> &#123;<br>     <span class="hljs-keyword">if</span> (employee-&gt;<span class="hljs-built_in">getFirstName</span>() == firstName &amp;&amp; employee-&gt;<span class="hljs-built_in">getLastName</span>() == lastName)<br>     &#123;<br>         <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">move</span>(employee);<br>     &#125;<br> &#125;<br> <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">logic_error</span>(<span class="hljs-string">&quot;No employee found.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h6 id="1-std-unique-ptr"><a href="#1-std-unique-ptr" class="headerlink" title="1.std::unique_ptr"></a>1.std::unique_ptr</h6><blockquote><ul><li><p><strong><code>std::make_unique&lt;elementType&gt;()</code></strong></p></li><li><p><strong>数组，允许：<code>std::make_unique&lt;elementType[]&gt;(listSize)</code></strong></p></li><li><p><strong><code>std::unique_ptr&lt;elementType&gt; elementName (new elementType);</code></strong></p></li><li><p><strong>数组，允许：<code>std::unique_ptr&lt;elementType[]&gt; elementName (new elementType[listSize]);</code></strong></p></li><li><p><strong><code>std::unique_ptr </code></strong> 类似于普通指针，但在它超出作用域或者被删除时，会自动释放内存或资源。**<code>std::unique_ptr</code>** 只属于它指向的对象。它的优点是：内存和资源始终被释放，即使执行返回语句或抛出异常(见稍后的讨论)。这极大地简化了代码，例如，如果有一个函数有多个返回语句，可以不必记着每个返回语句前释放资源。</p></li><li><p>要创建 **<code>std::unique_ptr</code>**，应当使用 **<code>std::make_unique&lt;&gt;()</code>**，例如，不要编写以下代码：</p></li></ul><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">Employee* anEmployee = <span class="hljs-keyword">new</span> Employee;<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">delete</span> anEmployee;<br></code></pre></td></tr></table></figure></blockquote><ul><li>而应当编写以下代码：</li></ul><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> anEmployee = std::<span class="hljs-built_in">make_enique</span>&lt;Employee&gt;();<br><br><span class="hljs-comment">// 关于 () 内参数设定，示例：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br> <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> value1, <span class="hljs-type">double</span> value2);<br> <span class="hljs-comment">// Other members...</span><br>&#125;;<br><span class="hljs-keyword">auto</span> myObject = std::<span class="hljs-built_in">make_unique</span>&lt;MyClass&gt;(<span class="hljs-number">42</span>, <span class="hljs-number">3.14</span>);<br></code></pre></td></tr></table></figure></blockquote><ul><li><p>注意，这样一来，将不再需要调用 delete，因为这将自动完成。本章后面的类型推断将详细讲解 auto 关键字(这里先不详细说明)。这里只需要了解，auto 关键字告诉编译器自动推断变量的类型，因此你不必手动指定完整类型；</p></li><li><p>std::unique_ptr 是一个通用的智能指针，他可以指向任意类型的内存，所以，它本质上是一个模板。模板需要尖括号来指定模板类型参数。在尖括号中必须指定 unique_ptr 要指向的内存类型。模板详见第12章、第22章，而智能指针在本书开头介绍，可见，事实上，它们使用起来很简单；</p></li><li><p>make_unique() 在 C++14 中被引入，如果用户编译器与 C++14 不兼容，可使用如下形式的 unique_ptr(注意，现在必须将 Employee 类型指定两次)：</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::unique_ptr&lt;Employee&gt; <span class="hljs-title">anEmployee</span> <span class="hljs-params">(<span class="hljs-keyword">new</span> Employee)</span></span>;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>可以像普通指针那样使用 anEmployee 智能指针，例如：</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span> (anEmployee)<br>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Salary: &quot;</span> &lt;&lt; anEmployee-&gt;salary &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>此外，<strong>unique_ptr</strong> 也可以储存 C 风格的数组，下例创建了一个包含 10 个 Employee 示例的数组，将其存储在 <strong>unique_ptr</strong> 中，并显示如何访问数组中的元素：</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> employees = std::<span class="hljs-built_in">make_unique</span>&lt;Employee[]&gt;(<span class="hljs-number">10</span>);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Salary: &quot;</span> &lt;&lt; employees[<span class="hljs-number">0</span>].salary &lt;&lt; std::endl;<br><br><span class="hljs-comment">// 使用 C 风格的不兼容处理</span><br><span class="hljs-function">std::unique_ptr&lt;Employee[]&gt; <span class="hljs-title">employees</span><span class="hljs-params">(<span class="hljs-keyword">new</span> Employee[<span class="hljs-number">10</span>])</span></span>;<br></code></pre></td></tr></table></figure></blockquote><ul><li><p>辨析：</p><blockquote><ol><li><p>上面的代码使用 <strong><code>anEmployee-&gt;salary</code></strong> 而非**<code>anEmployee.salary</code><strong>，是因为</strong><code>anEmployee</code>** 是一个指向 <strong><code>Employee</code></strong> 对象的 **<code>unique_ptr</code>**，而不是直接的对象，-&gt; 的作用是解引用并访问成员，. 的作用是访问成员；</p></li><li><p>下面的代码使用**<code> employees[0].salary</code>** 而非 <strong><code> employees[0]-&gt;salary</code></strong> ，因为，**<code>employees</code>** 是一个指向动态分配数组的 <strong><code>std::unique_ptr</code></strong> ，可见，[] 符能起到解引用的作用，. 的作用认识访问成员；</p></li></ol></blockquote></li></ul></li></ul></blockquote><h6 id="2-std-shared-ptr"><a href="#2-std-shared-ptr" class="headerlink" title="2.std::shared_ptr"></a>2.<strong>std::shared_ptr</strong></h6><blockquote><ul><li><p><strong><code>std::make_shared&lt;elementType&gt;()</code></strong></p></li><li><p><strong>数组，不允许：<code>std::make_shared&lt;elementType[]&gt;(listSize)</code></strong></p></li><li><p><strong><code>std::shared_ptr&lt;elementType&gt; elementName (new elementType);</code></strong></p></li><li><p><strong>数组，仅允许：<code>std::shared_ptr&lt;elementType[]&gt; elementName (new elementType[listSize]);</code></strong></p></li><li><p><strong><code>std::shared_ptr</code></strong> 允许数据的分布式“所有权”，每次指定 <strong><code>std::shared_ptr</code></strong> 时，都递增一个引用计数，指出数据又多出了一位“拥有者”。当它超出作用域时，就递减引用计数，当引用计数为 0 时，就表示数据不再拥有任何拥有者，于是释放指针引用的对象；</p></li><li><p>要创建 **<code>std::shared_ptr</code>**，应当使用 <strong><code>std::make_shared&lt;&gt;()</code><strong>，它与</strong><code>std::make_unique&lt;&gt;()</code></strong>:</p></li></ul><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> anEmployee = std::<span class="hljs-built_in">make_unique</span>&lt;Employee&gt;();<br><span class="hljs-keyword">if</span> (anEmployee)<br>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Salary: &quot;</span> &lt;&lt; anEmployee-&gt;salary &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><ul><li>从 C++17 开始，也可以将数组存储在 <strong><code>std::shared_ptr</code></strong> 中，而旧版的 C++ 是不允许的。但注意，此时不能使用 C++17 中的 **<code>make_shared&lt;&gt;()</code>**，示例：</li></ul><blockquote><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">std</span>::shared_ptr&lt;Employee[]&gt; employees(<span class="hljs-built_in">new</span> Employee[<span class="hljs-number">10</span>]);<br><span class="hljs-built_in">std</span>::cout &lt;&lt; <span class="hljs-string">&quot;Salary: &quot;</span> &lt;&lt; employees[<span class="hljs-number">0</span>].salary &lt;&lt; <span class="hljs-built_in">std</span>::endl;<br></code></pre></td></tr></table></figure></blockquote></blockquote><p>​第七章将详细阐述内存管理和智能指针，但由于 <strong>std::unique_ptr</strong> 和 <strong>std::shared_ptr</strong> 的基本用法十分简单，所以，在这里阐述；</p><h6 id="3-注意"><a href="#3-注意" class="headerlink" title="3.注意"></a>3.<strong>注意</strong></h6><blockquote><ul><li><p><strong>普通的裸指针仅允许在不涉及所有权时使用，否则默认使用  <code>std::unique_ptr</code>；</strong></p></li><li><p><strong>如果有需要共享所有权，就使用  <code>std::shared_ptr</code>；</strong></p></li><li><p><strong>如果知道 <code>auto_ptr</code>，应当忘记它，因为 C++ 11&#x2F;14 不赞成使用它，而 C++17 已经废弃它；</strong></p></li><li><p><strong>如果第二种表示法：<code>std::XXX_ptr&lt;elementType&gt; elementName (new elementType);</code>中构造函数抛出异常，那么就会出现内存泄漏</strong></p></li></ul></blockquote><hr><h4 id="2-3const-的多种用法"><a href="#2-3const-的多种用法" class="headerlink" title="2.3const 的多种用法"></a><strong>2.3const 的多种用法</strong></h4><blockquote><p>可以使用 auto 来去除 const 函数性质</p></blockquote><h5 id="1-使用-const-定义常量"><a href="#1-使用-const-定义常量" class="headerlink" title="1.使用 const 定义常量"></a>1.<strong>使用 const 定义常量</strong></h5><blockquote><ul><li><p>在 C 中，通常使用预处理器的 #define 机制来声明一个符号名称，其值在程序执行时不会改变；</p></li><li><p>在 C++ 中，鼓励使用 const 代替 #define 定义常量，使用 const 定义常量就像定义变量一样，只是编译器保证代码不会改变这个值；</p></li><li><p>示例：</p><blockquote><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">const</span> <span class="hljs-type">int</span> versionNumberMajor = <span class="hljs-number">2</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> versionNumberMinor = <span class="hljs-number">1</span>;<br><span class="hljs-type">const</span> std::string productName = <span class="hljs-string">&quot;Super Hyper Net Modulator&quot;</span>;<br></code></pre></td></tr></table></figure></blockquote></li></ul></blockquote><h5 id="2-使用-const-保护参数"><a href="#2-使用-const-保护参数" class="headerlink" title="2.使用 const 保护参数"></a>2.<strong>使用 const 保护参数</strong></h5><blockquote><ul><li><p>在 C++ 中，可将非 const 变量转换为 const 变量，这可以提供一定保护，防止其他代码修改变量。如果程序试图改变参数的值，编译不会完成；</p></li><li><p>示例：</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mysteryFunction</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string* someString)</span></span><br><span class="hljs-function"></span>&#123;<br>*someString = <span class="hljs-string">&quot;Test&quot;</span>;<br><span class="hljs-comment">// Will not complie</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::string myString = <span class="hljs-string">&quot;The string&quot;</span>;<br><span class="hljs-built_in">mysteryFunction</span>(&amp;myString);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li></ul></blockquote><hr><h4 id="2-4引用"><a href="#2-4引用" class="headerlink" title="2.4引用"></a><strong>2.4引用</strong></h4><blockquote><ul><li>C++ 允许使用给已有变量定义另一个名称：</li></ul><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x = <span class="hljs-number">42</span>;<br><span class="hljs-type">int</span>&amp; xReference = x;<br>std::cout &lt;&lt; xReference;<br><br><span class="hljs-comment">// 对比上下两者的不同</span><br><span class="hljs-type">int</span>* xPointer = &amp;x;<br>std::cout &lt;&lt; *xPointer;<br></code></pre></td></tr></table></figure><p>给类型附加 &amp;，则指示相应的变量是引用。在幕后他是一个指向原始变量的指针；</p></blockquote></blockquote><h5 id="1-按引用传递"><a href="#1-按引用传递" class="headerlink" title="1.按引用传递"></a><strong>1.按引用传递</strong></h5><blockquote><p>区别于值传递(制作副本)，不会改变原始变量的值；</p><p>按引用传递参数是引用而非指针，在执行函数时，会改变原始变量的值；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 传值版本</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addOne</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>i++;<br><span class="hljs-comment">// Has no real effect because this is a copy of the original</span><br>&#125;<br><br><span class="hljs-comment">// 传引用版本</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addOne</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; i)</span></span><br><span class="hljs-function"></span>&#123;<br>i++;<br><span class="hljs-comment">// Actually change the original variable</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><blockquote><p>对于两个版本的 addOne() 函数：</p><p>当前者传入字面量时，是可行的；</p><p>当后者传入字面量时，会导致编译错误；</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">addOne</span>(<span class="hljs-number">3</span>);<br><span class="hljs-comment">// 这对后者来说需要改变 3 的值，显然是不可能的</span><br><span class="hljs-comment">// 此外，还可以通过右值引用来解决，这将在之后讨论</span><br></code></pre></td></tr></table></figure></blockquote><p>此外，在 C++11 之前推荐使用这种非 const 引用，但 C++11 开始，再也不这么做了，因为存在了 move 语义(之后讨论)；</p></blockquote><h5 id="2-按-const-引用传递"><a href="#2-按-const-引用传递" class="headerlink" title="2.按 const 引用传递"></a><strong>2.按 const 引用传递</strong></h5><blockquote><p>由于制作副本，代价较大，所以，使用不改变值的引用传递，示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printString</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; myString)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; myString &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::string someString = <span class="hljs-string">&quot;Hello World&quot;</span>;<br><span class="hljs-built_in">printString</span>(someString);<br><span class="hljs-built_in">printString</span>(<span class="hljs-string">&quot;Hello World&quot;</span>);<span class="hljs-comment">// Passing literals works</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h5 id="3-注意-1"><a href="#3-注意-1" class="headerlink" title="3.注意"></a><strong>3.注意</strong></h5><blockquote><p>如需要给函数传递对象，最好按 const 引用(而非值)传递，这样可以防止多余复制；</p><p>如果需要修改对象，则为其传递非 const 引用；</p></blockquote><hr><h4 id="2-5异常"><a href="#2-5异常" class="headerlink" title="2.5异常 &amp; "></a><strong>2.5异常 &amp; <stdexcept></strong></h4><blockquote><ul><li><p><strong>C++是一种非常灵活的语言，但并不是非常安全</strong>，编译器通编写改变随机内存地址或尝试除以 0  的代码(计算机无法处理无穷大的数值)。<strong>异常就是试图增加一点安全性的语言特性；</strong></p></li><li><p>异常是一种无法预料的情形，例如如果编写一个获取web页面的函数 ，就有几件事可能出错，包含页面的 Internet 主机可能被关闭，页面可能是空白的，或者连接可能会丢失。处理这种情况的一种方法是从函数返回特定的值，如 nullptr 或其他错误代码。异常提供了处理此类问题的更好方法；</p></li><li><p>一场伴随着一些新的术语。当某段代码检测到异常时就会抛出一个异常，另一段代码会捕捉这个异常并执行恰当的操作。 下例给出一个名为 divideNumber() 的函数，如果调用者传递给分母的值为0，就会抛出一个异常。使用 <strong><code>std::invalid_arugment</code></strong> 时需要**<code> &lt;stdexcept&gt;</code>**:</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">divideNumbers</span><span class="hljs-params">(<span class="hljs-type">double</span> numerator, <span class="hljs-type">double</span> denominator)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (denominator == <span class="hljs-number">0</span>)<br> &#123;<br>     <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Denominator cannot be 0.&quot;</span>);<br>     <span class="hljs-comment">// 此处为抛出异常</span><br>     <span class="hljs-comment">// 详细内容将在异常章节讲述</span><br> &#125;<br> <span class="hljs-keyword">return</span> numerator / denominator;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>当执行 throw 行时，程序会立即结束而且不会返回值。</strong>如果调用者将函数调用放到 try &#x2F; catch块中就可以辅助捕获异常并进行处理，示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">try</span> <br>&#123;<br>std::cout &lt;&lt; <span class="hljs-built_in">divideNumbers</span>(<span class="hljs-number">2.5</span>, <span class="hljs-number">0.5</span>) &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-built_in">divideNumbers</span>(<span class="hljs-number">2.3</span>, <span class="hljs-number">0</span>) &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-built_in">divideNumbers</span>(<span class="hljs-number">4.5</span>, <span class="hljs-number">2.5</span>) &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::invalid_argument&amp; exception)<br>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Expression caught: &quot;</span> &lt;&lt; exception.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><strong>第一次调用 divideNumbers() 成功执行，结果会输出给用户；</strong></p></li><li><p><strong>第二次调用 divideNumbers() 会抛出一个异常，不会返回值，唯一的输出是捕获异常时输出的错误信息；</strong></p></li><li><p><strong>第三次调用 根本不会执行，因为第二次调用抛出了一个异常，导致程序跳转到 catch 块；</strong></p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-number">5</span><br>Expression caught: Denominator cannot be <span class="hljs-number">0.</span><br></code></pre></td></tr></table></figure></blockquote></li></ul></blockquote></li><li><p><strong>C++ 的异常非常灵活，为了正确使用异常，需要理解抛出异常时堆栈变量的行为，必须正确捕获并处理必要的异常</strong>。前面的示例中使用了内建的 **<code>std::invalid_argument </code>**类型，但最好根据所抛出的具体错误编写自己的异常类型。最后，C++ 编译器并不强制要求捕获可能发生的所有异常。如果代码从不捕获任何异常，但有异常抛出，程序自身会捕获异常并终止。第14章将进一步讨论异常的这些更复杂方面；</p></li></ul></blockquote><h4 id="2-6类型推断"><a href="#2-6类型推断" class="headerlink" title="2.6类型推断"></a><strong>2.6类型推断</strong></h4><blockquote><ul><li><strong>类型推断允许编译器自动推断出表达式的类型。类型推断有两个关键词 auto 和 decltype;</strong></li></ul></blockquote><h5 id="1-关键字-auto"><a href="#1-关键字-auto" class="headerlink" title="1.关键字 auto"></a>1.<strong>关键字 auto</strong></h5><blockquote><p><strong>多种完全不同的含义：</strong></p><ul><li><p>推断函数的返回类型如前所述结构化绑定，如前所述；</p></li><li><p>推断表达式的类型，如前所述；</p></li><li><p>推断非类型模板参数的类型，见第12章；</p></li><li><p>decltype(auto)，见第12章；</p></li><li><p>其他函数语法，见第12章。</p></li><li><p>通用 Lambda 表达式，见第18章；</p><blockquote><ul><li><p>auto 可用于告诉编译器在编译时自动推断变量的类型。下面的代码演示了在这种情况下关键字 auto 最简单的用法： </p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> x =<span class="hljs-number">123</span>;<br><span class="hljs-comment">// x will be of type int </span><br></code></pre></td></tr></table></figure><p>在这个示例中输入 auto 和输入 int 的效果没有区别，但 auto 对于较复杂的类型会更有用。假定 getFoo() 函数有一个复杂的返回类型。如果希望把调用该函数的结果赋予一个变量,就可以输入该复杂类型，也可以简单的使用 auto 让编译器推断出该类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> result = <span class="hljs-built_in">getFoo</span>();<br></code></pre></td></tr></table></figure><p>这样，你可以方便地更改函数的返回类型，而不需要更新代码中调用该函数的所有位置；</p></blockquote></li><li><p>但使用 auto 去除了引用和 const 限定符号。假设有以下函数：</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-type">const</span> std::string message = <span class="hljs-string">&quot;Test&quot;</span>;<br><br><span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">foo</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> message;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以调用 Foo()，把结果存储在一个变量中，将该变量的类型指定为auto，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> f1 = <span class="hljs-built_in">foo</span>();<br></code></pre></td></tr></table></figure><p>因为 auto 去除了引用和 const 限定符，且 f1 是 string 类型，所以建立一个副本。如果希望 f1 是一个 const 引用，就可以明确将它建立为一个引用，并标记为 const 如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; f2 = <span class="hljs-built_in">foo</span>();<br><br><span class="hljs-comment">// 补充</span><br>std::cout &lt;&lt; <span class="hljs-built_in">typeid</span>(element).<span class="hljs-built_in">name</span>();<br><span class="hljs-comment">// 为 type_info 类型   </span><br><br>或者<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;typeindex&gt;</span><span class="hljs-comment">// 必需 &lt;typeindex&gt;</span></span><br>std::cout &lt;&lt; std::<span class="hljs-built_in">type_index</span>(<span class="hljs-built_in">typeid</span>(element)).<span class="hljs-built_in">name</span>();<br><span class="hljs-comment">// 为与 type_info 类似的类，但提供了比 type_info 更好的比较和哈希功能</span><br></code></pre></td></tr></table></figure></blockquote></li><li><p><strong>注意</strong>：</p><blockquote><p><strong>始终要记住，auto 去除了引用和 const 限定符，从而会创建副本！如果不需要副本，可使用 auto&amp; 或 const auto&amp;；</strong></p></blockquote></li></ul></blockquote></li></ul></blockquote><h5 id="2-关键字-decltype"><a href="#2-关键字-decltype" class="headerlink" title="2.关键字 decltype"></a>2.<strong>关键字 decltype</strong></h5><blockquote><p><strong>关键词 decltype 把表达式作为实参，计算出该表达式的类型</strong>，示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> x = <span class="hljs-number">123</span>;<br><span class="hljs-keyword">decltype</span>(x) y = <span class="hljs-number">456</span>;<br></code></pre></td></tr></table></figure><p>在这个示例中，<strong>编译器会推断出 y 的类型是 int，因为这是 x 的类型；</strong></p><p><strong>auto 与 decltype 的区别在于，decltype 未除引用和 const 限定符。再来分析返回 const string引用的 foo() 函数。按照如下方式使用 decltype 定义 f2，导致 f2 的类型为 const string&amp;，从而不生成副本：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">decltype</span>(<span class="hljs-built_in">foo</span>()) f2 = <span class="hljs-built_in">foo</span>();<br></code></pre></td></tr></table></figure><p>刚开始不会觉得 decltype 有多大价值。但<strong>在模板环境中，decltype 会变得十分强大</strong>，详见第12 和第 22 章；</p></blockquote><hr><h3 id="1-3-作为面向对象语言的-C"><a href="#1-3-作为面向对象语言的-C" class="headerlink" title="1.3    作为面向对象语言的 C++"></a><strong>1.3    作为面向对象语言的 C++</strong></h3><hr><ul><li>如果你是一位 C 程序员，可能会认为本章讲述的内容到目前为止只是传统 C 语言的补充最好顾名思义，C++语言在很多方面只是“更好的C”。这种观点忽略了一个重点：与 C 不同 C++ 是一种面向对象的语言；</li><li><strong>面向对象程序设计 <em>(OPP)</em></strong> 是一种完全不同的、更趋自然的编码方式。如果习惯使用过程语言，如 C 或者 Pascal，不要担心。第五章的讲述将观念转换到面向对象范型所需的所有背景知识。如果你已经了解OPP的理论，下面的内容将帮助你加速了解 (或者回顾) 基本的 C++ 对象语法；</li></ul><h4 id="3-1定义类"><a href="#3-1定义类" class="headerlink" title="3.1定义类"></a><strong>3.1定义类</strong></h4><blockquote><ul><li><p><strong>类定义了对象的特征。在 C++ 中，类通常在头文件 (.h) 中声明，在对应的源文件 (.cpp) 中定义其并 非内联 方式和静态数据成员；</strong></p></li><li><p>下面示例定义了一个基本的<strong>机票类</strong>，这个类可根据飞行的里程数以及顾客是不是“精英超级奖励计划”的成员计算票价。这个定义<strong>首先声明一个类名</strong>，在大括号内声明了类的数据成员(属性)以及方法(行为)。 每个数据成员以及方法都具有特定的访问级别：<strong>public</strong>、<strong>protected</strong> 或 <strong>private</strong>。这些标记可按任意顺序出现，也可重复使用。<strong>public 成员可在类的外部访问，private 成员不能在类的外部访问，推荐把所有的数据成员都声明为 private,在需要时，可通过 public 读取器和设置器来访问它们。</strong>  <strong>这样，就很容易改变数据的表达方式，同时使 public 接口保持不变。</strong>关于 protected 的用法，将在第 5 和 10 章中介绍“继承”时讲解。</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// AirlineTicket.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AirlineTicket</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br> <span class="hljs-comment">// 构造类</span><br> <span class="hljs-built_in">AirlineTicket</span>();<br><br> <span class="hljs-comment">// 析构类</span><br> ~<span class="hljs-built_in">AirlineTicket</span>();<br><br> <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">calculatePriceInDollars</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br> <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getPassengerName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setPassageName</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name)</span></span>;<br><br> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getNumberOfMiles</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setNumberOfMiles</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> miles)</span></span>;<br><br> <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasEliteSuperRewardsStatus</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setHasEliteSuperRewardsStatus</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">bool</span> status)</span></span>;<br><span class="hljs-keyword">private</span>:<br> std::string mPassengerName;<br> <span class="hljs-type">int</span> mNumberOfMiles;<br> <span class="hljs-type">bool</span> mHasEliteSuperRewardsStatus;<br>&#125;;<br><br><span class="hljs-comment">// 约定：在类的每个数据成员之前加上小写字母 m, 如 mPassengefName</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><blockquote><p><strong>为遵循 const 正确性原则，最好将不改变对象的任何数据成员的成员函数声明为 const。相对于非 const 成员函数“修改器”，这些成员函数也称为 “检测器”。</strong></p></blockquote><ul><li><strong>构造函数的初始化：</strong></li></ul><ol><li><p><strong>更推荐的</strong>，使用<strong>构造函数初始化器</strong><em><strong>(constructor initializer)</strong></em></p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 构造函数</span><br><span class="hljs-comment">// AirlineTicket.h</span><br><span class="hljs-comment">// 推荐使用构造函数初始化器</span><br>AirlineTicket::<span class="hljs-built_in">AirlineTicket</span>()<br> : <span class="hljs-built_in">mPassengerName</span>(<span class="hljs-string">&quot;Unknown Passenger&quot;</span>)<br> , <span class="hljs-built_in">mNumberOfMiles</span>(<span class="hljs-number">0</span>)<br> , <span class="hljs-built_in">mHasEliteSuperRewardsStatus</span>(<span class="hljs-literal">false</span>)<br>&#123;<br>&#125;  <br></code></pre></td></tr></table></figure></blockquote></li><li><p><strong>将初始化任务放在构造函数体内</strong></p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// AirlineTicket.h</span><br>AirlineTicket::<span class="hljs-built_in">AirlineTicket</span>()<br>&#123;<br><span class="hljs-comment">//Initialize data member</span><br>mPassengerName = <span class="hljs-string">&quot;Unknown Passsenger&quot;</span>;<br>mNumberOfMiles = <span class="hljs-number">0</span>;<br>mHasEliteSuperRewardsStatus = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li></ol><ul><li><p>如果构造函数只是初始化数据成员，而不做其他事情，实际上就没必要使用构造函数，因为可在类定义中直接初始化数据成员。例如，不编写 AirlineTicket 构造函数，而是修改类定义中数据成员的定义，如下所示：  </p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// AirlineTicket.h</span><br><span class="hljs-keyword">private</span>:<br>std::string nPassengerName = <span class="hljs-string">&quot;Unknown Passenger&quot;</span>;<br><span class="hljs-type">int</span> mNumberOfMiles = <span class="hljs-number">0</span>;<br><span class="hljs-type">bool</span> mHasEliteSuperRewardsStatus = <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><p>如果类还需要执行其他的一些初始化类型，如打开文件、分配内存等，则需要编写构造函数进行处理；</p></blockquote></li><li><p><strong>析构函数</strong></p><blockquote><p>如下所示，为 AirlineTicket 类的析构函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">AirlineTicket::~<span class="hljs-built_in">AirlineTicket</span>()<br>&#123;<br> <span class="hljs-comment">// Nothing much to do in terms of cleanup</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个析构函数什么都不做，因此可以从类中删除，这里之所以需要显示它，是为了更好了解析构函数的语法；如果需要执行一些清理，如关闭文件、释放内存等，则需要使用析构函数；</p></blockquote></li><li><p><strong>AirlinTicket 的其他类方法</strong></p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// AirlineTicket.cpp</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">AirlineTicket::calculatePriceInDollars</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">hasEliteSuperRewardsStatus</span>())<br> &#123;<br>     <span class="hljs-comment">// Elite Super Rewards customers fly for free</span><br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br> &#125;<br> <span class="hljs-comment">// The cost of the ticket is the number of mile times 0.1.</span><br> <span class="hljs-comment">// Real airlines probably have a more complicated formula!</span><br> <span class="hljs-keyword">return</span> <span class="hljs-built_in">getNumberOfMiles</span>() * <span class="hljs-number">0.1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">AirlineTicket::getPassengerName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">return</span> mPassengerName;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AirlineTicket::setPassengerName</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; name)</span></span><br><span class="hljs-function"></span>&#123;<br> mPassengerName = name;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">AirlineTicket::getNumberOfMiles</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">return</span> mNumberOfMiles;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AirlineTicket::setNumberOfMiles</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> miles)</span></span><br><span class="hljs-function"></span>&#123;<br> mNumberOfMiles = miles;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">AirlineTicket::hasEliteSuperRewardsStatus</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">return</span> mHasEliteSuperRewardsStatus;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">AirlineTicket::setHasEliteSuperRewardsStatus</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">bool</span> status)</span></span><br><span class="hljs-function"></span>&#123;<br> mHasEliteSuperRewardsStatus = status;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li></ul></blockquote></li></ul></blockquote><h4 id="3-2使用类"><a href="#3-2使用类" class="headerlink" title="3.2使用类"></a><strong>3.2使用类</strong></h4><blockquote><p>下面示例程序给出了如何使用 AirlineTicket 类。这个示例创建的两个 AirlineTicket 对象分别给予堆栈和堆：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// testAirlineTicket.cpp</span><br><br><span class="hljs-comment">// Stack-based(堆栈) AirlineTicket</span><br><span class="hljs-comment">// 优点：</span><br><span class="hljs-comment">//    1.简单直观，不需要动态内存管理。</span><br><span class="hljs-comment">// 缺点：</span><br><span class="hljs-comment">//    1.对象的生命周期受限于其所在的作用域，一旦超出作用域，对象将被销毁。</span><br>AirlineTicket myTicket;<br>myTicket.<span class="hljs-built_in">setPassengerName</span>(<span class="hljs-string">&quot;Sherman T. Socketwrench&quot;</span>);<br>myTicket.<span class="hljs-built_in">setNumberOfMiles</span>(<span class="hljs-number">700</span>);<br><span class="hljs-type">double</span> cost = myTicket.<span class="hljs-built_in">calculatePriceInDollars</span>();<br>std::cout &lt;&lt; <span class="hljs-string">&quot;This ticket will cost $&quot;</span> &lt;&lt; cost &lt;&lt; std::endl;<br><span class="hljs-comment">/*--------------------------------------------------------------------------*/</span><br><br><span class="hljs-comment">// Heap-based(堆) AirlineTicket with smart pointer</span><br><span class="hljs-comment">// 推荐，使用</span><br><span class="hljs-comment">// 优点：</span><br><span class="hljs-comment">//    1.动态分配的内存由 std::unique_ptr 管理，无需手动释放内存。</span><br><span class="hljs-comment">//    2.可以更灵活地控制对象的生命周期</span><br><span class="hljs-comment">// 缺点：</span><br><span class="hljs-comment">//    1.相对于栈上创建，略微复杂</span><br><span class="hljs-keyword">auto</span> myTicket2 = std::<span class="hljs-built_in">make_unique</span>&lt;AirlineTicket&gt;();<br>myTicket2-&gt;<span class="hljs-built_in">setPassengerName</span>(<span class="hljs-string">&quot;Laudimore M. Hallidue&quot;</span>);<br>myTicket2-&gt;<span class="hljs-built_in">setNumberOfMiles</span>(<span class="hljs-number">2000</span>);<br>myTicket2-&gt;<span class="hljs-built_in">setHasEliteSuperRewardsStatus</span>(<span class="hljs-literal">true</span>);<br><span class="hljs-type">double</span> cost2 = myTicket2-&gt;<span class="hljs-built_in">calculatePriceInDollars</span>();<br>std::cout &lt;&lt; <span class="hljs-string">&quot;This other ticket will cost $&quot;</span> &lt;&lt; cost2 &lt;&lt; std::endl;<br><span class="hljs-comment">// No need to delete myTicket2, happens automatically</span><br><span class="hljs-comment">/*--------------------------------------------------------------------------*/</span><br><br><span class="hljs-comment">// Heap-based AirlineTicket without smart pointer (not recommended)</span><br><span class="hljs-comment">// 不推荐，也不要使用</span><br><span class="hljs-comment">// 优点：</span><br><span class="hljs-comment">//    1.可以手动控制对象的生命周期。</span><br><span class="hljs-comment">// 缺点：</span><br><span class="hljs-comment">//    1.容易出现内存泄漏或释放已删除的内存，因为没有智能指针进行内存管理。</span><br><span class="hljs-comment">//    2.必须手动调用 delete 来释放内存，容易出现忘记释放或者释放多次的问题。</span><br>AirlineTicket* myTicket3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AirlineTicket</span>();<br><span class="hljs-comment">// ... Use ticket 3</span><br><span class="hljs-keyword">delete</span> myTicket3;<br></code></pre></td></tr></table></figure></blockquote><hr><h3 id="1-4-统一初始化"><a href="#1-4-统一初始化" class="headerlink" title="1.4    统一初始化"></a><strong>1.4    统一初始化</strong></h3><h5 id="1-结构与类的初始化"><a href="#1-结构与类的初始化" class="headerlink" title="1.结构与类的初始化"></a><strong>1.结构与类的初始化</strong></h5><blockquote><h5 id="在-C-之前，初始化类型并非总是统一的。例如，考虑下面的两个定义，其中一个作为结构，另一个作为类，示例："><a href="#在-C-之前，初始化类型并非总是统一的。例如，考虑下面的两个定义，其中一个作为结构，另一个作为类，示例：" class="headerlink" title="在 C++之前，初始化类型并非总是统一的。例如，考虑下面的两个定义，其中一个作为结构，另一个作为类，示例："></a><strong>在 C++之前，初始化类型并非总是统一的。例如，考虑下面的两个定义，其中一个作为结构，另一个作为类，示例：</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">CircleStruct</span><br>&#123;<br><span class="hljs-type">int</span> x, y;<br><span class="hljs-type">double</span> radius;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CircleClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 使用成员初始化列表可以提高性能</span><br><span class="hljs-built_in">CircleClass</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">double</span> radius)<br>      : <span class="hljs-built_in">mX</span>(x), <span class="hljs-built_in">mY</span>(y), <span class="hljs-built_in">mRadius</span>(radius)<br>   &#123;<br><br>   &#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">CircleClass(int x = 1, int y = 1, double radius = 3)</span><br><span class="hljs-comment">: mX(x), mY(y), mRadius(radius)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">// 这样实现默认值填充</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> mX, mY;<br><span class="hljs-type">double</span> mRadius;<br>&#125;;<br><br><span class="hljs-comment">// 复写 Circle 类，使之更符合现代 C++ 关于默认初始变量设置的通常做法</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CircleClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br> <span class="hljs-built_in">Circle</span>() = <span class="hljs-keyword">default</span>;<br><span class="hljs-comment">// 使用成员初始化列表可以提高性能</span><br><span class="hljs-built_in">CircleClass</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, <span class="hljs-type">double</span> radius)<br>      : <span class="hljs-built_in">mX</span>(x), <span class="hljs-built_in">mY</span>(y), <span class="hljs-built_in">mRadius</span>(radius)<br>   &#123;<br><br>   &#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> mX = <span class="hljs-number">1</span>;<br> <span class="hljs-type">int</span> mY = <span class="hljs-number">1</span>;<br><span class="hljs-type">double</span> mRadius = <span class="hljs-number">3</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>在 C++11 之前，CircleStruct 类型变量和CircleClass 类型变量的初始化是不同的，对于结构版本，可使用 {…} 语法。然而，对于类版本，需要使用函数符号 (…) 调用构造函数。  ：</strong>  </p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">CircleStruct myCirclel = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2.5</span>&#125;;<br><span class="hljs-function">CircleClass <span class="hljs-title">myCircle2</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2.5</span>)</span></span>;<br></code></pre></td></tr></table></figure></blockquote><p><strong>自 C++11 以后，允许一律使用 {… }语法初始化类型，如下所示：</strong>  </p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">CircleStruct myCircle3 = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2.5</span>&#125;;<br>CircleClass myCircle4 = &#123;<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2.5</span>&#125;;<br></code></pre></td></tr></table></figure><p><strong>定义 myCircle4 时将自动调用 CircleClass 的构造函数。甚至等号也是可选的，因此下面的代码与前面的代码等价：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">CircleStruct myCircle5&#123;<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2.5</span>&#125;;<br>CircleClass myCircle6&#123;<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2.5</span>&#125;;<br></code></pre></td></tr></table></figure></blockquote><p><strong>统一初始化并不局限于结构和类</strong>，<strong>它可以用于初始化 C++ 中的任何内容</strong>，示例：</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 均将变量初始化为 3</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">3</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>;<br><span class="hljs-type">int</span> c = &#123;<span class="hljs-number">3</span>&#125;;<br><span class="hljs-type">int</span> d&#123;<span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure></blockquote></blockquote><h5 id="2-默认统一初始化："><a href="#2-默认统一初始化：" class="headerlink" title="2.默认统一初始化："></a>2.<strong>默认统一初始化</strong>：</h5><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 示例</span><br><br><span class="hljs-comment">// 对于基本整型</span><br><span class="hljs-type">char</span>、<span class="hljs-type">int</span>-&gt;<span class="hljs-number">0</span><br>ptr-&gt;nullprt<br><br><span class="hljs-comment">// 为此只需要指定一系列空大括号</span><br><span class="hljs-type">int</span> e&#123;&#125;;<span class="hljs-comment">// Uniform initialization，e will be 0</span><br></code></pre></td></tr></table></figure></blockquote><h5 id="3-阻止窄化-narrowing"><a href="#3-阻止窄化-narrowing" class="headerlink" title="3.**阻止窄化 (narrowing) **"></a>3.**阻止窄化 <em>(narrowing)</em> **</h5><p>​<strong>一般情况下，C++ 隐式地执行窄化，但存在部分编译器报错，部分不报错的情况，为解决不统一问题</strong>，示例：</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">/*...*/</span>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> x = <span class="hljs-number">3.14</span>;<br><span class="hljs-built_in">func</span>(<span class="hljs-number">3.14</span>);<br><span class="hljs-comment">// 上面两种情况窄化，将 3.14 截取成为 3</span><br><span class="hljs-comment">// 对于窄化，部分编译器报错，部分不报</span><br><span class="hljs-comment">// 但是，使用 统一初始化 则都会生成编译错误</span><br>&#125;<br><br><span class="hljs-comment">// 替换为：</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span><br><span class="hljs-function"></span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> x = &#123;<span class="hljs-number">3.14</span>&#125;; <span class="hljs-comment">// Error because narrowing</span><br><span class="hljs-built_in">func</span>(&#123;<span class="hljs-number">3.14</span>&#125;); <span class="hljs-comment">// Error because narrowing</span><br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h5 id="4-其他类型的统一初始化"><a href="#4-其他类型的统一初始化" class="headerlink" title="4.其他类型的统一初始化"></a><strong>4.其他类型的统一初始化</strong></h5><blockquote><p><strong>动态分配的数组的统一初始化：</strong></p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span>* pArray = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">4</span>]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br></code></pre></td></tr></table></figure></blockquote><p><strong>构造函数初始化器的统一初始化：</strong></p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Myclass</span><br>&#123;<br> <span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Myclass</span>()<br>     : mArray&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br> &#123;  <br><br>       &gt;     &#125;<br><br>    <span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> Array[<span class="hljs-number">4</span>];<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p><strong>此外，统一初始化还可以用于标准库容器，之后讨论；</strong></p></blockquote><h5 id="5-两种统一初始化的初始化列表"><a href="#5-两种统一初始化的初始化列表" class="headerlink" title="5.两种统一初始化的初始化列表"></a>5.两种统一初始化的初始化列表</h5><blockquote><ul><li><p><strong>复制列表初始化：T obj &#x3D; {arg1, arg2, …};</strong></p></li><li><p><strong>直接初始化：    T obj {arg1, arg2, …}</strong></p><blockquote><p>在 C++17 后，与 <strong>auto</strong> 结合有以下结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Copy list initialization</span><br><span class="hljs-keyword">auto</span> a = &#123;<span class="hljs-number">11</span>&#125;; <span class="hljs-comment">// initializer_list&lt;int&gt;</span><br><span class="hljs-keyword">auto</span> b = &#123;<span class="hljs-number">11</span>, <span class="hljs-number">22</span>&#125;; <span class="hljs-comment">// initial!zer_list&lt;int&gt;</span><br><br><span class="hljs-comment">// Direct list initialization</span><br><span class="hljs-keyword">auto</span> c &#123;<span class="hljs-number">11</span>); <span class="hljs-comment">// int</span><br><span class="hljs-keyword">auto</span> d &#123;<span class="hljs-number">11</span>, <span class="hljs-number">22</span>&#125;; <span class="hljs-comment">// Error, too many elements.</span><br><br><span class="hljs-comment">// 注意，auto 作为 std::initializer_list&lt;int&gt; 类型，不可以直接 std::cout &lt;&lt; 输出，使用下面方法：</span><br>       &gt; <span class="hljs-comment">// 以 a 为例</span><br><span class="hljs-keyword">auto</span> a = &#123; <span class="hljs-number">11</span> &#125;;<br><br><span class="hljs-comment">// 使用范围遍历输出</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; element : a) <br>&#123;<br>std::cout &lt;&lt; element &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><br><span class="hljs-comment">// 或者使用迭代器</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> item = a.<span class="hljs-built_in">begin</span>(); item != a.<span class="hljs-built_in">end</span>(); ++item) <br>&#123;<br>std::cout &lt;&lt; *item &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li></ul><blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">注意：<br><br><span class="hljs-number">1.</span> **对于复制列表初始化，放在大括号中的初始化器的所有元素都必须使用相同的类型**。例如，以下代码无法编译： <br><br>   &gt; ``` c++<br>   &gt; <span class="hljs-built_in">auto</span> b = &#123;<span class="hljs-number">11</span>, <span class="hljs-number">12.33</span>&#125;;<span class="hljs-comment">// Compilation error</span><br></code></pre></td></tr></table></figure><ol start="2"><li><strong>区分结构化绑定；</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>**在早期版本 (C++<span class="hljs-number">11</span>/<span class="hljs-number">14</span>) 中，复制初始化列表和直接列表初始化会推导出 std::initializer_list&lt;&gt;:**<br><br>```c++<br><span class="hljs-comment">// Copy list initialization</span><br><span class="hljs-keyword">auto</span> a = &#123;<span class="hljs-number">11</span>&#125;; <span class="hljs-comment">// initializer_list&lt;int&gt;</span><br><span class="hljs-keyword">auto</span> b = &#123;<span class="hljs-number">11</span>, <span class="hljs-number">22</span>&#125;; <span class="hljs-comment">// initializer_list&lt;int&gt;</span><br><br><span class="hljs-comment">// Direct list initialization</span><br><span class="hljs-keyword">auto</span> c &#123;<span class="hljs-number">11</span>&#125;; <span class="hljs-comment">// initial!zer_list&lt;int&gt;</span><br><span class="hljs-keyword">auto</span> d &#123;<span class="hljs-number">11</span>, <span class="hljs-number">22</span>&#125;; <span class="hljs-comment">// initializer_list&lt;int&gt;</span><br></code></pre></td></tr></table></figure></li></ol></blockquote></blockquote><hr><h3 id="1-5-标准库"><a href="#1-5-标准库" class="headerlink" title="1.5    标准库"></a><strong>1.5    标准库</strong></h3><blockquote><p><strong>C++ 具有标准库，其中包含许多有用的类，在代码中可方便地使用这些类。使用标准库中类的好处是不需要重新创建某些类，也不需要浪费时间去实现系统已经自动实现的内容。另一好处是标准库中的类己经过成千上万用户的严格测试和验证。标准库中类的性能也比较高，因此使用这些类比使用自己的类效率更高。</strong></p><p>标准库中可用的功能非常多。第 16~20 章将详细讲述标准库。<strong>当开始使用 C++时，最好立刻了解标准库可以做什么。</strong>如果你是一位 C 程序员，这一点尤其重要。作为 C 程序员，你使用 C++时可能会以 C 的方式解决问题。然而使用 C++ 的标准库类可以更方便、安全地解决问题。</p><p>本章前面己经介绍了标准库中的一些类，例如 <strong>std::string、std::array、std::vector、std::unique_ptr</strong> 和<strong>std::shared_ptr</strong> 第 16~20 章将介绍更多的类。</p></blockquote><hr><h3 id="1-6-第一个有用的-C-程序"><a href="#1-6-第一个有用的-C-程序" class="headerlink" title="1.6    第一个有用的 C++ 程序"></a><strong>1.6    第一个有用的 C++ 程序</strong></h3><hr><h4 id="6-1雇员记录系统"><a href="#6-1雇员记录系统" class="headerlink" title="6.1雇员记录系统"></a><strong>6.1雇员记录系统</strong></h4><blockquote><p>管理公司雇员记录的程序应该灵活并具有有效的功能，这个程序包含的功能有：</p><ul><li>添加雇员</li><li>解雇雇员</li><li>雇员晋升</li><li>查看所有雇员，包括过去和现在的雇员</li><li>查看所有当前雇员</li><li>查看所有之前雇员</li></ul><p>程序的代码分为三部分：Employee 类封装了单个雇员的信息，Database 类管理公司的所有雇员，单独的用户界面提供程序的接口；</p></blockquote><hr><h4 id="6-2Employee-类"><a href="#6-2Employee-类" class="headerlink" title="6.2Employee 类"></a><strong>6.2Employee 类</strong></h4><blockquote><p>Employee 类维护了某个雇员的的全部信息，该类的方法提供了查询以及修改信息的途径。Employee 类还知道如何在控制台显示自身。此外，还存在调整雇员薪水和就业状态的方法。</p></blockquote><hr><h6 id="1-Employee-h"><a href="#1-Employee-h" class="headerlink" title="1.Employee.h"></a>1.Employee.h</h6><blockquote><p><strong>注意：使用以下约定：给常量加前缀 k(小写字母)。这源于德语单词 Konstant, 意思是“顾问”  ；</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*第一行包括 #pragma once，以防止文件被包含多次。</span><br><span class="hljs-comment">此外还包括 string 功能。*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-comment">// 不推荐，也不要将这个参量定义于头文件命名空间外，因为当引入到实现文件后，文件之间耦合性可能增加，可能引起错误</span><br><span class="hljs-comment">// const int kDefaultStartingSalary = 30000;</span><br><br><span class="hljs-comment">/*代码还声明后面的代码(包括在大括号中)将位于Records名称空间。</span><br><span class="hljs-comment">为使用特定代码，整个程序都会用到 Rewards 名称空间；*/</span><br><span class="hljs-keyword">namespace</span> Records<br>&#123;<br> <span class="hljs-comment">/*下面的常量代表新雇员的默认起薪，位于 Records 名称空间。</span><br><span class="hljs-comment"> Records 名称空间中的其他代码可以将这个常量作为 kDefhultStartingSalary 访问。</span><br><span class="hljs-comment"> 在其他位置，必须通过 Records::kDefaultStartingSalary 来引用它。*/</span><br> <span class="hljs-comment">// 这里在命名空间内定义这个参量，使得 kDefaultStartingSalary 作用域限定于命名空间域，避免耦合</span><br> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kDefaultStartingSalary = <span class="hljs-number">30000</span>;<br><br> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span><br> &#123;<br>     <span class="hljs-keyword">public</span>:<br>     <span class="hljs-built_in">Employee</span>() = <span class="hljs-keyword">default</span>;<br>     <span class="hljs-built_in">Employee</span>(<span class="hljs-type">const</span> std::string&amp; firstName,<br>                  <span class="hljs-type">const</span> std::string&amp; lastNmae);<br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">promote</span><span class="hljs-params">(<span class="hljs-type">int</span> raiseAmount = <span class="hljs-number">1000</span>)</span></span>;<br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demote</span><span class="hljs-params">(<span class="hljs-type">int</span> demeritAmount = <span class="hljs-number">1000</span>)</span></span>;<br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hire</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// Hires or rehires the employee</span><br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fire</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// Dissmisses the employee</span><br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// Output employee info to console</span><br><br>     <span class="hljs-comment">// Getters and setters</span><br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setFirstName</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; firstName)</span></span>;<br>     <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getFirstName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setLastName</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; lastName)</span></span>;<br>     <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getLastName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setEmployeeNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> employeeNumber)</span></span>;<br>     <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getEmployeeNumber</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setSalary</span><span class="hljs-params">(<span class="hljs-type">int</span> newSalary)</span></span>;<br>     <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getSalary</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>     <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isHired</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>     <span class="hljs-comment">/*最后将数据成员声明为 private, 这样其他部分的代码将无法直接修改它们。</span><br><span class="hljs-comment">     获取器和设置器提供了修改或查询这些值的唯一公有途径。</span><br><span class="hljs-comment">     数据成员也在这里(而非构造函数中)进行初始化。*/</span><br>     <span class="hljs-keyword">private</span>:<br>     std::string mFirstName;<br>     std::string mLastName;<br>     <span class="hljs-type">int</span> mEmployeeNumber = <span class="hljs-number">-1</span>;   <span class="hljs-comment">// 雇员编号而非雇员数量</span><br>     <span class="hljs-type">int</span> mSalary = kDefaultStartingSalary;<span class="hljs-comment">// 默认起始薪资</span><br>     <span class="hljs-type">bool</span> mHired = <span class="hljs-literal">false</span>;   <span class="hljs-comment">// 受雇状态</span><br> &#125;;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h6 id="2-Employee-cpp"><a href="#2-Employee-cpp" class="headerlink" title="2.Employee.cpp"></a><strong>2.Employee.cpp</strong></h6><p>​<strong>注意，整型参数的默认值不显示在源文件中；</strong></p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Employee.h&quot;</span></span><br><br><span class="hljs-comment">// using namespace std;</span><br><span class="hljs-comment">// 课本上这样讲了，但是这事实上引入 std 名称空间是一种不好的实践，尤其是在头文件中</span><br><span class="hljs-comment">// 下面给出更好的做法，引入所需要的标识符：</span><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-keyword">namespace</span> Records<br>&#123;<br> <span class="hljs-comment">/*构造函数接收姓名，只设置相应的数据成员；*/</span><br> Employee::<span class="hljs-built_in">Employee</span>(<span class="hljs-type">const</span> std::string&amp; firstName,<br>                    <span class="hljs-type">const</span> std::string&amp; lastName)<br>     : <span class="hljs-built_in">mFirstName</span>(firstName), <span class="hljs-built_in">mLastName</span>(lastName)<br> &#123;<br><br> &#125;<br><br> <span class="hljs-comment">/*promote() 和 demote() 方法只是用一些新值调用 setSalary() 方法。</span><br><span class="hljs-comment">   注意，整型参数的默认值不显示在源文件中；</span><br><span class="hljs-comment"> 它们只能出现在函数声明中，不能出现在函数定义中。*/</span><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Employee::promote</span><span class="hljs-params">(<span class="hljs-type">int</span> raiseAmount)</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-built_in">setSalary</span>(<span class="hljs-built_in">getSalary</span>() + raiseAmount);<br> &#125;<br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Employee::demote</span><span class="hljs-params">(<span class="hljs-type">int</span> demoteAmount)</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-built_in">setSalary</span>(<span class="hljs-built_in">getSalary</span>() - demoteAmount);<br> &#125;<br><br> <span class="hljs-comment">/*hire() 和 fire() 方法正确设置了 mHired 数据成员*/</span><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Employee::hire</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123;<br>     mHired = <span class="hljs-literal">true</span>;<br> &#125;<br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Employee::fire</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123;<br>     mHired = <span class="hljs-literal">false</span>;<br> &#125;<br><br> <span class="hljs-comment">/*display()方法使用控制台输出流显示当前雇员的信息。</span><br><span class="hljs-comment"> 由于这段代码是 Employee 类的一部分，因此可直谈访问数据成员(如 mSalary), 而不需要使用 getSalaryo获取器。</span><br><span class="hljs-comment"> 然而，使用获取器和设置器(当存在时)是一种好的风格，甚至在类的内部也是如此。*/</span><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Employee::display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"> </span>&#123;<br>     cout &lt;&lt; <span class="hljs-string">&quot;Employee: &quot;</span> &lt;&lt; <span class="hljs-built_in">getLastName</span>() &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; <span class="hljs-built_in">getFirstName</span>() &lt;&lt; endl;<br>     cout &lt;&lt; <span class="hljs-string">&quot;-------------------------&quot;</span> &lt;&lt; endl;<br>     cout &lt;&lt; (<span class="hljs-built_in">isHired</span>() ? <span class="hljs-string">&quot;Current Employee&quot;</span> : <span class="hljs-string">&quot;Former Employee&quot;</span>) &lt;&lt; endl;<br>     cout &lt;&lt; <span class="hljs-string">&quot;Employee Number : &quot;</span> &lt;&lt; <span class="hljs-built_in">getEmployeeNumber</span>() &lt;&lt; endl;<br>     cout &lt;&lt; <span class="hljs-string">&quot;Salary: $&quot;</span> &lt;&lt; <span class="hljs-built_in">getSalary</span>() &lt;&lt; endl;<br>     cout &lt;&lt; std::endl;<br> &#125;<br><br> <span class="hljs-comment">/*许多获取器和设置器执行获取值以及设置值的任务。</span><br><span class="hljs-comment"> 即使这些方法看起来微不足道，但是使用这些微不足道的获取器和设置器，仍然优于将数据成员设置为 public。</span><br><span class="hljs-comment"> 可能想在 setSalary() 方法中执行边界检查，它们也能简化调试，因为可在其中设置断点，在检索或设置值时检查它们。</span><br><span class="hljs-comment"> 另一个原因是决定修改类中存储数据的方式时，只需要修改这些获取器和设置器。*/</span><br> <span class="hljs-comment">// Getters and setters</span><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Employee::setFirstName</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; firstName)</span></span><br><span class="hljs-function"> </span>&#123;<br>     mFirstName = firstName;<br> &#125;<br> <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getFirstName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">return</span> mFirstName;<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Employee::setLastName</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; lastName)</span></span><br><span class="hljs-function"> </span>&#123;<br>     mLastName = lastName;<br> &#125;<br> <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getLastName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">return</span> mLastName;<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Employee::setEmployeeNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> employeeNumber)</span></span><br><span class="hljs-function"> </span>&#123;<br>     mEmployeeNumber = employeeNumber;<br> &#125;<br> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Employee::getEmployeeNumber</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">return</span> mEmployeeNumber;<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Employee::setSalary</span><span class="hljs-params">(<span class="hljs-type">int</span> newSalary)</span></span><br><span class="hljs-function"> </span>&#123;<br>     mSalary = newSalary;<br> &#125;<br> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Employee::getSalary</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">return</span> mSalary;<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Employee::isHired</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">return</span> mHired;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><hr><h6 id="3-EmployeeTest-cpp"><a href="#3-EmployeeTest-cpp" class="headerlink" title="3.EmployeeTest.cpp"></a><strong>3.EmployeeTest.cpp</strong></h6><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Employee.h&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> Records;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Testing the Employee class.&quot;</span> &lt;&lt; endl;<br>Employee emp;<br>emp.<span class="hljs-built_in">setFirstName</span>(<span class="hljs-string">&quot;John&quot;</span>);<br>emp.<span class="hljs-built_in">setLastName</span>(<span class="hljs-string">&quot;Doe&quot;</span>);<br>emp.<span class="hljs-built_in">setEmployeeNumber</span>(<span class="hljs-number">71</span>);<br>emp.<span class="hljs-built_in">setSalary</span>(<span class="hljs-number">50000</span>);<br>emp.<span class="hljs-built_in">promote</span>();<br>emp.<span class="hljs-built_in">promote</span>(<span class="hljs-number">50</span>);<br>emp.<span class="hljs-built_in">hire</span>();<br>emp.<span class="hljs-built_in">display</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上为书中给出的测试文件书写方法，但下面给出我认为更好的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Employee.h&quot;</span></span><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> Records; <span class="hljs-comment">// 这里选择性地引入 Records 命名空间</span><br><span class="hljs-comment">// 因为是对这个文件的测试所以引入了，但一般大型工程中不使用</span><br> cout &lt;&lt; <span class="hljs-string">&quot;Testing the Employee class.&quot;</span> &lt;&lt; endl;<br><br> Employee emp;<br> emp.<span class="hljs-built_in">setFirstName</span>(<span class="hljs-string">&quot;John&quot;</span>);<br> emp.<span class="hljs-built_in">setLastName</span>(<span class="hljs-string">&quot;Doe&quot;</span>);<br> emp.<span class="hljs-built_in">setEmployeeNumber</span>(<span class="hljs-number">71</span>);<br> emp.<span class="hljs-built_in">setSalary</span>(<span class="hljs-number">50000</span>);<br> emp.<span class="hljs-built_in">promote</span>();<br> emp.<span class="hljs-built_in">promote</span>(<span class="hljs-number">50</span>);<br> emp.<span class="hljs-built_in">hire</span>();<br> emp.<span class="hljs-built_in">display</span>();<br><br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 乃至使用以下的方式：</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Employee.h&quot;</span></span><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> Records;<br> cout &lt;&lt; <span class="hljs-string">&quot;Testing the Employee class.&quot;</span> &lt;&lt; endl;<br><br> <span class="hljs-keyword">auto</span> emp = std::<span class="hljs-built_in">make_unique</span>&lt;Employee&gt;();<br> emp-&gt;<span class="hljs-built_in">setFirstName</span>(<span class="hljs-string">&quot;John&quot;</span>);<br> emp-&gt;<span class="hljs-built_in">setLastName</span>(<span class="hljs-string">&quot;Doe&quot;</span>);<br> emp-&gt;<span class="hljs-built_in">setEmployeeNumber</span>(<span class="hljs-number">71</span>);<br> emp-&gt;<span class="hljs-built_in">setSalary</span>(<span class="hljs-number">50000</span>);<br> emp-&gt;<span class="hljs-built_in">promote</span>();<br> emp-&gt;<span class="hljs-built_in">promote</span>(<span class="hljs-number">50</span>);<br> emp-&gt;<span class="hljs-built_in">hire</span>();<br> emp-&gt;<span class="hljs-built_in">display</span>();<br><br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当确信 Employee 类可正常运行后，应删除这个文件，或将这个文件注释掉，这样就不会编译具有多个 main() 函数的代码;</li><li>一种测试各个类的方法是使用单元测试，详见第 26 章中的讨论;</li></ul></blockquote><hr><h4 id="6-3Database-类"><a href="#6-3Database-类" class="headerlink" title="6.3Database 类"></a><strong>6.3Database 类</strong></h4><blockquote><p>Database 类使用标准库中的 std::vector 类来存储 Employee 对象</p></blockquote><hr><h5 id="1-Database-h"><a href="#1-Database-h" class="headerlink" title="1.Database.h"></a><strong>1.Database.h</strong></h5><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*由于数据库会自动给新雇员指定一个雇员号，因此定义一个常量作为编号的开始*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Employee.h&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> Records<br>&#123;<br> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kFirstEmployeeNumber = <span class="hljs-number">1000</span>;<br> <span class="hljs-comment">/*数据库可根据提供的姓名方便地添加一个新雇员。为方便起见，这个方法返回一个新雇员的引用。</span><br><span class="hljs-comment"> 外部代码也可通过调用 getEmployee() 方法来获得雇员的引用。</span><br><span class="hljs-comment"> 为这个方法声明了两个版本，一个允许按雇员号进行检索，另一个要求提供雇员的姓名。*/</span><br> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Database</span><br> &#123;<br> <span class="hljs-keyword">public</span>:<br>     <span class="hljs-function">std::shared_ptr&lt;Employee&gt;&amp; <span class="hljs-title">addEmployee</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; firstName,</span></span><br><span class="hljs-params"><span class="hljs-function">                                            <span class="hljs-type">const</span> std::string&amp; lastName)</span></span>;<br>     <span class="hljs-function">std::shared_ptr&lt;Employee&gt;&amp; <span class="hljs-title">getEmployee</span><span class="hljs-params">(<span class="hljs-type">int</span> employeeNumber)</span></span>;<br>     <span class="hljs-function">std::shared_ptr&lt;Employee&gt;&amp; <span class="hljs-title">getEmployee</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; firstName,</span></span><br><span class="hljs-params"><span class="hljs-function">                                            <span class="hljs-type">const</span> std::string&amp; lastName)</span></span>;<br><span class="hljs-comment">/*由于数据库是所有雇员记录的中心存储库，因此具有输出所有雇员、当前在职雇员以及己离职雇员的方法。*/</span><br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">displayAll</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">displayCurrent</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">displayFormer</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>     <span class="hljs-comment">/*mEmployees 包含 Employee 对象。</span><br><span class="hljs-comment">     数据成员 mNextEmployeeNumber 跟踪新雇员的雇员号，使用 kFirstEmployeeNumber 常量进行初始化*/</span><br> <span class="hljs-keyword">private</span>:<br>     <span class="hljs-comment">// std::vector&lt;std::make_unique&lt;Employee&gt;()&gt; mEmployee;</span><br>     <span class="hljs-comment">// 上是最一开始写错的版本，下面给出正确版本</span><br>     std::vector&lt;std::shared_ptr&lt;Employee&gt;&gt; mEmployees;<br>     <span class="hljs-type">int</span> mNextEmployeeNumber = kFirstEmployeeNumber;<br> &#125;;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><hr><h5 id="2-Database-cpp"><a href="#2-Database-cpp" class="headerlink" title="2.Database.cpp"></a><strong>2.Database.cpp</strong></h5><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*addEmployeeo方法创建一个新的 Employee 对象，在其中填充信息并将其添加到 vector 中。</span><br><span class="hljs-comment">注意当使用了这个方法后，数据成员 mNextEmployeeNumber 的值会递增，因此下一个雇员将获得新编号*/</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Database.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-keyword">namespace</span> Records<br>&#123;<br> <span class="hljs-function">std::shared_ptr&lt;Employee&gt;&amp; <span class="hljs-title">Database::addEmployee</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; firstName,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                  <span class="hljs-type">const</span> std::string&amp; lastName)</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">auto</span> theEmployee = std::<span class="hljs-built_in">make_shared</span>&lt;Employee&gt;(firstName, lastName);<br>     theEmployee-&gt;<span class="hljs-built_in">setEmployeeNumber</span>(mNextEmployeeNumber++);<br>     theEmployee-&gt;<span class="hljs-built_in">hire</span>();<br>     mEmployees.<span class="hljs-built_in">push_back</span>(theEmployee);<br><br>     <span class="hljs-keyword">return</span> mEmployees[mEmployees.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br> &#125;<br><br> <span class="hljs-function">std::shared_ptr&lt;Employee&gt;&amp; <span class="hljs-title">Database::getEmployee</span><span class="hljs-params">(<span class="hljs-type">int</span> employeeNumber)</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; employee : mEmployees)<br>     &#123;<br>         <span class="hljs-keyword">if</span> (employee-&gt;<span class="hljs-built_in">getEmployeeNumber</span>() == employeeNumber)<br>         &#123;<br>             <span class="hljs-keyword">return</span> employee;<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">logic_error</span>(<span class="hljs-string">&quot;No employee found.&quot;</span>);<br> &#125;<br><br> <span class="hljs-function">std::shared_ptr&lt;Employee&gt;&amp; <span class="hljs-title">Database::getEmployee</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; firstName,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                  <span class="hljs-type">const</span> std::string&amp; lastName)</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; employee : mEmployees)<br>     &#123;<br>         <span class="hljs-keyword">if</span> (employee-&gt;<span class="hljs-built_in">getFirstName</span>() == firstName &amp;&amp; employee-&gt;<span class="hljs-built_in">getLastName</span>() == lastName)<br>         &#123;<br>             <span class="hljs-keyword">return</span> employee;<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">logic_error</span>(<span class="hljs-string">&quot;No employee found.&quot;</span>);<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Database::displayAll</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; employee : mEmployees)<br>     &#123;<br>         employee-&gt;<span class="hljs-built_in">display</span>();<br>     &#125;<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Database::displayCurrent</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; employee : mEmployees)<br>     &#123;<br>         <span class="hljs-keyword">if</span> (employee-&gt;<span class="hljs-built_in">isHired</span>() == <span class="hljs-literal">true</span>)<br>         &#123;<br>             employee-&gt;<span class="hljs-built_in">display</span>();<br>         &#125;<br>     &#125;<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Database::displayFormer</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; employee : mEmployees)<br>     &#123;<br>         <span class="hljs-keyword">if</span> (employee-&gt;<span class="hljs-built_in">isHired</span>() == <span class="hljs-literal">false</span>)<br>         &#123;<br>             employee-&gt;<span class="hljs-built_in">display</span>();<br>         &#125;<br>     &#125;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h5 id="3-DatabaseTest-cpp"><a href="#3-DatabaseTest-cpp" class="headerlink" title="3.DatabaseTest.cpp"></a><strong>3.DatabaseTest.cpp</strong></h5><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*用于数据库基本功能的简单测试*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Database.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Records::Database myDB;<br><span class="hljs-keyword">auto</span>&amp; emp1 = myDB.<span class="hljs-built_in">addEmployee</span>(<span class="hljs-string">&quot;Greg&quot;</span>, <span class="hljs-string">&quot;Wallis&quot;</span>);<br>emp1-&gt;<span class="hljs-built_in">fire</span>();<br><span class="hljs-keyword">auto</span> &amp; emp2 = myDB.<span class="hljs-built_in">addEmployee</span>(<span class="hljs-string">&quot;Marc&quot;</span>, <span class="hljs-string">&quot;White&quot;</span>);<br>emp2-&gt;<span class="hljs-built_in">setSalary</span>(<span class="hljs-number">100000</span>);<br><span class="hljs-keyword">auto</span> &amp; emp3 = myDB.<span class="hljs-built_in">addEmployee</span>(<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;Doe&quot;</span>);<br>emp3-&gt;<span class="hljs-built_in">setSalary</span>(<span class="hljs-number">10000</span>);<br>emp3-&gt;<span class="hljs-built_in">promote</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;all employees: &quot;</span> &lt;&lt; endl &lt;&lt; endl;<br>myDB.<span class="hljs-built_in">displayAll</span>();<br>cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;current employees: &quot;</span> &lt;&lt; endl &lt;&lt; endl;<br>myDB.<span class="hljs-built_in">displayCurrent</span>();<br>cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;former employees: &quot;</span> &lt;&lt; endl &lt;&lt; endl;<br>myDB.<span class="hljs-built_in">displayFormer</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><hr><h5 id="4-std-unique-ptr版本"><a href="#4-std-unique-ptr版本" class="headerlink" title="4.std::unique_ptr版本"></a><strong>4.std::unique_ptr</strong>版本</h5><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Database.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Employee.h&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> Records<br>&#123;<br> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kFirstEmployeeNumber = <span class="hljs-number">1000</span>;<br> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Database</span><br> &#123;<br> <span class="hljs-keyword">public</span>:<br>     <span class="hljs-function">std::unique_ptr&lt;Employee&gt;&amp; <span class="hljs-title">addEmployee</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; firstName,</span></span><br><span class="hljs-params"><span class="hljs-function">                                           <span class="hljs-type">const</span> std::string&amp; lastName)</span></span>;<br>     <span class="hljs-function">std::unique_ptr&lt;Employee&gt; <span class="hljs-title">getEmployee</span><span class="hljs-params">(<span class="hljs-type">int</span> employeeNumber)</span></span>;<br>     <span class="hljs-function">std::unique_ptr&lt;Employee&gt; <span class="hljs-title">getEmployee</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; firstName,</span></span><br><span class="hljs-params"><span class="hljs-function">                                           <span class="hljs-type">const</span> std::string&amp; lastName)</span></span>;<br><br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">displayAll</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">displayCurrent</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">displayFormer</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>     std::vector&lt;std::unique_ptr&lt;Employee&gt;&gt; mEmployees;<br>     <span class="hljs-type">int</span> mNextEmployeeNumber = kFirstEmployeeNumber;<br> &#125;;<br>&#125;<br><br><span class="hljs-comment">/*-----------------------------------------------------------------------------------*/</span><br><span class="hljs-comment">// Database.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Database.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-keyword">namespace</span> Records<br>&#123;<br> <span class="hljs-function">std::unique_ptr&lt;Employee&gt;&amp; <span class="hljs-title">Database::addEmployee</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; firstName,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                 <span class="hljs-type">const</span> std::string&amp; lastName)</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">auto</span> theEmployee = std::<span class="hljs-built_in">make_unique</span>&lt;Employee&gt;(firstName, lastName);<br>     theEmployee-&gt;<span class="hljs-built_in">setEmployeeNumber</span>(mNextEmployeeNumber++);<br>     theEmployee-&gt;<span class="hljs-built_in">hire</span>();<br>     mEmployees.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(theEmployee));<br><br>     <span class="hljs-keyword">return</span> mEmployees[mEmployees.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br> &#125;<br><br> <span class="hljs-function">std::unique_ptr&lt;Employee&gt; <span class="hljs-title">Database::getEmployee</span><span class="hljs-params">(<span class="hljs-type">int</span> employeeNumber)</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; employee : mEmployees)<br>     &#123;<br>         <span class="hljs-keyword">if</span> (employee-&gt;<span class="hljs-built_in">getEmployeeNumber</span>() == employeeNumber)<br>         &#123;<br>             <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">move</span>(employee);<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">logic_error</span>(<span class="hljs-string">&quot;No employee found.&quot;</span>);<br> &#125;<br><br> <span class="hljs-function">std::unique_ptr&lt;Employee&gt; <span class="hljs-title">Database::getEmployee</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; firstName,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                 <span class="hljs-type">const</span> std::string&amp; lastName)</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; employee : mEmployees)<br>     &#123;<br>         <span class="hljs-keyword">if</span> (employee-&gt;<span class="hljs-built_in">getFirstName</span>() == firstName &amp;&amp; employee-&gt;<span class="hljs-built_in">getLastName</span>() == lastName)<br>         &#123;<br>             <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">move</span>(employee);<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">logic_error</span>(<span class="hljs-string">&quot;No employee found.&quot;</span>);<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Database::displayAll</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; employee : mEmployees)<br>     &#123;<br>         employee-&gt;<span class="hljs-built_in">display</span>();<br>     &#125;<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Database::displayCurrent</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; employee : mEmployees)<br>     &#123;<br>         <span class="hljs-keyword">if</span> (employee-&gt;<span class="hljs-built_in">isHired</span>() == <span class="hljs-literal">true</span>)<br>         &#123;<br>             employee-&gt;<span class="hljs-built_in">display</span>();<br>         &#125;<br>     &#125;<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Database::displayFormer</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; employee : mEmployees)<br>     &#123;<br>         <span class="hljs-keyword">if</span> (employee-&gt;<span class="hljs-built_in">isHired</span>() == <span class="hljs-literal">false</span>)<br>         &#123;<br>             employee-&gt;<span class="hljs-built_in">display</span>();<br>         &#125;<br>     &#125;<br> &#125;<br>&#125;<br><br><span class="hljs-comment">/*-----------------------------------------------------------------------------------*/</span><br><span class="hljs-comment">// DatabaseTest.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Database.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Records::Database myDB;<br><span class="hljs-keyword">auto</span>&amp; emp1 = myDB.<span class="hljs-built_in">addEmployee</span>(<span class="hljs-string">&quot;Greg&quot;</span>, <span class="hljs-string">&quot;Wallis&quot;</span>);<br>emp1-&gt;<span class="hljs-built_in">fire</span>();<br><span class="hljs-keyword">auto</span> &amp; emp2 = myDB.<span class="hljs-built_in">addEmployee</span>(<span class="hljs-string">&quot;Marc&quot;</span>, <span class="hljs-string">&quot;White&quot;</span>);<br>emp2-&gt;<span class="hljs-built_in">setSalary</span>(<span class="hljs-number">100000</span>);<br><span class="hljs-keyword">auto</span> &amp; emp3 = myDB.<span class="hljs-built_in">addEmployee</span>(<span class="hljs-string">&quot;John&quot;</span>, <span class="hljs-string">&quot;Doe&quot;</span>);<br>emp3-&gt;<span class="hljs-built_in">setSalary</span>(<span class="hljs-number">10000</span>);<br>emp3-&gt;<span class="hljs-built_in">promote</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;all employees: &quot;</span> &lt;&lt; endl &lt;&lt; endl;<br>myDB.<span class="hljs-built_in">displayAll</span>();<br>cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;current employees: &quot;</span> &lt;&lt; endl &lt;&lt; endl;<br>myDB.<span class="hljs-built_in">displayCurrent</span>();<br>cout &lt;&lt; endl &lt;&lt; <span class="hljs-string">&quot;former employees: &quot;</span> &lt;&lt; endl &lt;&lt; endl;<br>myDB.<span class="hljs-built_in">displayFormer</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><hr><h4 id="6-4用户界面-UI"><a href="#6-4用户界面-UI" class="headerlink" title="6.4用户界面(UI)**"></a><em><em>6.4用户界面</em>(UI)</em>**</h4><blockquote><p><strong>程序的最后一部分是基于菜单的用户界面，可让用户方便地使用雇员数据库。main()函数是一个显示菜单的循环，执行被选中的操作，然后重新开始循环。对于大多数的操作都定义了独立的函数。对于显示雇员之类的简单操作，则将实际代码放在对应的情况(case)中。</strong></p></blockquote><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Display.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;exception&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;limits&gt;</span>           <span class="hljs-comment">// 用于清除输入缓冲区</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Database.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><span class="hljs-keyword">using</span> std::string;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">displayMenu</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doHire</span><span class="hljs-params">(Records::Database&amp; db)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doFire</span><span class="hljs-params">(Records::Database&amp; db)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doPromote</span><span class="hljs-params">(Records::Database&amp; db)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doDemote</span><span class="hljs-params">(Records::Database&amp; db)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> Records::Database employeeDB;<br> <span class="hljs-type">bool</span> done = <span class="hljs-literal">false</span>;<br> <span class="hljs-keyword">while</span> (!done)<br> &#123;<br>     <span class="hljs-type">int</span> selection = <span class="hljs-built_in">displayMenu</span>();<br>     <span class="hljs-keyword">switch</span> (selection)<br>     &#123;<br>     <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>         done = <span class="hljs-literal">true</span>;<br>         <span class="hljs-keyword">break</span>;<br>     <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>         <span class="hljs-built_in">doHire</span>(employeeDB);<br>         <span class="hljs-keyword">break</span>;<br>     <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>         <span class="hljs-built_in">doFire</span>(employeeDB);<br>         <span class="hljs-keyword">break</span>;<br>     <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>         <span class="hljs-built_in">doPromote</span>(employeeDB);<br>         <span class="hljs-keyword">break</span>;<br>     <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>         employeeDB.<span class="hljs-built_in">displayAll</span>();<br>         <span class="hljs-keyword">break</span>;<br>     <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>         employeeDB.<span class="hljs-built_in">displayCurrent</span>();<br>         <span class="hljs-keyword">break</span>;<br>     <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>         employeeDB.<span class="hljs-built_in">displayFormer</span>();<br>         <span class="hljs-keyword">break</span>;<br>     <span class="hljs-keyword">default</span>:<br>         std::cerr &lt;&lt; <span class="hljs-string">&quot;Unknown command.&quot;</span> &lt;&lt; endl;<br>         <span class="hljs-keyword">break</span>;<br>     &#125;<br> &#125;<br><br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* displayMenu() 函数输出菜单获取用户输入。</span><br><span class="hljs-comment">在此假定用户能够“正确地输入”，当需要一个数字时就输入一个数字，这一点很重要。</span><br><span class="hljs-comment">在阅读了第 13 章有关 I / O 的内容后，你就会知道如何防止输入错误信息*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">displayMenu</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-type">int</span> selection;<br> cout &lt;&lt; endl;<br> cout &lt;&lt; <span class="hljs-string">&quot;Employee Database&quot;</span> &lt;&lt; endl;<br> cout &lt;&lt; <span class="hljs-string">&quot;-----------------&quot;</span> &lt;&lt; endl;<br> cout &lt;&lt; <span class="hljs-string">&quot;1) Hire a new employee&quot;</span> &lt;&lt; endl;<br> cout &lt;&lt; <span class="hljs-string">&quot;2) Fire an employee&quot;</span> &lt;&lt; endl;<br> cout &lt;&lt; <span class="hljs-string">&quot;3) Promote an employee&quot;</span> &lt;&lt; endl;<br> cout &lt;&lt; <span class="hljs-string">&quot;4) List all employees&quot;</span> &lt;&lt; endl;<br> cout &lt;&lt; <span class="hljs-string">&quot;5) List all current employee&quot;</span> &lt;&lt; endl;<br> cout &lt;&lt; <span class="hljs-string">&quot;6) List all former employee&quot;</span> &lt;&lt; endl;<br> cout &lt;&lt; <span class="hljs-string">&quot;0) Quit&quot;</span> &lt;&lt; endl;<br> cout &lt;&lt; <span class="hljs-string">&quot;---&gt;   &quot;</span>;<br><br> <span class="hljs-comment">// 循环，直到得到有效的输入</span><br> <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br> &#123;<br>     <span class="hljs-comment">// 尝试读取用户输入</span><br>     <span class="hljs-keyword">try</span><br>     &#123;<br>         std::cin &gt;&gt; selection;<br><br>         <span class="hljs-comment">// 检查输入流的状态</span><br>         <span class="hljs-keyword">if</span> (std::cin.<span class="hljs-built_in">fail</span>())<br>         &#123;<br>             <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Invalid input. Please enter a number.&quot;</span>);<br>         &#125;<br><br>         <span class="hljs-comment">// 如果程序能够执行到这里，说明输入是有效的</span><br>         <span class="hljs-keyword">break</span>;<br>     &#125;<br>     <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::invalid_argument&amp; exception)<br>     &#123;<br>         std::cerr &lt;&lt; <span class="hljs-string">&quot;Error: &quot;</span> &lt;&lt; exception.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br><br>         <span class="hljs-comment">// 清除错误状态</span><br>         std::cin.<span class="hljs-built_in">clear</span>();<br><br>         <span class="hljs-comment">// 忽略缓冲区中的无效字符，直到遇到换行符</span><br>         std::cin.<span class="hljs-built_in">ignore</span>(std::numeric_limits&lt;std::streamsize&gt;::<span class="hljs-built_in">max</span>(), <span class="hljs-string">&#x27;\n&#x27;</span>);<br>     &#125;<br> &#125;<br><br> <span class="hljs-keyword">return</span> selection;<br>&#125;<br><br><span class="hljs-comment">/* doHire() 函数获取用户输入的新雇员的姓名，并通知数据库添加这个雇员*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doHire</span><span class="hljs-params">(Records::Database&amp; db)</span></span><br><span class="hljs-function"></span>&#123;<br> string firstName;<br> string lastName;<br><br> cout &lt;&lt; <span class="hljs-string">&quot;First name? input: &quot;</span>;<br> std::cin &gt;&gt; firstName;<br><br> cout &lt;&lt; <span class="hljs-string">&quot;Last name? input: &quot;</span>;<br> std::cin &gt;&gt; lastName;<br><br> db.<span class="hljs-built_in">addEmployee</span>(firstName, lastName);<br>&#125;<br><br><span class="hljs-comment">/* doFire() 、doPromote() 以及 doDemote() 函数都要求数据库根据雇员号找到雇员，然后使用 Employee 对象的 public 方法进行修改*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doFire</span><span class="hljs-params">(Records::Database&amp; db)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-type">int</span> employeeNumber;<br><br> cout &lt;&lt; <span class="hljs-string">&quot;Employee number? input: &quot;</span>;<br> std::cin &gt;&gt; employeeNumber;<br><br> <span class="hljs-comment">// 将 try 遇到的问题抛出，并继续执行程序</span><br> <span class="hljs-keyword">try</span><br> &#123;<br>     std::unique_ptr&lt;Records::Employee&gt; emp = db.<span class="hljs-built_in">getEmployee</span>(employeeNumber);<br>     emp-&gt;<span class="hljs-built_in">fire</span>();<br>     cout &lt;&lt; <span class="hljs-string">&quot;Employee &quot;</span> &lt;&lt; employeeNumber &lt;&lt; <span class="hljs-string">&quot; terminated.&quot;</span> &lt;&lt; endl;<br> &#125;<br> <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::logic_error&amp; exception)<br> &#123;<br>     std::cerr &lt;&lt; <span class="hljs-string">&quot;Unable to terminate employee: &quot;</span> &lt;&lt; exception.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br> &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doPromote</span><span class="hljs-params">(Records::Database&amp; db)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-type">int</span> employeeNumber;<br> <span class="hljs-type">int</span> raiseAmount;<br><br> cout &lt;&lt; <span class="hljs-string">&quot;Employee number? input: &quot;</span>;<br> std::cin &gt;&gt; employeeNumber;<br><br> cout &lt;&lt; <span class="hljs-string">&quot;How much of a raise? input: &quot;</span>;<br> std::cin &gt;&gt; raiseAmount;<br><br> <span class="hljs-keyword">try</span><br> &#123;<br>     std::unique_ptr&lt;Records::Employee&gt; emp = db.<span class="hljs-built_in">getEmployee</span>(employeeNumber);<br>     emp-&gt;<span class="hljs-built_in">promote</span>(raiseAmount);<br> &#125;<br> <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::logic_error&amp; exception)<br> &#123;<br>     std::cerr &lt;&lt; <span class="hljs-string">&quot;Unable to promote employee: &quot;</span> &lt;&lt; exception.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br> &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doDemote</span><span class="hljs-params">(Records::Database&amp; db)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-type">int</span> employeeNumber;<br> <span class="hljs-type">int</span> demeritAmount;<br><br> cout &lt;&lt; <span class="hljs-string">&quot;Employee number? input: &quot;</span>;<br> std::cin &gt;&gt; employeeNumber;<br><br> cout &lt;&lt; <span class="hljs-string">&quot;How much of a demerit? input: &quot;</span>;<br> std::cin &gt;&gt; demeritAmount;<br><br> <span class="hljs-keyword">try</span><br> &#123;<br>     std::unique_ptr&lt;Records::Employee&gt; emp = db.<span class="hljs-built_in">getEmployee</span>(employeeNumber);<br>     emp-&gt;<span class="hljs-built_in">demote</span>(demeritAmount);<br> &#125;<br> <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::logic_error&amp; exception)<br> &#123;<br>     std::cerr &lt;&lt; <span class="hljs-string">&quot;Unable to promote employee: &quot;</span> &lt;&lt; exception.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><hr><h4 id="6-5评估程序"><a href="#6-5评估程序" class="headerlink" title="6.5评估程序"></a><strong>6.5评估程序</strong></h4><blockquote><p>前面的程序涵盖了许多主题，从最简单的到较复杂的都有。可采用多种方法扩展这个程序。例如，用户界面(UI)没有公开 Database 或 Employee 类的全前功能。可修改 UL 以包含这些特性。还可修改 Database 类，以从 mEmployees 中删除被解雇的雇员。</p><p>如果不理解程序的某些部分，参考前面的内容以回顾这些主题。如果仍不甚明了，最好的学习方法是编写代码并查看结果。例如，如果不确定如何使用条件运算符，可编写一个简单的 main()函数进行测试。  </p></blockquote><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Employee.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> Records<br>&#123;<br> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kDefaultStartingSalary = <span class="hljs-number">30000</span>;<br><br> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span><br> &#123;<br> <span class="hljs-keyword">public</span>:<br>     <span class="hljs-built_in">Employee</span>() = <span class="hljs-keyword">default</span>;<br>     <span class="hljs-built_in">Employee</span>(<span class="hljs-type">const</span> std::string&amp; firstName,<br>         <span class="hljs-type">const</span> std::string&amp; lastNmae);<br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">promote</span><span class="hljs-params">(<span class="hljs-type">int</span> raiseAmount = <span class="hljs-number">1000</span>)</span></span>;<br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">demote</span><span class="hljs-params">(<span class="hljs-type">int</span> demeritAmount = <span class="hljs-number">1000</span>)</span></span>;<br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">hire</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// Hires or rehires the employee</span><br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fire</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">// Dissmisses the employee</span><br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>; <span class="hljs-comment">// Output employee info to console</span><br><br>     <span class="hljs-comment">// Getters and setters</span><br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setFirstName</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; firstName)</span></span>;<br>     <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getFirstName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setLastName</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; lastName)</span></span>;<br>     <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">getLastName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setEmployeeNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> employeeNumber)</span></span>;<br>     <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getEmployeeNumber</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setSalary</span><span class="hljs-params">(<span class="hljs-type">int</span> newSalary)</span></span>;<br>     <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getSalary</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br>     <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isHired</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>     std::string mFirstName;<br>     std::string mLastName;<br>     <span class="hljs-type">int</span> mEmployeeNumber = <span class="hljs-number">-1</span>;   <span class="hljs-comment">// 雇员编号而非雇员数量</span><br>     <span class="hljs-type">int</span> mSalary = kDefaultStartingSalary;<span class="hljs-comment">// 默认起始薪资</span><br>     <span class="hljs-type">bool</span> mHired = <span class="hljs-literal">false</span>;   <span class="hljs-comment">// 受雇状态</span><br> &#125;;<br>&#125;<br><br><span class="hljs-comment">/*--------------------------------------------分隔符---------------------------------------------------*/</span><br><br><span class="hljs-comment">// Employee.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Employee.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-keyword">namespace</span> Records<br>&#123;<br> Employee::<span class="hljs-built_in">Employee</span>(<span class="hljs-type">const</span> std::string&amp; firstName,<br>     <span class="hljs-type">const</span> std::string&amp; lastName)<br>     : <span class="hljs-built_in">mFirstName</span>(firstName), <span class="hljs-built_in">mLastName</span>(lastName)<br> &#123;<br><br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Employee::promote</span><span class="hljs-params">(<span class="hljs-type">int</span> raiseAmount)</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-built_in">setSalary</span>(<span class="hljs-built_in">getSalary</span>() + raiseAmount);<br> &#125;<br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Employee::demote</span><span class="hljs-params">(<span class="hljs-type">int</span> demeritAmount)</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-built_in">setSalary</span>(<span class="hljs-built_in">getSalary</span>() - demeritAmount);<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Employee::hire</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123;<br>     mHired = <span class="hljs-literal">true</span>;<br> &#125;<br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Employee::fire</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123;<br>     mHired = <span class="hljs-literal">false</span>;<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Employee::display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"> </span>&#123;<br>     cout &lt;&lt; <span class="hljs-string">&quot;Employee: &quot;</span> &lt;&lt; <span class="hljs-built_in">getLastName</span>() &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; <span class="hljs-built_in">getFirstName</span>() &lt;&lt; endl;<br>     cout &lt;&lt; <span class="hljs-string">&quot;-------------------------&quot;</span> &lt;&lt; endl;<br>     cout &lt;&lt; (<span class="hljs-built_in">isHired</span>() ? <span class="hljs-string">&quot;Current Employee&quot;</span> : <span class="hljs-string">&quot;Former Employee&quot;</span>) &lt;&lt; endl;<br>     cout &lt;&lt; <span class="hljs-string">&quot;Employee Number : &quot;</span> &lt;&lt; <span class="hljs-built_in">getEmployeeNumber</span>() &lt;&lt; endl;<br>     cout &lt;&lt; <span class="hljs-string">&quot;Salary: $&quot;</span> &lt;&lt; <span class="hljs-built_in">getSalary</span>() &lt;&lt; endl;<br>     cout &lt;&lt; std::endl;<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Employee::setFirstName</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; firstName)</span></span><br><span class="hljs-function"> </span>&#123;<br>     mFirstName = firstName;<br> &#125;<br> <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">Employee::getFirstName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">return</span> mFirstName;<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Employee::setLastName</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; lastName)</span></span><br><span class="hljs-function"> </span>&#123;<br>     mLastName = lastName;<br> &#125;<br> <span class="hljs-function"><span class="hljs-type">const</span> std::string&amp; <span class="hljs-title">Employee::getLastName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">return</span> mLastName;<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Employee::setEmployeeNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> employeeNumber)</span></span><br><span class="hljs-function"> </span>&#123;<br>     mEmployeeNumber = employeeNumber;<br> &#125;<br> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Employee::getEmployeeNumber</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">return</span> mEmployeeNumber;<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Employee::setSalary</span><span class="hljs-params">(<span class="hljs-type">int</span> newSalary)</span></span><br><span class="hljs-function"> </span>&#123;<br>     mSalary = newSalary;<br> &#125;<br> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Employee::getSalary</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">return</span> mSalary;<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Employee::isHired</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">return</span> mHired;<br> &#125;<br>&#125;<br><br><span class="hljs-comment">/*--------------------------------------------分隔符---------------------------------------------------*/</span><br><br><span class="hljs-comment">// Database.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Employee.h&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> Records<br>&#123;<br> <span class="hljs-type">const</span> <span class="hljs-type">int</span> kFirstEmployeeNumber = <span class="hljs-number">1000</span>;<br> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Database</span><br> &#123;<br> <span class="hljs-keyword">public</span>:<br>     <span class="hljs-function">std::unique_ptr&lt;Employee&gt;&amp; <span class="hljs-title">addEmployee</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; firstName,</span></span><br><span class="hljs-params"><span class="hljs-function">                                           <span class="hljs-type">const</span> std::string&amp; lastName)</span></span>;<br>     <span class="hljs-function">std::unique_ptr&lt;Employee&gt;&amp; <span class="hljs-title">getEmployee</span><span class="hljs-params">(<span class="hljs-type">int</span> employeeNumber)</span></span>;<br>     <span class="hljs-function">std::unique_ptr&lt;Employee&gt;&amp; <span class="hljs-title">getEmployee</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; firstName,</span></span><br><span class="hljs-params"><span class="hljs-function">                                           <span class="hljs-type">const</span> std::string&amp; lastName)</span></span>;<br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeEmployee</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; firstName,</span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-type">const</span> std::string&amp; lastName)</span></span>;<br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeEmployee</span><span class="hljs-params">(<span class="hljs-type">int</span> employeeNumber)</span></span>;<br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeUnhiredEmployee</span><span class="hljs-params">()</span></span>;<br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">displayAll</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">displayCurrent</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>     <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">displayFormer</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br> <span class="hljs-keyword">private</span>:<br>     std::vector&lt;std::unique_ptr&lt;Employee&gt;&gt; mEmployees;<br>     <span class="hljs-type">int</span> mNextEmployeeNumber = kFirstEmployeeNumber;<br> &#125;;<br>&#125;<br><br><span class="hljs-comment">/*--------------------------------------------分隔符---------------------------------------------------*/</span><br><br><span class="hljs-comment">// Database.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Database.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><br><span class="hljs-keyword">namespace</span> Records<br>&#123;<br> <span class="hljs-function">std::unique_ptr&lt;Employee&gt;&amp; <span class="hljs-title">Database::addEmployee</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; firstName,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                 <span class="hljs-type">const</span> std::string&amp; lastName)</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">auto</span> theEmployee = std::<span class="hljs-built_in">make_unique</span>&lt;Employee&gt;(firstName, lastName);<br>     theEmployee-&gt;<span class="hljs-built_in">setEmployeeNumber</span>(mNextEmployeeNumber++);<br>     theEmployee-&gt;<span class="hljs-built_in">hire</span>();<br>     mEmployees.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">move</span>(theEmployee));<br><br>     <span class="hljs-keyword">return</span> mEmployees[mEmployees.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>];<br> &#125;<br><br> <span class="hljs-function">std::unique_ptr&lt;Employee&gt;&amp; <span class="hljs-title">Database::getEmployee</span><span class="hljs-params">(<span class="hljs-type">int</span> employeeNumber)</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">if</span> (!mEmployees.<span class="hljs-built_in">empty</span>())<br>     &#123;<br>         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; employee : mEmployees)<br>         &#123;<br>             <span class="hljs-keyword">if</span> (employee-&gt;<span class="hljs-built_in">getEmployeeNumber</span>() == employeeNumber)<br>             &#123;<br>                 <span class="hljs-keyword">return</span> employee;<br>             &#125;<br>         &#125;<br>         <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">logic_error</span>(<span class="hljs-string">&quot;No employee found.&quot;</span>);<br>     &#125;<br>     <span class="hljs-keyword">else</span><br>     &#123;<br>         std::cerr &lt;&lt; <span class="hljs-string">&quot;No employees in the database.&quot;</span> &lt;&lt; std::endl;<br>         <span class="hljs-comment">// 返回一个空指针或者抛出异常，具体取决于你的需求</span><br>         <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">logic_error</span>(<span class="hljs-string">&quot;No employees in the database.&quot;</span>);<br>     &#125;<br> &#125;<br><br><br><span class="hljs-function">std::unique_ptr&lt;Employee&gt;&amp; <span class="hljs-title">Database::getEmployee</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; firstName,</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-type">const</span> std::string&amp; lastName)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">if</span> (!mEmployees.<span class="hljs-built_in">empty</span>())<br> &#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; employee : mEmployees)<br>     &#123;<br>         <span class="hljs-keyword">if</span> (employee-&gt;<span class="hljs-built_in">getFirstName</span>() == firstName &amp;&amp; employee-&gt;<span class="hljs-built_in">getLastName</span>() == lastName)<br>         &#123;<br>             <span class="hljs-keyword">return</span> employee;<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">logic_error</span>(<span class="hljs-string">&quot;No employee found.&quot;</span>);<br> &#125;<br> <span class="hljs-keyword">else</span><br> &#123;<br>     std::cerr &lt;&lt; <span class="hljs-string">&quot;No employees in the database.&quot;</span> &lt;&lt; std::endl;<br>     <span class="hljs-comment">// 返回一个空指针或者抛出异常，具体取决于你的需求</span><br>     <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">logic_error</span>(<span class="hljs-string">&quot;No employees in the database.&quot;</span>);<br> &#125;<br>&#125;<br><br><br> <span class="hljs-comment">//void Database::removeEmployee(const std::string&amp; firstName,</span><br> <span class="hljs-comment">//                              const std::string&amp; lastName) </span><br> <span class="hljs-comment">//&#123;</span><br> <span class="hljs-comment">//    auto item = std::find(mEmployees.begin(), mEmployees.end(), getEmployee(firstName, lastName));</span><br> <span class="hljs-comment">//    if (item != mEmployees.end() || ((*mEmployees.end())-&gt;getFirstName() == firstName &amp;&amp; (*mEmployees.end())-&gt;getFirstName() == lastName))</span><br> <span class="hljs-comment">//    &#123;</span><br> <span class="hljs-comment">//        mEmployees.erase(item);</span><br> <span class="hljs-comment">//    &#125;</span><br> <span class="hljs-comment">//    else </span><br> <span class="hljs-comment">//    &#123;</span><br> <span class="hljs-comment">//        std::cerr &lt;&lt; &quot;Element not found.&quot; &lt;&lt; std::endl;</span><br> <span class="hljs-comment">//    &#125;</span><br> <span class="hljs-comment">//&#125;</span><br><br> <span class="hljs-comment">//void Database::removeEmployee(int employeeNumber)</span><br> <span class="hljs-comment">//&#123;</span><br> <span class="hljs-comment">//    auto item = std::find(mEmployees.begin(), mEmployees.end(), getEmployee(employeeNumber));</span><br> <span class="hljs-comment">//        if ((*item)-&gt;getEmployeeNumber() == employeeNumber)</span><br> <span class="hljs-comment">//        &#123;</span><br> <span class="hljs-comment">//            mEmployees.erase(item);</span><br> <span class="hljs-comment">//        &#125;</span><br> <span class="hljs-comment">//&#125;</span><br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Database::removeEmployee</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; firstName, <span class="hljs-type">const</span> std::string&amp; lastName)</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">if</span> (!mEmployees.<span class="hljs-built_in">empty</span>())<br>     &#123;<br>         mEmployees.<span class="hljs-built_in">erase</span>(<br>             std::<span class="hljs-built_in">remove_if</span>(mEmployees.<span class="hljs-built_in">begin</span>(), mEmployees.<span class="hljs-built_in">end</span>(), [&amp;firstName, &amp;lastName](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; employee) &#123;<br>                 <span class="hljs-keyword">return</span> employee-&gt;<span class="hljs-built_in">getFirstName</span>() == firstName &amp;&amp; employee-&gt;<span class="hljs-built_in">getLastName</span>() == lastName;<br>                 &#125;),<br>             mEmployees.<span class="hljs-built_in">end</span>()<br>         );<br>         cout &lt;&lt; <span class="hljs-string">&quot;This employee is removed&quot;</span> &lt;&lt; endl;<br>     &#125;<br>     <span class="hljs-keyword">else</span><br>     &#123;<br>         std::cerr &lt;&lt; <span class="hljs-string">&quot;No employees in the database.&quot;</span> &lt;&lt; std::endl;<br>     &#125;<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Database::removeEmployee</span><span class="hljs-params">(<span class="hljs-type">int</span> employeeNumber)</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">if</span> (!mEmployees.<span class="hljs-built_in">empty</span>())<br>     &#123;<br>         mEmployees.<span class="hljs-built_in">erase</span>(<br>             std::<span class="hljs-built_in">remove_if</span>(mEmployees.<span class="hljs-built_in">begin</span>(), mEmployees.<span class="hljs-built_in">end</span>(), [employeeNumber](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; employee) &#123;<br>                 <span class="hljs-keyword">return</span> employee-&gt;<span class="hljs-built_in">getEmployeeNumber</span>() == employeeNumber;<br>                 &#125;),<br>             mEmployees.<span class="hljs-built_in">end</span>()<br>         );<br>         cout &lt;&lt; <span class="hljs-string">&quot;This employee is removed&quot;</span> &lt;&lt; endl;<br>     &#125;<br>     <span class="hljs-keyword">else</span><br>     &#123;<br>         std::cerr &lt;&lt; <span class="hljs-string">&quot;No employees in the database.&quot;</span> &lt;&lt; std::endl;<br>     &#125;<br> &#125;<br><br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Database::removeUnhiredEmployee</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">if</span> (!mEmployees.<span class="hljs-built_in">empty</span>())<br>     &#123;<br>         mEmployees.<span class="hljs-built_in">erase</span><br>         (std::<span class="hljs-built_in">remove_if</span>(mEmployees.<span class="hljs-built_in">begin</span>(),<br>             mEmployees.<span class="hljs-built_in">end</span>(),<br>             [](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; employee)<br>             &#123;<br>                 <span class="hljs-keyword">return</span> !employee-&gt;<span class="hljs-built_in">isHired</span>(); <span class="hljs-comment">// 移除所有未雇佣的员工</span><br>             &#125;),<br>             mEmployees.<span class="hljs-built_in">end</span>()<br>         );<br>         cout &lt;&lt; <span class="hljs-string">&quot;Fired employees are removed&quot;</span> &lt;&lt; endl;<br>     &#125;<br>     <span class="hljs-keyword">else</span><br>     &#123;<br>         std::cerr &lt;&lt; <span class="hljs-string">&quot;No employees in the database.&quot;</span> &lt;&lt; std::endl;<br>     &#125;<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Database::displayAll</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">if</span> (!mEmployees.<span class="hljs-built_in">empty</span>())<br>     &#123;<br>         <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; employee : mEmployees)<br>         &#123;<br>             employee-&gt;<span class="hljs-built_in">display</span>();<br>         &#125;<br>         cout &lt;&lt; <span class="hljs-string">&quot;All employees are printed above&quot;</span> &lt;&lt; endl;<br>     &#125;<br>     <span class="hljs-keyword">else</span><br>     &#123;<br>         std::cerr &lt;&lt; <span class="hljs-string">&quot;No employees in the database.&quot;</span> &lt;&lt; std::endl;<br>     &#125;<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Database::displayCurrent</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">if</span> (!mEmployees.<span class="hljs-built_in">empty</span>())<br>     &#123;<br>         <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; employee : mEmployees)<br>         &#123;<br>             <span class="hljs-keyword">if</span> (employee-&gt;<span class="hljs-built_in">isHired</span>() == <span class="hljs-literal">true</span>)<br>             &#123;<br>                 employee-&gt;<span class="hljs-built_in">display</span>();<br>             &#125;<br>         &#125;<br>         cout &lt;&lt; <span class="hljs-string">&quot;Current employees are printed above&quot;</span> &lt;&lt; endl;<br>     &#125;<br>     <span class="hljs-keyword">else</span><br>     &#123;<br>         std::cerr &lt;&lt; <span class="hljs-string">&quot;No employees in the database.&quot;</span> &lt;&lt; std::endl;<br>     &#125;<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Database::displayFormer</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"> </span>&#123;<br>     <span class="hljs-keyword">if</span> (!mEmployees.<span class="hljs-built_in">empty</span>()) <br>     &#123;<br>         <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; employee : mEmployees)<br>         &#123;<br>             <span class="hljs-keyword">if</span> (employee-&gt;<span class="hljs-built_in">isHired</span>() == <span class="hljs-literal">false</span>)<br>             &#123;<br>                 employee-&gt;<span class="hljs-built_in">display</span>();<br>             &#125;<br>         &#125;<br>         cout &lt;&lt; <span class="hljs-string">&quot;Former employees are printed above&quot;</span> &lt;&lt; endl;<br>     &#125;<br>     <span class="hljs-keyword">else</span> <br>     &#123;<br>         std::cerr &lt;&lt; <span class="hljs-string">&quot;No employees in the database.&quot;</span> &lt;&lt; std::endl;<br>     &#125;<br> &#125;<br>&#125;<br><br><span class="hljs-comment">/*--------------------------------------------分隔符---------------------------------------------------*/</span><br><br><span class="hljs-comment">// UItest.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;exception&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;limits&gt;</span>           <span class="hljs-comment">// 用于清除输入缓冲区</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Database.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><span class="hljs-keyword">using</span> std::string;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">displayMenu</span><span class="hljs-params">()</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doHire</span><span class="hljs-params">(Records::Database&amp; db)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doFire</span><span class="hljs-params">(Records::Database&amp; db)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doPromote</span><span class="hljs-params">(Records::Database&amp; db)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doDemote</span><span class="hljs-params">(Records::Database&amp; db)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> Records::Database employeeDB;<br> <span class="hljs-type">bool</span> done = <span class="hljs-literal">false</span>;<br> <span class="hljs-keyword">while</span> (!done)<br> &#123;<br>     <span class="hljs-type">int</span> selection = <span class="hljs-built_in">displayMenu</span>();<br>     <span class="hljs-keyword">switch</span> (selection)<br>     &#123;<br>     <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>         done = <span class="hljs-literal">true</span>;<br>         <span class="hljs-keyword">break</span>;<br>     <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>         <span class="hljs-built_in">doHire</span>(employeeDB);<br>         <span class="hljs-keyword">break</span>;<br>     <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>         <span class="hljs-built_in">doFire</span>(employeeDB);<br>         <span class="hljs-keyword">break</span>;<br>     <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>         <span class="hljs-built_in">doPromote</span>(employeeDB);<br>         <span class="hljs-keyword">break</span>;<br>     <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>         employeeDB.<span class="hljs-built_in">displayAll</span>();<br>         <span class="hljs-keyword">break</span>;<br>     <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>         employeeDB.<span class="hljs-built_in">displayCurrent</span>();<br>         <span class="hljs-keyword">break</span>;<br>     <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>         employeeDB.<span class="hljs-built_in">displayFormer</span>();<br>         <span class="hljs-keyword">break</span>;<br>     <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<br>         employeeDB.<span class="hljs-built_in">removeUnhiredEmployee</span>();<br>         <span class="hljs-keyword">break</span>;<br>     <span class="hljs-keyword">default</span>:<br>         std::cerr &lt;&lt; <span class="hljs-string">&quot;Unknown command.&quot;</span> &lt;&lt; endl;<br>         <span class="hljs-keyword">break</span>;<br>     &#125;<br> &#125;<br><br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* displayMenu() 函数输出菜单获取用户输入。</span><br><span class="hljs-comment">在此假定用户能够“正确地输入”，当需要一个数字时就输入一个数字，这一点很重要。</span><br><span class="hljs-comment">在阅读了第 13 章有关 I / O 的内容后，你就会知道如何防止输入错误信息*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">displayMenu</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-type">int</span> selection;<br> cout &lt;&lt; endl;<br> cout &lt;&lt; <span class="hljs-string">&quot;Employee Database&quot;</span> &lt;&lt; endl;<br> cout &lt;&lt; <span class="hljs-string">&quot;-----------------&quot;</span> &lt;&lt; endl;<br> cout &lt;&lt; <span class="hljs-string">&quot;1) Hire a new employee&quot;</span> &lt;&lt; endl;<br> cout &lt;&lt; <span class="hljs-string">&quot;2) Fire an employee&quot;</span> &lt;&lt; endl;<br> cout &lt;&lt; <span class="hljs-string">&quot;3) Promote an employee&quot;</span> &lt;&lt; endl;<br> cout &lt;&lt; <span class="hljs-string">&quot;4) List all employees&quot;</span> &lt;&lt; endl;<br> cout &lt;&lt; <span class="hljs-string">&quot;5) List all current employee&quot;</span> &lt;&lt; endl;<br> cout &lt;&lt; <span class="hljs-string">&quot;6) List all former employee&quot;</span> &lt;&lt; endl;<br> cout &lt;&lt; <span class="hljs-string">&quot;7) Remove all unhired employees&quot;</span> &lt;&lt; endl;<br> cout &lt;&lt; <span class="hljs-string">&quot;0) Quit&quot;</span> &lt;&lt; endl;<br> cout &lt;&lt; <span class="hljs-string">&quot;---&gt;   &quot;</span>;<br><br> <span class="hljs-comment">// 循环，直到得到有效的输入</span><br> <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br> &#123;<br>     <span class="hljs-comment">// 尝试读取用户输入</span><br>     <span class="hljs-keyword">try</span><br>     &#123;<br>         std::cin &gt;&gt; selection;<br><br>         <span class="hljs-comment">// 检查输入流的状态</span><br>         <span class="hljs-keyword">if</span> (std::cin.<span class="hljs-built_in">fail</span>())<br>         &#123;<br>             <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;Invalid input. Please enter a number.&quot;</span>);<br>         &#125;<br><br>         <span class="hljs-comment">// 如果程序能够执行到这里，说明输入是有效的</span><br>         <span class="hljs-keyword">break</span>;<br>     &#125;<br>     <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::invalid_argument&amp; exception)<br>     &#123;<br>         std::cerr &lt;&lt; <span class="hljs-string">&quot;Error: &quot;</span> &lt;&lt; exception.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br><br>         <span class="hljs-comment">// 清除错误状态</span><br>         std::cin.<span class="hljs-built_in">clear</span>();<br><br>         <span class="hljs-comment">// 忽略缓冲区中的无效字符，直到遇到换行符</span><br>         std::cin.<span class="hljs-built_in">ignore</span>(std::numeric_limits&lt;std::streamsize&gt;::<span class="hljs-built_in">max</span>(), <span class="hljs-string">&#x27;\n&#x27;</span>);<br>     &#125;<br> &#125;<br><br> <span class="hljs-keyword">return</span> selection;<br>&#125;<br><br><span class="hljs-comment">/* doHire() 函数获取用户输入的新雇员的姓名，并通知数据库添加这个雇员*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doHire</span><span class="hljs-params">(Records::Database&amp; db)</span></span><br><span class="hljs-function"></span>&#123;<br> string firstName;<br> string lastName;<br><br> cout &lt;&lt; <span class="hljs-string">&quot;First name? input: &quot;</span>;<br> std::cin &gt;&gt; firstName;<br><br> cout &lt;&lt; <span class="hljs-string">&quot;Last name? input: &quot;</span>;<br> std::cin &gt;&gt; lastName;<br><br> db.<span class="hljs-built_in">addEmployee</span>(firstName, lastName);<br>&#125;<br><br><span class="hljs-comment">/* doFire() 、doPromote() 以及 doDemote() 函数都要求数据库根据雇员号找到雇员，然后使用 Employee 对象的 public 方法进行修改*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doFire</span><span class="hljs-params">(Records::Database&amp; db)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-type">int</span> employeeNumber;<br><br> cout &lt;&lt; <span class="hljs-string">&quot;Employee number? input: &quot;</span>;<br> std::cin &gt;&gt; employeeNumber;<br><br> <span class="hljs-comment">// 将 try 遇到的问题抛出，并继续执行程序</span><br> <span class="hljs-keyword">try</span><br> &#123;<br>     <span class="hljs-keyword">if</span> (db.<span class="hljs-built_in">getEmployee</span>(employeeNumber)-&gt;<span class="hljs-built_in">isHired</span>())<br>     &#123;<br>         db.<span class="hljs-built_in">getEmployee</span>(employeeNumber)-&gt;<span class="hljs-built_in">fire</span>();<br>         cout &lt;&lt; <span class="hljs-string">&quot;Employee &quot;</span> &lt;&lt; employeeNumber &lt;&lt; <span class="hljs-string">&quot;is terminated.&quot;</span> &lt;&lt; endl;<br>     &#125;<br>     <span class="hljs-keyword">else</span><br>     &#123;<br>         std::cerr &lt;&lt; <span class="hljs-string">&quot;Employee has been fired&quot;</span> &lt;&lt; endl;<br>     &#125;<br> &#125;<br> <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::logic_error&amp; exception)<br> &#123;<br>     std::cerr &lt;&lt; <span class="hljs-string">&quot;Unable to terminate employee: &quot;</span> &lt;&lt; exception.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br> &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doPromote</span><span class="hljs-params">(Records::Database&amp; db)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-type">int</span> employeeNumber;<br> <span class="hljs-type">int</span> raiseAmount;<br><br> cout &lt;&lt; <span class="hljs-string">&quot;Employee number? input: &quot;</span>;<br> std::cin &gt;&gt; employeeNumber;<br><br> cout &lt;&lt; <span class="hljs-string">&quot;How much of a raise? input: &quot;</span>;<br> std::cin &gt;&gt; raiseAmount;<br><br> <span class="hljs-keyword">try</span><br> &#123;<br>     <span class="hljs-keyword">if</span> (db.<span class="hljs-built_in">getEmployee</span>(employeeNumber)-&gt;<span class="hljs-built_in">isHired</span>())<br>     &#123;<br>         db.<span class="hljs-built_in">getEmployee</span>(employeeNumber)-&gt;<span class="hljs-built_in">promote</span>(raiseAmount);<br>         cout &lt;&lt; <span class="hljs-string">&quot;Employee &quot;</span> &lt;&lt; employeeNumber &lt;&lt; <span class="hljs-string">&quot;is promoted.&quot;</span> &lt;&lt; endl;<br>     &#125;<br>     <span class="hljs-keyword">else</span><br>     &#123;<br>         std::cerr &lt;&lt; <span class="hljs-string">&quot;Employee has been fired&quot;</span> &lt;&lt; endl;<br>     &#125;<br> &#125;<br> <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::logic_error&amp; exception)<br> &#123;<br>     std::cerr &lt;&lt; <span class="hljs-string">&quot;Unable to promote employee: &quot;</span> &lt;&lt; exception.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br> &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doDemote</span><span class="hljs-params">(Records::Database&amp; db)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-type">int</span> employeeNumber;<br> <span class="hljs-type">int</span> demeritAmount;<br><br> cout &lt;&lt; <span class="hljs-string">&quot;Employee number? input: &quot;</span>;<br> std::cin &gt;&gt; employeeNumber;<br><br> cout &lt;&lt; <span class="hljs-string">&quot;How much of a demerit? input: &quot;</span>;<br> std::cin &gt;&gt; demeritAmount;<br><br> <span class="hljs-keyword">try</span><br> &#123;<br>     db.<span class="hljs-built_in">getEmployee</span>(employeeNumber)-&gt;<span class="hljs-built_in">demote</span>(demeritAmount);<br> &#125;<br> <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> std::logic_error&amp; exception)<br> &#123;<br>     std::cerr &lt;&lt; <span class="hljs-string">&quot;Unable to promote employee: &quot;</span> &lt;&lt; exception.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><hr><h3 id="1-7-本章小结"><a href="#1-7-本章小结" class="headerlink" title="1.7    本章小结"></a><strong>1.7    本章小结</strong></h3><hr><ul><li>我上面所书写的代码并不是按照书上的格式写的，我使用了智能指针来实现这个工程，而不是书上说书写的 Employee 类的 vector，而是它的智能指针的 vector； </li><li>现在已经了解了 C++的基本知识，为成为专业 C++程序员做好了准备。在开始深入学习本书后面的 C++ 语言知识时，可查阅本章以回顾需要复习的内容。为了回顾那些被遗忘的概念，只需要查看本章的一些示例代码。</li><li>编写的每个程序都必须以这样或那样的方式使用字符串。为此，下一章将深入讲解如何在 C++ 中处理字符串。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 复习教程第九章（精通类与对象）</title>
    <link href="/2024/03/14/C++%20%E5%A4%8D%E4%B9%A0%E6%95%99%E7%A8%8B%E7%AC%AC%E4%B9%9D%E7%AB%A0%EF%BC%88%E7%B2%BE%E9%80%9A%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%89/"/>
    <url>/2024/03/14/C++%20%E5%A4%8D%E4%B9%A0%E6%95%99%E7%A8%8B%E7%AC%AC%E4%B9%9D%E7%AB%A0%EF%BC%88%E7%B2%BE%E9%80%9A%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="第9章-——-精通类与对象"><a href="#第9章-——-精通类与对象" class="headerlink" title="第9章 —— 精通类与对象"></a>第9章 —— 精通类与对象</h2><blockquote><p>第8章讲述了类和对象，这一章将讲述其精妙之处——如何操纵并利用 C++ 语言中最复杂的特性，以编写安全、有效、有用的类。本章的许多概念会出现在 C++ 高级编程中，特别是 标准库。</p></blockquote><hr><h3 id="9-1友元"><a href="#9-1友元" class="headerlink" title="9.1友元"></a>9.1友元</h3><blockquote><p>C++ 允许某个类将其他类、其他类的成员函数或非成员函数声明为 友元(friend)，友元可以访问类的 protected、private 数据成员和方法。例如，假设有两个类 Foo 和 Bar。可将 Bar 类指定为 Foo 类的友元，如下例所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span><br>&#123;<br><span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bar</span>;<span class="hljs-comment">// 认为 Bar 是 friend，但是不代表 Bar 也认定 Foo 为 friend</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>现在，<strong>Bar 类的所有成员可访问 Foo 类的 private、protected 数据成员和方法。</strong></p><p>也可将 Bar 类的一个特定方法作为友元。假设 Bar 类拥有一个 processFoo(const Foo&amp; foo) 方法，下面的语法将该方法成为 Foo 类的友元：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">calss Foo<br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">Bar::processFoo</span><span class="hljs-params">(<span class="hljs-type">const</span> Foo&amp; foo)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>独立函数也可以成为类的友元。例如，假设要编写一个函数，将 Foo 对象的所有数据转储到控制台。你可能希望将这个函数放在 Foo 类之外，以模拟外部审计，但该函数应当可以访问 Foo 对象的内部数据成员，对其进行适当检查。下面是 Foo 类定义和 dumpFoo() 友元函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span><br>&#123;<br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">dumpFoo</span><span class="hljs-params">(<span class="hljs-type">const</span> Foo&amp; foo)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>类中的 friend 声明用作函数的原型。不需要在别处编写原型(当然，如果你那样做，也无害处)。</p><p>下面是函数定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dumpFoo</span><span class="hljs-params">(<span class="hljs-type">const</span> Foo&amp; foo)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// Dump all data of foo to the console, including</span><br><span class="hljs-comment">// private and protected data members.</span><br><span class="hljs-comment">// 该函数可以获取了访问 dumpFoo 的 成员 </span><br>&#125;<br></code></pre></td></tr></table></figure><p>你编写的函数与其他函数类似，只是可以用这个函数直接访问 Foo 类的 private 和 protected 数据成员。在函数定义中不需要重复使用 friend 关键字。</p><p><strong>注意类需要知道其他哪些类、方法或函数希望成为友元；类、方法或函数不能将自身声明为其他类的友元并访问这些类的非公有名称。</strong></p><p>friend 类和方法很容易被滥用；友元可以违反封装原则，将类的内部暴露给其他类或函数。因此，只有在特定的情况下才应该使用它们，本章将穿插介绍一些用例。</p></blockquote><hr><h3 id="9-2对象的动态内存分配"><a href="#9-2对象的动态内存分配" class="headerlink" title="9.2对象的动态内存分配"></a>9.2对象的动态内存分配</h3><blockquote><p>为解决在程序实际运行前，并不知道需要多少内存的问题；那么就要动态地分配内存。类也不例外，有时不知道某个对象需要多少内存，在这种情况下，就要动态内存分配。但是，对于类而言，它的构建、复制、析构、赋值等就面临内存泄漏的严重问题，这种情况就需要我们对析构、复制、赋值函数进行重新构造。</p></blockquote><hr><h4 id="2-1Spreadsheet-类"><a href="#2-1Spreadsheet-类" class="headerlink" title="2.1Spreadsheet 类"></a>2.1Spreadsheet 类</h4><blockquote><p>与 SpreadsheetCell 类 类似，Spreadsheet 类将在本章中不断被完善。因此我们将在不断尝试中，说明编写类的最佳方法。</p><p>Spreadsheet 的最初版本只是一个 Spreadsheet 类的二维数组，其中具有设置和获取 SpreadsheetCell 中特定的类的最佳方式，其中具有设置和获取 Spreadsheet 中特定位置单元格的方法。尽管大多数电子表格应用程序为了指定单元格，会在一个方向上使用字母，但此处的 Spreadsheet 类在两个方向上均使用数字(仅为说明应该如何构建类)，下面为一个简单定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++">&gt;<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span><br>&gt;<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;SpreadsheetCell.h&quot;</span></span><br><br>&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Spreadsheet</span><br>&gt;&#123;<br>&gt;<span class="hljs-keyword">public</span>:<br>&gt;<span class="hljs-built_in">SpreadsheetCell</span>(<span class="hljs-type">size_t</span> width, <span class="hljs-type">size_t</span> height);<br>&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setCellAt</span><span class="hljs-params">(<span class="hljs-type">size_t</span> x, <span class="hljs-type">size_t</span> y, <span class="hljs-type">const</span> SpreadsheetCell&amp; cell)</span></span>;<br>&gt;<span class="hljs-function">SpreadsheetCell&amp; <span class="hljs-title">getCellAt</span><span class="hljs-params">(<span class="hljs-type">size_t</span> x, <span class="hljs-type">size_t</span> y)</span></span>;<br><br>&gt;<span class="hljs-keyword">private</span>:<br>&gt;<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">inRange</span><span class="hljs-params">(<span class="hljs-type">size_t</span> value, <span class="hljs-type">size_t</span> upper)</span> <span class="hljs-type">const</span></span>;<br>&gt;<span class="hljs-type">size_t</span> mWidth = <span class="hljs-number">0</span>;<br>&gt;<span class="hljs-type">size_t</span> mHeight = <span class="hljs-number">0</span>;<br>&gt;SpreadsheetCell** mCells = <span class="hljs-literal">nullptr</span>;<br>&gt;&#125;;<br><br>&gt;<span class="hljs-comment">/* 注意：这里仍然使用的是 SpreadsheetCell 的普通指针。这一方法将贯穿整个第 9 章，目的是说明因果关系，以及金额是如何在类中处理动态内存分配问题。在产品中，应该使用标准的 C++ 容器，例如：std::vector 的嵌套可极大地简化 Spreadsheet 类的实现，但是目前还没学习该如何使用裸指针正确处理动态内存，这如果不讲，当遇到旧代码可能会手足无措，那么接下来还是至少能够看懂这些代码的，所以还要讲。*/</span><br>&gt;<span class="hljs-comment">// 但是，在现代 C++ 中，绝对不要使用裸指针！！！</span><br>&gt;<span class="hljs-comment">// 因为，裸指针不仅语法复杂，而且内存泄漏、指针悬空出现得十分隐蔽。</span><br></code></pre></td></tr></table></figure><p>为什么不直接包含一个 Spreadsheet 二维数组，而是一个 Spreadsheet 的二阶指针？</p><blockquote><p>因为， Spreadsheet 对象的尺寸可能不同，如果给定二维数组，那么将失去调整宽度和高度的动态分配的灵活性。【在这里我们也知道，指针具有更高的灵活性，但是也继承了更多在内存则责任，安全性堪忧】，注意在 C++  中，不可能之编写 new SpreadsheetCell[mWidth] [mHeight],这与 Java 不同【这里为什么这样说，不能 new 出来一个二维数组，请看前面的第 7 章使用指针部分，哪里有关于这一点的详细说明】：</p></blockquote><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++">Spreadsheet::<span class="hljs-built_in">Spreadsheet</span>(<span class="hljs-type">size_t</span> width, <span class="hljs-type">size_t</span> height)<br>: <span class="hljs-built_in">mWidth</span>(width), <span class="hljs-built_in">mHeight</span>(height)<br>&#123;<br> mCells = <span class="hljs-keyword">new</span> SpreadsheetCell*[mWidth];<br> <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; mWidth; i++)<br> &#123;<br>     mCells[i] = <span class="hljs-keyword">new</span> Spreadsheet[mHeight];<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>堆栈为名为 s1 的 Spreadsheet 对象分配的内存，如图 9-1 所示，宽度为 4，高度为 3；</p><p><img src="https://bu.dusays.com/2024/03/15/65f446a080edd.png" alt="image-20240228142230920"></p><p>设置和获取方法的实现简单明了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++">&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Spreadsheet::setCellAt</span><span class="hljs-params">(<span class="hljs-type">size_t</span> x, <span class="hljs-type">size_t</span> y, <span class="hljs-type">const</span> SpreadsheetCell&amp; cell)</span></span><br><span class="hljs-function">&gt;</span>&#123;<br> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">inRange</span>(x, mWidth) || !<span class="hljs-built_in">inRange</span>(y, mHeight))<br> &#123;<br>     <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;&quot;</span>);<br> &#125;<br><br> mCell[x][y] = cell;<br>&gt;&#125;<br><br>&gt;<span class="hljs-function">SpreadsheetCell&amp; <span class="hljs-title">Spreadsheet::getCellAt</span><span class="hljs-params">(<span class="hljs-type">size_t</span> x, <span class="hljs-type">size_t</span> y)</span></span><br><span class="hljs-function">&gt;</span>&#123;<br> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">inRange</span>(x, mWidth) || !<span class="hljs-built_in">inRange</span>(y, mHeight))<br> &#123;<br>     <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;&quot;</span>)<br> &#125;<br><br> <span class="hljs-keyword">return</span> mCell[x][y];<br>&gt;&#125;<br><br>&gt;<span class="hljs-comment">// 上述代码使用了辅助方法 inRange() 检测 x 和 y  是否有效。试图通过索引范围外的数组元素将导致程序故障</span><br>&gt;<span class="hljs-comment">// 这个示例也是用了第 1 章提及，并将在第 14 章详细讲述的异常</span><br></code></pre></td></tr></table></figure><p>这时，我们看到实际上两个方法 setCellAt() 和 getCellAt() 中，有相当部分的代码是重复的，我们在第 6 章学过，要不惜一切地重用代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++">&gt;<span class="hljs-comment">// 依照复用的原则，那么定义 verifyCoordinate() 方法而非辅助方法 inRange()；</span><br>&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">verifyCoodination</span><span class="hljs-params">(<span class="hljs-type">size_t</span> x, <span class="hljs-type">size_t</span> y)</span> <span class="hljs-type">const</span></span>;<br><br>&gt;<span class="hljs-comment">// 实现该类检查指定坐标，如果坐标无效，则抛出异常：</span><br>&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Spreadsheet::verifyCoordinate</span><span class="hljs-params">(<span class="hljs-type">size_t</span> x, <span class="hljs-type">size_t</span> y)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">&gt;</span>&#123;<br> <span class="hljs-keyword">if</span> (x &gt;= mWidth || y &gt;= mHeight)<br> &#123;<br>     <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;&quot;</span>);<br> &#125;<br>&gt;&#125;<br><br>&gt;<span class="hljs-comment">// 重写 setCellAt() 和 getCellAt() 方法：</span><br>&gt;<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Spreadsheet::setCellAt</span><span class="hljs-params">(<span class="hljs-type">size_t</span> x, <span class="hljs-type">size_t</span> y, <span class="hljs-type">const</span> SpreadsheetCell&amp; cell)</span></span><br><span class="hljs-function">&gt;</span>&#123;<br> <span class="hljs-built_in">verifyCoordinate</span>(x, y);<br><br> mCell[x][y] = cell;<br>&gt;&#125;<br><br>&gt;<span class="hljs-function">SpreadsheetCell&amp; <span class="hljs-title">Spreadsheet::getCellAt</span><span class="hljs-params">(<span class="hljs-type">size_t</span> x, <span class="hljs-type">size_t</span> y)</span></span><br><span class="hljs-function">&gt;</span>&#123;<br> <span class="hljs-built_in">verifyCoordinate</span>(x, y);<br><br> <span class="hljs-keyword">return</span> mCell[x][y];<br>&gt;&#125;<br></code></pre></td></tr></table></figure></blockquote><hr><h4 id="2-2使用析构函数释放内存"><a href="#2-2使用析构函数释放内存" class="headerlink" title="2.2使用析构函数释放内存"></a>2.2使用析构函数释放内存</h4><blockquote><p>如果不再需要动态分配的内存，就必须释放它们。如果为对象动态分配了内存，就在析构函数中释放内存。当销毁对象时，编译器确保调用析构函数。下面是带有析构函数的 Spreadsheet 类定义。  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Spreadsheet</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Spreadsheet</span>(<span class="hljs-type">size_t</span> width, <span class="hljs-type">size_t</span> height);<br>~<span class="hljs-built_in">Spreadsheet</span>();<br><span class="hljs-comment">// Code omitted for brevity</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>析构函数与类(和构造函数)同名，名称前面有一个波浪号(~)。析构函数没有参数，并且只能有一个析构函数，为析构函数隐式地标记 noexcept，因为它们不应当抛出异常。</strong></p><p><strong>注意：</strong></p><p>​<strong>可使用 noexpect 标记函数，指示不会抛出异常。例如：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myNonThrowingFunction</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span> </span>&#123; <span class="hljs-comment">/* ... */</span>&#125;<br></code></pre></td></tr></table></figure><p><strong>析构函数隐式地使用 noexcept，因此不必专门添加这个关键字。</strong>**<strong>如果 noexcept 函数真的抛出了异常，程序将终止。</strong>有关 noexcept 的更多信息，以及为什么必须避免析构函数抛出异常的信息，详细参见第 14 章。</p><p>下面为析构函数 ~Spreadsheet() 进行实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++">Spreadsheet::~<span class="hljs-built_in">Spreadsheet</span>()<br>&#123;<br> <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; mWidth, i++)<br> &#123;<br>     <span class="hljs-keyword">delete</span> [] mCells[i];<br>     <span class="hljs-comment">// 释放一阶指针创建的二阶指针创建的数组资源</span><br> &#125;<br><br> <span class="hljs-keyword">delete</span> [] mCells;<br> <span class="hljs-comment">// 释放一阶指针创建的数组资源</span><br> mCells = <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>析构函数释放在构造函数中分配的内存。当然，并没有规则要求在析构函数中释放内存。在析构函数中可以编写任何代码，但最好让析构函数只释放内存或清理其他资源。</p></blockquote><hr><h4 id="2-3处理复制和赋值"><a href="#2-3处理复制和赋值" class="headerlink" title="2.3处理复制和赋值"></a>2.3处理复制和赋值</h4><blockquote><p>回顾第 8 章，如果没有自行编写复制构造函数或赋值运算符，C++ 将自动生成。编译器生成的方法递归调用对象数据成员的复制构造函数或赋值构造函数。然而对于基本类型，如 int、double 和 指针，只是提供表层(或按位)复制或赋值；只是将数据成员从元对象中直接复制或复制到目标对象。当为对象动态分配内存时，这样做会引发问题。例如，在下面的代码中，当 s1 传递给函数 printSpreadsheet() 时，复制了电子表格 s1 以初始化 s：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Spreadsheet.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printspreadsheet</span><span class="hljs-params">(Spreadsheet s)</span><span class="hljs-comment">// 复制步骤发生在这里，这是隐式匿名的</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// Code omitted for brevity.</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Spreadsheet <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-number">4</span>, <span class="hljs-number">3</span>)</span></span>;<br><span class="hljs-built_in">printSpreadsheet</span>(s1);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Spreadsheet 包含一个指针变量: mCells。 Spreadsheet 的表层复制向目标对象提供了一个 mCells 指针的副本,但没有复制底层数据【只复制浅层量，即，二阶指针创建的一阶指针数组】。最终结果是 s 和 s1 都有一个指向同一数据的指针，如图 9.2 所示。  </p><p><img src="https://bu.dusays.com/2024/03/15/65f446a265f11.png" alt="image-20240228144529144"></p><p>如果 s 修改了 mCells 所指的内容，这一改动也会在 s1 中表现出来。更糟糕的是，当函数 printSpreadsheet() 退出时，会调用 s 的析构函数【匿名函数自动调用析构函数，释放二阶指针所指空间】，释放 mCells 所指的内存。图 9-3 显示了这一状况 :</p><p><img src="https://bu.dusays.com/2024/03/15/65f446a3c6209.png" alt="image-20240228144729062"></p><p>现在 s1 拥有的指针所指的内存不再有效，这称为悬空指针(dangling pointer)。令人难以置信的是，当使用赋值时，情况会变得更糟。假定编写以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Spreadsheet <span class="hljs-title">s1</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)</span>, <span class="hljs-title">s2</span><span class="hljs-params">(<span class="hljs-number">4</span>, <span class="hljs-number">3</span>)</span></span>;<br>s1 = s2;<br></code></pre></td></tr></table></figure><p>在第一行后，当创建两个对象时，内存的布局如图 9-4 所示：</p><p><img src="https://bu.dusays.com/2024/03/15/65f446a5c2493.png" alt="image-20240228150434487"></p><p>当执行赋值语句后，内存布局如 9-5 所示：</p><p><img src="https://bu.dusays.com/2024/03/15/65f446a7bf26d.png" alt="image-20240228150527146"></p><p>现在，不仅 s1 和 s2 中的 mCell 指向同一内存，而且 s1 前面所指的内存被遗弃。这称为内存泄漏。这就是在赋值运算中进行自定义的深层复制的原因了。</p><p><strong>可以看出，依赖 C++ 默认的复制构造函数 或 赋值运算符 对于堆上的对象而言并不是健全的。</strong></p><p>警告：</p><p>​无论什么时候，在类中动态分配内存后，应该编写自己的复制构造函数和赋值运算符，以提供深层次的内存复制。</p><ol><li><p><strong>Spreadsheet 类的复制构造函数</strong></p><p>下面是 Spreadsheet 类中复制构造函数的声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Spreadsheet</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Spreadsheet</span>(<span class="hljs-type">const</span> Spreadsheet&amp; src);<br>&#125;;<br></code></pre></td></tr></table></figure><p>下面是复制构造函数的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++">Spreadsheet::<span class="hljs-built_in">Spreadsheet</span>(<span class="hljs-type">const</span> Spreadsheet&amp; src)<br> : <span class="hljs-built_in">Spreadsheet</span>(src.mWidth, src.mHeight)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; mWidth; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> j = <span class="hljs-number">0</span>; j &lt; mHeight; j++)<br>        &#123;<br>            mCells[i][j] = src.mCells[i][j];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意使用了委托构造函数。把这个复制构造函数的 ctor-initializer(构造函数初始化器)首先委托给非复制构造函数，以分配适当的内存量。复制构造函数此后复制实际值。总之，对 mCells 动态分配的二维数组进行了深层复制。</p></li><li><p><strong>Spreadsheet 类的赋值运算符</strong></p><p>下面是包含赋值运算符的 Spreadsheet 类定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Spreadsheet</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    Spreadsheet&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Spreadsheet&amp; rhs);<br>    <span class="hljs-comment">// Code omitted for brevity.</span><br>&#125;<br></code></pre></td></tr></table></figure><p>下面是一个不成熟的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++">Spreadsheet&amp; Spreadsheet::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Spreadsheet&amp; rhs)<br>&#123;<br>    <span class="hljs-comment">// Check for self-assignment</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;rhs)<br>    &#123;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>      <br>    <span class="hljs-comment">// Free the old memeory</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; mWidth; i++)<br>    &#123;<br>        <span class="hljs-keyword">delete</span> [] mCells[i];<br>    &#125;<br>    <span class="hljs-keyword">delete</span> [] mCells;<br>    mCells = <span class="hljs-literal">nullptr</span>;<br>      <br>    <span class="hljs-comment">// Allocate new memory</span><br>    mWidth = rhs.mWidth;<br>    mHeight = rhs.mHeight;<br>      <br>    mCells = <span class="hljs-keyword">new</span> SpreadsheetCell*[mWidth];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; mWidth; i++)<br>    &#123;<br>        mCells[i] = <span class="hljs-keyword">new</span> SpreadsheetCell[mHeight];<br>    &#125;<br>      <br>    <span class="hljs-comment">// Copy the data</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; mWidth; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> j = <span class="hljs-number">0</span>; j &lt; mHeight; j++)<br>        &#123;<br>            mCells[i][j] = rhs.mCells[i][j];<br>        &#125;<br>    &#125;<br>      <br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>这个方法存有不少问题，有不少地方会出错。this 对象可能进入无效状态。例如，假设成功释放了内存，合理设置了 mWidth 和 mHeight, 但分配内存的循环抛出了异常。如果发生这种情况，将不再执行该方法的剩余部分，而是从该方法中退出。此时，Spreadsheet 实例受损，它的 mWidth 和 mHeight 数据成员声明了指定大小，但 mCells 数据成员不具有适当的内存量。基本上，该代码不能安全地处理异常！</strong></p><p><strong>我们需要一种全有或全无的机制；要么全部成功，要么该对象保持不变。为实施这样一个能安全处理异常的赋值运算符，建议使用“复制和交换”惯用语法。这里将非成员函数 swap() 实现为 Spreadsheet 类的友元。如果不使用非成员函数 swap(), 那么可以给类添加 swap() 方法。但是，建议你练习将 swap() 实现为非成员函数，这样一来，各种标准库算法都可使用它。下面是包含 赋值运算符 和 swap 的函数的 Spreadsheet 类的定义</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Spreadsheet</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    Spreadsheet&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Spreadsheet&amp; rhs);<br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Spreadsheet&amp; first, Spreadsheet&amp; second)</span> <span class="hljs-type">const</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>要实现能安全处理异常的 “复制和交换” 惯用语法，要求 swap() 函数永不抛出异常，因此将其标记为 noexcept。swap() 函数的实现使用标准库中提供的 std::swap() 工具函数 (在头文件 <utility> 中定义)，交换每个数据成员:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Spreadsheet&amp; first, Spreadsheet&amp; second)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">using</span> std::swap;<br>      <br>    <span class="hljs-built_in">swap</span>(first.mWidth, second.mWidth);<br>    <span class="hljs-built_in">swap</span>(first.mHeight, second.mHeight);<br>    <span class="hljs-built_in">swap</span>(first.mCells, second.mCells);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在就有了能安全处理异常的 swap() 函数，它可用来实现赋值运算符：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++">Spreadsheet&amp; Spreadsheet::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Spreadsheet&amp; rhs)<br>&#123;<br>    <span class="hljs-comment">// Check for self-assignment</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> = &amp;rhs)<br>    &#123;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>      <br>    <span class="hljs-function">Spreadsheet <span class="hljs-title">temp</span><span class="hljs-params">(rhs)</span></span>;<span class="hljs-comment">// Do all the work in a temporary instance</span><br>    <span class="hljs-built_in">swap</span>(*<span class="hljs-keyword">this</span>, temp);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该实现使用“复制和交换”惯用语法。为提高效率，有时也为了正确性，赋值运算符的第一行检查自赋值。</p><p> 接下来，对右边进行复制，称为 temp。然后用这个副本替代*this。这个模式可确保“稳健地”安全处理异常(strong exception safety)。这意味着如果发生任何异常，当前的 Spreadsheet 对象保持不变。</p><p> 这通过三个阶段来实现：</p><ul><li>第一个阶段创建一个临时副本。这不修改当前 Spreadsheet 对象的状态，因此，如果在这个阶段发生异常，不会出现问题。</li><li>第二个阶段使用 swap()函数，将创建的临时副本与当前对象交换。swap() 永远不会抛出异常。</li><li>第三个阶段销毁临时对象(由于发生了交换，现在包含原始对象)以清理任何内存。</li></ul><p> 注意：</p><p> ​除复制外，C++ 还支持移动语义，移动语义需要移动构造函数和移动赋值运算符。在某些情况下，它们可以用来增强性能，稍后的章节“使用移动语义处理移动” 将对此进行详细讨论。</p></li><li><p><strong>禁止赋值和按值传递</strong><br>在类中动态分配内存时，如果只想禁止其他人复制对象或者为对象赋值，只需要显式地将 opemtok和复制构造函数标记为 delete。通过这种方法，当其他任何人按值传递对象时、从函数或方法返回对象时，或者为对象赋值时，编译器都会报错。下面的 Spreadsheet 类定义禁止赋值并按值传递：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Spreadsheet</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Spreadsheet</span>(<span class="hljs-type">size_t</span> width,<span class="hljs-type">size_t</span> height);<br>    <span class="hljs-built_in">Spreadsheet</span>(<span class="hljs-type">const</span> Spreadsheet&amp; src) = <span class="hljs-keyword">delete</span>;<br>    ~<span class="hljs-built_in">Spreadsheet</span>();<br>      <br>    Spreadsheet&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Spreadsheet&amp; rhs) = <span class="hljs-keyword">delete</span>;<br>    <span class="hljs-comment">// Code omitted for brevity</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>不需要提供 delete 复制构造函数和复制运算符的实现。链接器永远不会查看它们，因为编译器不允许代码调用它们。当代码复制 Spreadsheet 对象或者对 Spreadsheet 对象的赋值时，编译器将给出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-string">&#x27;Spreadsheet &amp;Spreadsheet::operator =(const Spreadsheet &amp;)&#x27;</span> : attempting to reference a deleted function<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>​<strong>如果编译器不支持显式地删除成员函数，那么可以把复制构造函数和赋值运算符标记为 private，且不提供任何实现，从而禁用复制和赋值。</strong></p></li></ol></blockquote><hr><h4 id="2-4使用移动语义处理移动"><a href="#2-4使用移动语义处理移动" class="headerlink" title="2.4使用移动语义处理移动"></a>2.4使用移动语义处理移动</h4><p>对象的移动语义(move semantics)需要实现移动构造函数(move constructor)和移动赋值符(move assignment operator)。如果源对象是操作结束后被销毁的临时对象，编译器就会使用这两个方法。移动构造函数和移动赋值运算符将数据成员从源对象移动到新对象，然后使得源对象处于有效但不确定的状态。通常会将源代码的数据成员重置为空值。这样做实际上将内存和其他资源的所有权从一个对象移动到另一个对象上，这两个方法基本上只是对成员变量进行表层复制(shallow copy)，然后转换已分配内存和其他资源的所有权，从而阻止悬空指针和内存泄漏。</p><p><strong>在实现移动语义前，需要学习右值(rvalue) 和 右值引用(rvalue reference)；</strong></p><ol><li><p><strong>右值引用</strong></p><p>左值(lvalue)：已分配地址(可获取其指针)的名称量。此外，所有不是左值的量都是右值(rvalue)。</p><p><strong>右值引用是对右值(rvlaue)的引用。特别地，这是一个当右值是临时对象时才适用的概念。右值引用的目的是在涉及临时对象时提供可选用的特定函数。由于知道临时对象会被销毁，通过右值引用，某些涉及复制大量值的操作可通过简单地复制指向这些值的指针来实现。</strong>  </p><p><strong>函数可将 &amp;&amp; 作为参数说明的一部分(例如 type &amp;&amp; name), 以指定右值引用参数。</strong>通常，临时对象被当作 const type&amp; , 但当函数重载使用了右值引用时，可以解析临时对象，用于该函数重载。下面的示例说明了这一点。代码首先定义了两个handleMessage() 函数，一个接收左值引用，另一个接收右值引用:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// lvalue reference parameter</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(std::string&amp; message)</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;handleMessage with lvalue reference: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-comment">// rvalue reference parameter</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(std::string&amp;&amp; message)</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;handleMessage with rvalue reference: &quot;</span> &lt;&lt; message &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>可使用具有名称的变量作为参数调用 handleMessage() 函数：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::string a = <span class="hljs-string">&quot;Hello&quot;</span>;<br>std::string b = <span class="hljs-string">&quot;World&quot;</span>;<br><span class="hljs-built_in">handleMessage</span>(a);<span class="hljs-comment">// Calls handleMessage(string&amp; value)</span><br><span class="hljs-comment">// 由于 a 是一个命名变量，调用 handleMessageo函数时，该函数接收一个左值引用。handleMessage() 函数通过其引用参数所执行的任何更改来更改 a 的值</span><br></code></pre></td></tr></table></figure><p><strong>注意：还可以用表达式作为参数来调用 handleMessage() 函数：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">handleMessage</span>(a + b);<br><span class="hljs-comment">// 此时无法使用接收左值引用作为参数的 handleMessage()函数，因为表达式 a+b 的结果是临时的，这不是一个左值。在此情况下，会调用右值引用版本。由于参数是一个临时值，handleMessage。函数调用结束后，会丢失通过引用参数所做的任何更改。</span><br></code></pre></td></tr></table></figure><p><strong>字面量也可作为 handleMessage() 调用的参数，此时同样会调用右值引用版本，因为字面量不能作为左值(但字面量可作为 const 引用形参的对应实参传递)。</strong>  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">handleMessage</span>(<span class="hljs-string">&quot;Hello World&quot;</span>);<span class="hljs-comment">// Calls handleMessage(std::string&amp;&amp; value)</span><br></code></pre></td></tr></table></figure><p><strong>如果删除接收左值引用的 handleMessage。函数，使用有名称的变量调用 handleMessage() 函数 (例如handleMessage(b)), 会导致编译错误，因为右值引用参数 (string&amp;&amp; message) 永远不会与左值(b)绑定。如下所示，可使用 std::move()将左值转换为右值，强迫编译器调用 handleMessage() 函数的右值引用版本：</strong>  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">handleMessage</span>(std::<span class="hljs-built_in">move</span>(b));<span class="hljs-comment">// Calls handleMessage(std::string&amp;&amp; value)</span><br></code></pre></td></tr></table></figure><p>重申一下，有名称的变量是左值，因此在 handleMessage() 函数中，右值引用参数 message 本身是一个左值，原因是它具有名称！如果希望将这个左值引用参数，作为右值传递【注意，不是复制】给另一个函数，则需要使用 std::move()，将左值转换为右值。例如，假设要添加以下函数使用右值引用参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">helper</span><span class="hljs-params">(std::string&amp;&amp; message)</span></span><br><span class="hljs-function"></span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果按照如下方法调用，则无法编译：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(std::string&amp;&amp; message)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">helper</span>(message);<br>&#125;<br></code></pre></td></tr></table></figure><p>helper() 函数需要使用右值引用，而 handleMessage() 函数传递 message，message 具有名称，因此是左值，导致编译错误。正确的方式是使用 std::move():</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(std::string&amp;&amp; message)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">helper</span>(std::<span class="hljs-built_in">move</span>(message));<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>警告：</strong></p><p>​<strong>有名称的右值引用，如右值引用参数，本身就是左值，因为它具有名称！</strong></p><p>右值引用并不局限于函数的参数。可声明右值引用类型的变量，并对其赋值，尽管这一用法并不常见。考虑下面的代码，在 C++ 中这是不合法的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span>&amp; i = <span class="hljs-number">2</span>;<span class="hljs-comment">// Invalid:reference to a constant</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">2</span>, b = <span class="hljs-number">3</span>;<br><span class="hljs-type">int</span>&amp; j = a + b;<span class="hljs-comment">// Invalid:reference to a temporary</span><br></code></pre></td></tr></table></figure><p>使用右值引用后，下面的代码完全合法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span>&amp;&amp; i = <span class="hljs-number">2</span>;<br><span class="hljs-type">int</span> a = <span class="hljs-number">2</span>, b = <span class="hljs-number">3</span>;<br><span class="hljs-type">int</span>&amp;&amp; j = a + b;<br><br><span class="hljs-comment">// 但是，单独使用右值引用的情况是十分少见的</span><br></code></pre></td></tr></table></figure></li><li><p><strong>实现移动语义</strong></p><p>移动语义是通过右值引用实现的。为了对类增加移动语义，需要实现移动构造函数和移动赋值运算符。移动构造函数和移动赋值运算符应使用 noexcept 限定符标记，这告诉编译器，它们不会抛出任何异常。这对于与标准库兼容非常重要，因为如果实现了移动语义，与标准库的完全兼容只会移动存储的对象，且确保不抛出异常。下面的 Spreadsheet 类定义包含一个移动构造函数和一个移动赋值运算符。也引入了两个辅助方法 cleanup。和 moveFrom()。前者在析构函数和移动赋值运算符中调用。后者用于把成员变量从源对象移动到目标对象，接着重置源对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Spreadsheet</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Spreadsheet</span>(Spreadsheet&amp;&amp; src) <span class="hljs-keyword">noexcept</span>;<span class="hljs-comment">// Move constructor</span><br>    Spreadsheet&amp; <span class="hljs-keyword">operator</span>=(Spreadsheet&amp;&amp; rhs) <span class="hljs-keyword">noexcept</span>;<span class="hljs-comment">// Move assign</span><br>    <br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cleanup</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">moveFrom</span><span class="hljs-params">(Spreadsheet&amp; src)</span> <span class="hljs-keyword">noexcept</span></span>;<br>    <span class="hljs-comment">// Remaining code omitted for brevity</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>实现代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Spreadsheet::cleanup</span><span class="hljs-params">()</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; mWidth; i++)<br>    &#123;<br>        <span class="hljs-keyword">delete</span> [] mCells[i];<br>    &#125;<br>    <span class="hljs-keyword">delete</span> [] mCells;<br>    mCells = <span class="hljs-literal">nullptr</span>;<br>    <br>    mWidth = mHeight = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Spreadsheet::moveForm</span><span class="hljs-params">(Spreadsheet&amp; src)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// Shallow copy(浅复制) of data</span><br>    <span class="hljs-comment">// 通过浅复制将指针总输入的源函数 src 拷贝到 *this 对象中</span><br>    mWidth = src.mWidth;<br>    mHeight = src.mHeight;<br>    mCells = <span class="hljs-literal">nullptr</span>;<br>    <br>    <span class="hljs-comment">// Reset the source object, because ownership has been moved!</span><br> src.mWidth = <span class="hljs-number">0</span>;<br> src.mHeight = <span class="hljs-number">0</span>;<br> src.mCells = <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-comment">// Move constructor</span><br>Spreadsheet::<span class="hljs-built_in">Spreadsheet</span>(Spreadsheet&amp;&amp; src) noexcpet<br>&#123;<br>    <span class="hljs-built_in">moveForm</span>(src);<br>&#125;<br><br><span class="hljs-comment">// Move assignment operator</span><br>Spreadsheet&amp; Spreadsheet::<span class="hljs-keyword">operator</span>=(Spreadsheet&amp;&amp; src) <span class="hljs-keyword">noexcept</span><br>&#123;<br>    <span class="hljs-comment">// check for self-assignment</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;rhs)<br>    &#123;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">//  free the old memory</span><br>    <span class="hljs-built_in">cleanup</span>();<br>    <br>    <span class="hljs-built_in">moveFrom</span>(rhs);<br>    <br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>移动构造函数和移动赋值运算符都将 mCells 的内存所有权从源对象移动到新对象，这两个方法将源对象的 mCells 指针设置为空指针，以防源对象的析构函数释放这块内存，因为新的对象现在拥有了这块内存。</strong></p><p><strong>很明显，只有你知道将销毁源对象时，移动语义才有用。</strong></p><p>例如，就像普通的构造函数或复制赋值运算符一样，<strong>可显式将移动构造函数和&#x2F;或移动赋值运算符设置为默认或将其删除，如第 8 章所述。</strong></p><p><strong>仅当类没有用户声明的复制构造函数、复制赋值运算符、移动赋值运算符或析构函数时，编译器才会为类自动生成默认的移动构造函数。仅当类没有用户声明的复制构造函数、移动构造函数、复制赋值运算符或析构函数时，才会为类生成默认的移动赋值运算符。</strong>  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 普通构造函数</span><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> value) : <span class="hljs-built_in">data_</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(value)) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;普通构造函数被调用\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 移动构造函数</span><br>    <span class="hljs-built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">data_</span>(other.data_) &#123;<br>        other.data_ = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 移动后将源对象的指针置为nullptr</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;移动构造函数被调用\n&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 其他成员函数和数据成员的定义...</span><br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>* data_;<br><br>    <span class="hljs-comment">// 其他私有成员函数和数据成员的定义...</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 调用普通构造函数</span><br>    <span class="hljs-function">MyClass <span class="hljs-title">obj1</span><span class="hljs-params">(<span class="hljs-number">42</span>)</span></span>;<br><br>    <span class="hljs-comment">// 调用移动构造函数</span><br>    MyClass obj2 = std::<span class="hljs-built_in">move</span>(obj1);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// 这里就知道什么时候时普通构造什么时候是复制构造函数了</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><p><strong>如果类中动态分配了内存，则通常应当实现析构函数、复制构造函数、移动构造函数、复制赋值运算符和移动赋值运算符，这称为 “5 规则”(Rule of Five)。</strong></p><p><strong>移动对象数据成员：</strong></p><p>​<strong>moveFrom() 方法对三个数据成员直接赋值，因为这些成员都是基本类型。如果对象还将其他对象作为数据成员，则应当使用 std::move()移动这些对象。</strong>假设 Spreadsheet 类有一个名为 mName 的 std::string 数据成员。接着采用以下方式实现 moveFrom()方法：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Spreadsheet::moveFrom</span><span class="hljs-params">(Spreadsheet&amp; src)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// Move object data members</span><br>    mName = std::<span class="hljs-built_in">move</span>(src.mName);<br>    <span class="hljs-comment">// 这里是说，如果有其他的类作为此类的成员，那么就调用它的移动构造函数进行转移</span><br>    <br>    <span class="hljs-comment">// Move primitive</span><br>    <span class="hljs-comment">// Shallow copy of data</span><br>    mWidth = src.mWidth;<br>    mHeight = src.mHeight;<br>    mCells = src.mCells;<br>    <br>    <span class="hljs-comment">// Reset the source object, because onwership has been move!</span><br>    src.mWidth = <span class="hljs-number">0</span>;<br>    src.mHeight = <span class="hljs-number">0</span>;<br>    src.mCells = <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>用交换方式实现移动构造函数和移动赋值运算符：</p><p>​前面的移动构造函数和移动赋值运算符的实现都使用了 moveFrom() 辅助方法，该辅助方法通过执行浅表复制来移动所有数据成员。<strong>在此实现中，如果给 Spreadsheet 类添加新的数据成员，则必须修改 swap() 函数和 moveFrom() 方法。如果忘了更新其中的一个，则会引入 bug。为避免此类 bug, 可使用默认构造函数和 swap() 函数，编写移动构造函数和移动赋值运算符</strong>。</p><p><strong>首先给 Spreadsheet 类添加默认构造函数。不应当让类的用户使用这个默认构造函数，故将其标记为 private</strong>：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Spreadsheet</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-built_in">Spreadsheet</span>() = dafault;<br>    <span class="hljs-comment">// Remaining code omitted for brevity</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>接下来，可删除 cleanup() 和 moveFrom() 辅助方法，将 cleanup() 方法中的代码移入析构函数。此后，可按如下方式实现移动构造函数和移动赋值运算符:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++">Spreadsheet::<span class="hljs-built_in">Spreadsheet</span>(Spreadsheet&amp;&amp; src) <span class="hljs-keyword">noexcept</span><br>    : <span class="hljs-built_in">Spreadsheet</span>()<br>&#123;<br>    <span class="hljs-built_in">swap</span>(*<span class="hljs-keyword">this</span>, src);<br>&#125;<br><br>Spreadsheet&amp; Spreadsheet::<span class="hljs-keyword">operator</span>=(Spreadsheet&amp;&amp; rhs) <span class="hljs-keyword">noexcept</span><br>&#123;<br>    Spreadsheet <span class="hljs-built_in">temp</span>(std::<span class="hljs-built_in">move</span>(rhs));<br>    <span class="hljs-built_in">swap</span>(*<span class="hljs-keyword">this</span>, temp);<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>移动构造函数首先委托给默认构造函数。此后，对默认构造的 *this 与给定的源对象进行交换。移动赋值运算符首先使用 std::move(rhs), 创建一个本地 Spreadsheet 实例，然后将这个本地 Spreadsheet 实例与 *this 交换。与前面使用 moveFrom() 的实现相比，使用默认构造函数和 swap() 函数实现移动构造函数和移动赋值运算符的效率稍微差一些。但这种做法也有优点，它需要的代码较少，将数据成员添加到类时，需要的代码较少，也不太可能引入 bug, 因为只需要更新 swap() 实现，加入新的数据成员即可。</p></li><li><p><strong>测试 Spreadsheet 移动运算</strong></p><p>可使用以下代码来测试 Spreadsheet 移动构造函数和移动复制赋值运算符：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Spreadsheet <span class="hljs-title">createObject</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Spreadsheet</span>(<span class="hljs-number">3</span>, <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;Spreadsheet&gt; vec;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)<br>    &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Iteration &quot;</span> &lt;&lt; i &lt;&lt; std::endl;<br>        vec.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">Spreadsheet</span>(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>));<br>        std::cout &lt;&lt; std::endl;<br>    &#125;<br>    <br>    <span class="hljs-function">Spreadsheet <span class="hljs-title">s</span><span class="hljs-params">(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span></span>;<br>    s = <span class="hljs-built_in">createObject</span>();<br>    <br>    <span class="hljs-function">Spreadsheet <span class="hljs-title">s2</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>)</span></span>;<br>    s2 = s;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 输出：</span><br>Iteration <span class="hljs-number">0</span><br>Normal constructor<br>Move constructor<br><br>Iteration <span class="hljs-number">1</span><br>Normal constructor<br>Move constructor<br>Move constructor<br><br>Normal constructor<br>Normal constructor<br>Move assignment <span class="hljs-keyword">operator</span><br>Normal constructor<br>Copy assignment <span class="hljs-keyword">operator</span><br>Normal constructor<br>Copy constructor<br></code></pre></td></tr></table></figure><p>第一章 引入了 vector。vector 的大小会动态增长以容纳新对象，为此，可分配较大的内存块，然后将对象复制到(或移动到)较大、新的 vector。如果编译器发下来移动构造函数，那么就移动而不深拷贝。</p><p>上述的内容具体解释见课本，太复杂了，我这里不赘述。真是烦死了这个构造。</p><p>我这里就强调一点：怎么看到底是移动还是普通——就是看它的右侧的源对象是否要被销毁，或者说是不是一个“字面量”。</p></li><li><p><strong>使用移动语义实现交换函数</strong></p><p>考虑到交换两对象的 swap() 函数，这是另一个使用移动语义提供性能的示例。下面的 swapCopy() 实现没有使用移动语义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swapCopy</span><span class="hljs-params">(T&amp; a, T&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">T <span class="hljs-title">temp</span><span class="hljs-params">(a)</span></span>;<br>    a = b;<br>    b = temp;<br>&#125;<br></code></pre></td></tr></table></figure><p>这一实现是极其影响性能的，使用 std::move() 语义进行复写，可以极大提高性能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swapCopy</span><span class="hljs-params">(T&amp; a, T&amp; b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">T <span class="hljs-title">temp</span><span class="hljs-params">(std::move(a))</span></span>;<br>    a = std::<span class="hljs-built_in">move</span>(b);<br>    b = std;:<span class="hljs-built_in">move</span>(temp);<br>&#125;<br></code></pre></td></tr></table></figure><p>这正是标准库的 std::swap() 的实现方法。</p></li></ol><hr><h4 id="2-5零规则"><a href="#2-5零规则" class="headerlink" title="2.5零规则"></a>2.5零规则</h4><p>上述的五大特殊成员函数：</p><ol><li>析构函数</li><li>复制构造函数</li><li>移动构造函数</li><li>复制赋值运算符</li><li>移动赋值运算符</li></ol><p>都不要用！！！！！！！！！！！！！！！！！！！！</p><p>用标准库！！！！！！！！！！！！！！！！！！！！</p><p>所以，之前就是在扯淡？比如，使用 vector&lt;vector<SpreadsheetCell>&gt; 替代 Spreadsheet**，该 vector 会自动处理内存，而且很高效。</p><hr><h3 id="9-3与方法有关的更多内容"><a href="#9-3与方法有关的更多内容" class="headerlink" title="9.3与方法有关的更多内容"></a>9.3与方法有关的更多内容</h3><blockquote><p>C++ 为方法提供许多选择，本章将详细讲述。</p></blockquote><hr><h4 id="3-1静态方法"><a href="#3-1静态方法" class="headerlink" title="3.1静态方法"></a>3.1静态方法</h4><blockquote><p><strong>静态方法和普通方法的对比</strong>：</p><ul><li><strong>静态方法：</strong></li><li>被声明为<code>static</code>的方法是属于类而不是类的实例的。它们可以通过类名调用，而不需要创建类的实例。</li><li>静态方法不能直接访问非静态成员或成员函数，因为它们不与类的实例相关联，但可以访问类的 private 和 protected 静态数据成员。如果同一类型的其他对象对静态方法可见(例如传入了对象的指针或引用)，那么静态方法也可访问其他对象的 private 和 protected 非静态数据成员。</li><li>静态方法内部不能使用<code>this</code>指针，因为它们没有实例上下文。</li><li>静态方法可以被类的所有实例共享，也可以被类本身调用。</li><li><strong>普通方法：</strong></li><li>普通方法是类的实例的一部分，需要通过类的实例（对象）来调用。</li><li>可以访问和修改实例的非静态成员，可以使用<code>this</code>指针来引用当前实例。</li><li>普通方法与类的实例相关联，可以访问和修改实例的状态。</li></ul><p><strong>必要性和使用场景</strong>：</p><ol><li><strong>静态方法的必要性：</strong></li></ol><ul><li><strong>共享资源或功能：</strong> 静态方法通常用于实现与类本身相关的功能，而不是与实例相关的功能。例如，计算类的总数或提供与类相关的全局设置。</li><li><strong>工具函数：</strong> 静态方法可以用作类的工具函数，提供一些通用的操作，而不需要创建类的实例。</li><li><strong>避免创建实例：</strong> 如果某个方法与类的状态无关，而只与类的行为有关，可以将其声明为静态方法，以避免不必要的实例创建。</li></ul><ol start="2"><li><strong>普通方法的必要性：</strong></li></ol><ul><li><strong>操作实例状态：</strong> 如果方法需要访问或修改实例的状态，那么它应该是普通方法。普通方法可以使用<code>this</code>指针来引用当前实例。</li><li><strong>对象特定的行为：</strong> 如果方法的行为与实例的状态密切相关，且需要在多个地方使用，那么它可能是一个普通方法。</li><li><strong>面向对象编程：</strong> 普通方法是面向对象编程中的重要概念，它们强调了对象的封装性和行为。通过普通方法，类的实例可以表现出个体性和特定的行为。</li></ul><p> 示例：</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++">&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">SpreadsheetCell</span><br>&gt;&#123;<br>   <span class="hljs-comment">// Omitted for brevity</span><br>&gt;<span class="hljs-keyword">private</span>:<br>   <span class="hljs-function"><span class="hljs-type">static</span> std::string <span class="hljs-title">doubleToString</span><span class="hljs-params">(<span class="hljs-type">double</span> inValue)</span></span>;<br>   <span class="hljs-function"><span class="hljs-type">static</span> doubel <span class="hljs-title">stringToDouble</span><span class="hljs-params">(std::string_view inString)</span></span>;<br>&gt;&#125;<br></code></pre></td></tr></table></figure><p> 将这两个函数定义为 public，就可以在代码外使用它们，这时其实这种方法就有些类似于 命名空间 了。</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">&gt;string str = SpreadsheetCell::<span class="hljs-built_in">doubleToString</span>(<span class="hljs-number">5.0</span>);<br></code></pre></td></tr></table></figure></blockquote><hr><h4 id="3-2const-方法与-mutable"><a href="#3-2const-方法与-mutable" class="headerlink" title="3.2const 方法与 mutable"></a>3.2const 方法与 mutable</h4><p><strong>const</strong> **方法 ： **</p><blockquote><p>即，约定这些方法不改变任何数据成员，仅此而已。</p><p>只要记住，不想改变传入的数据，就既使用 const type&amp; 又使用 const 定义方法，这样就好。</p></blockquote><p><strong>mutable 方法 ：</strong></p><blockquote><p>有些编码从逻辑上是一种 const 方法，但是实际上它内部要进行一种“统计”或者说一种另外的对于用户来说毫无影响的某种操作。这时，我们会发现无论我们改变什么都不会被编译器允许，因为方法被定义为了 const ，但是总不能因为这种改动而去除 const 关键字，这样是不优雅的，而是采用将这种改动的成员变量定义为 mutable，这样对这样的成员进行的修改，将在编译器对 const 方法处理时忽略掉。</p><p>如下示例,对某种方法使用次数进行统计：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++">&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">SpreadsheetCell</span><br>&gt;&#123;<br>&gt;<span class="hljs-comment">// Omitted for brevity</span><br>&gt;<span class="hljs-keyword">private</span>:<br>&gt;<span class="hljs-type">double</span> mValue = <span class="hljs-number">0</span>;<br>&gt;<span class="hljs-keyword">mutable</span> <span class="hljs-type">size_t</span> mNumAccess = <span class="hljs-number">0</span>;<br>&gt;&#125;;<br><br>&gt;<span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">SpreadsheetCell::getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">&gt;</span>&#123;<br>&gt;mNumAccess++;<br>&gt;<span class="hljs-keyword">return</span> mNumAccess;<br>&gt;&#125;<br><br>&gt;<span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">SpreadsheetCell::getString</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">&gt;</span>&#123;<br>&gt;mNumberAccess++;<br>&gt;<span class="hljs-keyword">return</span> <span class="hljs-built_in">doubleToString</span>(mValue);<br>&gt;&#125;<br></code></pre></td></tr></table></figure></blockquote><hr><h4 id="3-3方法重载"><a href="#3-3方法重载" class="headerlink" title="3.3方法重载"></a>3.3方法重载</h4><blockquote><p>保持函数名不变，改动函数输入和输出类型，而使得编译器在面对不同的传入传出，做出不同的行为，这叫 重载解析(overload resolution)。但是，如果传入传出值不能完全确定出使用哪个重载函数，那么编译器就无从判断。</p><p>1.<strong>基于 const 的重载</strong></p><p>通常情况下，const 版本 和 非 const 版本 的实现是一样的，为避免代码重复，可使用 Scott Meyer 的 cosnt_cast() 模式。例如，，Spreadsheet 类中有 getCellAt() 方法，该方法返回 SpreadsheetCell 的非 const 引用。可添加 const 重载版本，它返回 SpreadsheetCell 的 const 引用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Spreadsheet</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br> <span class="hljs-function">SpreadsheetCell&amp; <span class="hljs-title">getCellAt</span><span class="hljs-params">(<span class="hljs-type">size_t</span> x, <span class="hljs-type">size_t</span> y)</span></span>;<br> <span class="hljs-function"><span class="hljs-type">const</span> SpreadsheetCell&amp; <span class="hljs-title">getCellAt</span><span class="hljs-params">(<span class="hljs-type">size_t</span> x, <span class="hljs-type">size_t</span> y)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>const getCellAt() 正常写，下面说明如何实现 Scott Meyer 的 const_cast 模式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">cosnt SpreadsheetCell&amp; <span class="hljs-title">Spreadsheet::getCellAt</span><span class="hljs-params">(<span class="hljs-type">size_t</span> x, <span class="hljs-type">size_t</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-built_in">verifyCoordinate</span>(x, y);<br> <span class="hljs-keyword">return</span> mCells[x][y];<br>&#125;<br><br><span class="hljs-function">SpreadsheetCell&amp; <span class="hljs-title">Spreadsheet::getCellAt</span><span class="hljs-params">(<span class="hljs-type">size_t</span> x, <span class="hljs-type">size_t</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-built_in">const_cast</span>&lt;SpreadsheetCell&amp;&gt;(std::<span class="hljs-built_in">as_const</span>(*<span class="hljs-keyword">this</span>).<span class="hljs-built_in">getCellAt</span>(x, y));<br> <span class="hljs-comment">// 以下代码也可以，上述代码需要 C++17 才能实现 as_const</span><br> <span class="hljs-keyword">return</span> <span class="hljs-built_in">const_cast</span>&lt;SpreadsheetCell&amp;&gt;(<span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> Spreadsheet&amp;&gt;(*<span class="hljs-keyword">this</span>).<span class="hljs-built_in">getCellAt</span>(x, y));<br>&#125;<br><span class="hljs-comment">// 这种 const_cast 语法类似于静态类型转换，也就是 static_cast </span><br></code></pre></td></tr></table></figure><p>这里貌似使用 const_cast() 模式的优势并不明显，但是想象一下随着 cosnt 方法实现的内容逐步增多，这样做能够节省很多代码空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Spreadsheet <span class="hljs-title">sheet1</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>)</span></span>;<br>SpreadsheetCell&amp; cell = sheet1.<span class="hljs-built_in">getCellAt</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br><br><span class="hljs-function"><span class="hljs-type">const</span> Spreadsheet <span class="hljs-title">sheet2</span><span class="hljs-params">(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>)</span></span>;<br><span class="hljs-type">const</span> SpreadhsheetCell&amp; cell2 = sheet2.<span class="hljs-built_in">getCellAt</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><ol start="2"><li><p><strong>显式删除重载</strong></p><p>重载方法可以被显式地删除，可以用这种方法对具有某种特定参数的成员函数进行禁止调用。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以用以下代码对 foo() 代码进行调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">MyClass c;<br>c.<span class="hljs-built_in">foo</span>(<span class="hljs-number">123</span>);<br>c.<span class="hljs-built_in">foo</span>(<span class="hljs-number">1.23</span>);<span class="hljs-comment">// 这里进行了隐式的类型转换</span><br></code></pre></td></tr></table></figure><p>下面定义方法则可以禁止这种隐式类型转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>= <span class="hljs-keyword">delete</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这样上述隐式转换将被报错。</p></li></ol></blockquote><hr><h4 id="3-4内联方法"><a href="#3-4内联方法" class="headerlink" title="3.4内联方法"></a>3.4内联方法</h4><blockquote><p>C++ 提供这样一种能力：**函数或方法的调用不应再生成的代码中实现，就像调用独立的代码块那样，编译器应将方法体或函数体直接插入到调用方法或函数的位置。这个过程叫做内联(inline)**，具有这一行为的函数或方法被称为内联函数或内联方法。</p><p>注意：</p><p><strong>内联比使用 #define 宏安全！</strong></p><p>可在方法或函数定义名称前使用 inline 关键字，将某个方法或函数定义为内联的。例如，要让 SpreadsheetCell 类的访问方法成为内联的，可以这样定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++">&gt;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title">SpreadsheetCell::getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">&gt;</span>&#123;<br>mNumAccess++;<br><span class="hljs-keyword">return</span> mValue;<br>&gt;&#125;<br><br>&gt;<span class="hljs-function"><span class="hljs-keyword">inline</span> std::string <span class="hljs-title">SpreadsheetCell::getString</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">&gt;</span>&#123;<br>mNumAccess++;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">doubleToString</span>(mValue);<br>&gt;&#125;<br></code></pre></td></tr></table></figure><p>这是提示编译器，用实际的方法体替换对 getValue() 和 getString() 的调用，而不是生成代码进行函数调用。注意， inline 关键字只是提示 编译器，如果编译器认为这样做会降低性能，那么就会忽略掉该关键字。</p><p>注意，在所有调用了内联函数或内联方法的源文件中，内敛方法或内联函数的定义必须有效。考虑到这个问题如果没有看到函数定义，那么编译器就无法完成函数体替换。因此——如果编写了内联函数或内联方法，就应该将定义与原型一起放在头文件中。</p><p>注意：</p><p><strong>高级 C++ 编译器不要求将内联方法放在头文件中。</strong>例如，Microsoft Visual C++ 支持连接时代码生成(LTCG)，会自动将较小的函数内联，即使这些函数没有声明为内联函数或者没有在头文件中定义，同样也如此。<strong>可以利用这一点，不需要将定义放在头文件中，这样可以保证接口整洁，因为在接口文件中看不到任何实现细节。示例如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++">&gt;<span class="hljs-comment">// MathUtils.h</span><br>&gt;<span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br>&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">MathUtils</span> <br>&gt;&#123;<br>&gt;<span class="hljs-keyword">public</span>:<br>&gt;<span class="hljs-comment">// 内联函数的声明</span><br>&gt;<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>;<br>&gt;&#125;;<br><br>&gt;<span class="hljs-comment">// MathUtils.cpp</span><br>&gt;<span class="hljs-comment">// 内联函数的定义（放在头文件中）</span><br>&gt;<span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">MathUtils::square</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span><br><span class="hljs-function">&gt;</span>&#123;<br>&gt;<span class="hljs-keyword">return</span> x * x;<br>&gt;&#125;<br></code></pre></td></tr></table></figure><p><strong>另一种定义内联的方法</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++">&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">Spreadsheetcell</span><br>&gt;&#123;<br>&gt;<span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// Omitted for brevity</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span><br><span class="hljs-function"></span>&#123;<br>    mNumAccesses++; <br>    <span class="hljs-keyword">return</span> mValue; <br>&#125;<br><span class="hljs-function">std::string <span class="hljs-title">getString</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>mNumAccesses++;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">doubleToString</span>(mValue);<br>&#125;<br><span class="hljs-comment">// Omitted for brevity</span><br>&gt;&#125;;<br></code></pre></td></tr></table></figure><p>注意：</p><p>​如果使用调试器单步调试内联函数的调用，某些高级 C++ 调试器会跳到内联函数实际的源代码处，这就好似依旧是在进行函数调用的假象【内联不是调用，内联函数的使用可能会增加最终的编译文件大小。内联函数的主要优势在于提高程序的执行效率，因为它避免了函数调用的开销，直接将函数体的代码插入到调用点。】但实际上是内联的。</p><p>但是，请记住，inline 关键字是一种对编译器的请求，而不是绝对的要求，所以，如果这种使用能够使得效率增高且不会过分代码膨胀，才会进行内联处理。</p></blockquote><hr><h4 id="3-5默认参数"><a href="#3-5默认参数" class="headerlink" title="3.5默认参数"></a>3.5默认参数</h4><blockquote><p>  在 C++ 中，默认参数(defaut arguments) 与方法重载类似，在原型中，可以为函数或方法的参数指定默认值。</p><p>  注意，任何默认构造函数能做到的，使用方法重载都可以做到，然而这种默认构造方法确实是应当使用得心应手的机制。</p></blockquote><hr><h3 id="9-4不同的数据成员类型【部分内容不太明白】"><a href="#9-4不同的数据成员类型【部分内容不太明白】" class="headerlink" title="9.4不同的数据成员类型【部分内容不太明白】"></a>9.4不同的数据成员类型【部分内容不太明白】</h3><blockquote><p>  C++为数据成员提供了多种选择。除了在类中简单地声明<strong>数据成员</strong>外，还可创建<strong>静态数据成员(类的所有对象共享)<strong>、</strong>静态常量数据成员</strong>、<strong>引用数据成员</strong>、<strong>常量引用数据成员和其他成员</strong>。本节解释这些不同类型的数据成员。  </p></blockquote><hr><h4 id="4-1静态数据成员"><a href="#4-1静态数据成员" class="headerlink" title="4.1静态数据成员"></a>4.1静态数据成员</h4><blockquote><p>  使用机制基本和静态成员函数一样。</p><p>  有时让类的所有对象都包含某个变量的副本是没必要的。数据成员可能只对类有意义，而每个对象都拥有其副本是不合适的，<strong>使用 static 关键字</strong>。  </p><p>  下面是 Spreadsheet 类的定义，其中包含了新的静态数据成员 sCounter：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Spreadsheet</span><br>&#123;<br><span class="hljs-comment">// Omitted for brevity </span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">static</span> <span class="hljs-type">size_t</span> sCounter;<br>&#125;;<br></code></pre></td></tr></table></figure><p>  不仅要在<strong>类定义中列出 static 类成员，还需要在源文件中为其分配内存，通常是定义类方法的那个源文件</strong>。<strong>在此还可初始化静态成员，但注意与普通的变量和数据成员不同，默认情况下它们会初始化为 0</strong>。static 指针会初始化为 nullptr 下面是为 sCounter 分配空间并初始化为 0 的代码：  </p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">size_t</span> Spreadsheet::sCounter;<br></code></pre></td></tr></table></figure><p>  静态数据成员默认情况下初始化为 0, 但如果需要，可将它们显式地初始化为 0, 所下所示:</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">size_t</span> Spreadsheet::sCounter = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>  这行代码在函数或方法外部，与声明全局变量非常类似，只是使用作用域解析 Spreadsheet::指出这是Spreadsheet 类的一部分。【这也就是和上面说的一样，和静态方法类似的原因】</p><ol><li><p><strong>内联方法</strong></p><p>从 C++17 开始，就可以使用 inline 来声明静态数据成员，这样做的好处就是不用在源文件中为其分配空间，示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Spreadsheet</span><br>&#123;<br>    <span class="hljs-comment">// Omitted for brevity</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">size_t</span> sCounter = <span class="hljs-number">0</span>;<br>&#125;;<br><span class="hljs-comment">// 注意，有了 inline 关键字，那么就不要在源文件中再次定义</span><br></code></pre></td></tr></table></figure></li><li><p><strong>在类方法内访问静态数据成员</strong></p><p>在类方法内部，可以像使用普通数据成员一样使用静态数据成员。例如，为 Spreadsheet 类创建一个 mId 成员，并在 Spreadsheet 构造函数中用 sCounter 成员初始化它。下面是包含了 mId 成员的 Spreadsheet 类定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Spreadsheet</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// Omitted for brevity</span><br>    <span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">static</span> <span class="hljs-type">size_t</span> sCounter;<br>    <span class="hljs-type">size_t</span> mId;<br>&#125;;<br></code></pre></td></tr></table></figure><p>下面是 Spreadsheet 构造函数的实现，在此赋予初始 ID：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++">Spreadsheet::<span class="hljs-built_in">Spreadsheet</span>(<span class="hljs-type">size_t</span> width, <span class="hljs-type">size_t</span> height)<br>    : <span class="hljs-built_in">mId</span>(sCounter++), <span class="hljs-built_in">mWidth</span>(width), <span class="hljs-built_in">mHeight</span>(height)<br>&#123;<br>    mCells = <span class="hljs-keyword">new</span> SpreadsheetCell*[mWidth];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; mWidth; i++)<br>    &#123;<br>        mCells[i] = <span class="hljs-keyword">new</span> SpreadsheetCell[mHeight];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，构造函数可以访问 sCounter ,这就像是一个普通成员，在复制构造函数中，也要指定新的 ID，由于Spreadsheet 复制构造函数委托给非复制构造函数(会自动创建新的 ID), 因此这可以自动进行处理。  </p><p>在赋值运算符中不应该复制 ID。一旦给某个对象指定 ID, 就不应该再改变。建议把 mId 设置为 const 数据成员。</p></li><li><p><strong>在方法外访问静态数据成员</strong></p><p><strong>访问控制限定符适用于静态数据成员：sCounter 是私有的，因此不能在类方法之外访问。如果 sCounter 是公有的，就可在类方法外访问</strong>，具体方法是用::作用域解析运算符指出这个变量是 Spreadsheet 类的一部分：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> c = Spreadsheet::sCounter;<br></code></pre></td></tr></table></figure><p>然而，建议不要使用公有数据成员(9.42 节讨论的静态常量数据成员属于例外)。<strong>应该提供公有的 get&#x2F;set 方法来授予访问权限。如果要访问静态数据成员，应该实现静态的 get&#x2F;set 方法。</strong></p></li></ol></blockquote><hr><h4 id="4-2静态常量数据成员"><a href="#4-2静态常量数据成员" class="headerlink" title="4.2静态常量数据成员"></a>4.2静态常量数据成员</h4><blockquote><p>  <strong>类中的数据成员可声明为 const, 意味着在创建并初始化后，数据成员的值不能再改变。如果某个常量只适用于类，应该使用静态常量(static const 或 const static)数据成员，而不是全局常量。</strong>可在类定义中定义和初始化整型和枚举类型的静态常量数据成员，而不需要将其指定为内联变量。例如，你可能想指定电子表格的最大高度和宽度。如果用户想要创建的电子表格的高度或宽度大于最大值，就改用最大值。可将最大高度和宽度设置为 Spreadsheet <strong>类的 static const 成员</strong>：  </p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Spreadsheet</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>   <span class="hljs-comment">// Omitted for brevity</span><br>   <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">size__t</span> kMaxHeight = <span class="hljs-number">100</span>;<br>   <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> kMaxWidth = <span class="hljs-number">100</span>;<br>   <span class="hljs-comment">// kMaxHeight 和 kMaxWidth 是公有的，因此可在程序的任何位置访问它们，就像它们是全局变量一样，只是语法略有不同。必须用作用域解析运算符::指出该变量是 Spreadsheet 类的一部分</span><br>   <span class="hljs-comment">// 同时使用 static 和 const 并且在类定义时初始化值，可以简化在源文件中的相关操作(内联)</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>  可在构造函数中使用这些新常量，如下面的代码片段所示：  </p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br>Spreadsheet::<span class="hljs-built_in">Spreadsheet</span>(<span class="hljs-type">size_t</span> width, <span class="hljs-type">size_t</span> height)<br>: <span class="hljs-built_in">mId</span>(sCounter++)<br>, <span class="hljs-built_in">mWidth</span>(std::<span class="hljs-built_in">min</span>(width, kMaxWidth)) <span class="hljs-comment">// std::min() requires &lt;algorithm&gt;</span><br>, <span class="hljs-built_in">mHeight</span>(std::<span class="hljs-built_in">min</span>(height, kMaxHeight)) <span class="hljs-comment">// 用于返回两者中较小值</span><br>  <span class="hljs-comment">// 并抛出异常，但不会调用相应类的析构函数</span><br>&#123;<br>mCells = <span class="hljs-keyword">new</span> Spreadsheetcell*[mWidth];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; mWidth; i++) <br>  &#123;<br>mCells[i] = <span class="hljs-keyword">new</span> Spreadsheetcell[mHeight];<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>  注意：当 高度或宽度超出最大值时，除了自动使用最大高度或宽度外，也可以抛出异常。然而，在构造函数中抛出异常时，不会调用析构函数，因此需要谨慎处理。第 14 章将对此进行详细解释。</p><p>  注意：非静态数据成员也可声明为 const。例如，mId 数据成员就可声明为 const。因为不能给 const 数据成员赋值，所以需要在类内初始化器或 ctor-initializer 中初始化它们。这意味着根据使用情形，可能无法为具有非静态常量数据成员的类提供赋值运算符。如果属于这种情况，通常将赋值运算符标记为 deleted。</p></blockquote><hr><h4 id="4-3引用数据成员"><a href="#4-3引用数据成员" class="headerlink" title="4.3引用数据成员"></a>4.3引用数据成员</h4><blockquote><p>  Spreadsheets 和 SpreadsheetCells 很好，但这两个类本身并不能组成非常有用的应用程序。为了用代码控制整个电子表格程序，可将这两个类一起放入 SpreadsheetApplication 类。</p><p>  这个类的实现在此并不重要。现在考虑这个架构存在的问题：电子表格如何与应用程序通信？应用程序存储了一组电子表格, 因此可与电子表格通信。与此类似,每个电子表格都应存储应用程序对象的引用。<strong>Spreadsheet类必须知道 SpreadsheetApplication 类，SpreadsheetApplication 类也必须知道 Spreadsheet 类</strong>【这种知道某种程度上类似于双链表的逻辑】。这是一个<strong>循环引用问题</strong>，无法用普通的#include 解决。解决方案是在其中一个头文件中使用前置声明。下面是新的使用了前置声明的 Spreadsheet 类定义，用来通知编译器关于 SpreadsheetApplication 类的信息。第 11 章解释前置声明的另一个优势：可缩短编译和链接时间。</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpreadsheetApplication</span>; <span class="hljs-comment">// forward declaration</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Spreadsheet</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Spreadsheet</span>(<span class="hljs-type">size_t</span> width, <span class="hljs-type">size__t</span> height, SpreadsheetApplication&amp; theApp);<br><span class="hljs-comment">// Code omitted for brevity.</span><br><span class="hljs-keyword">private</span>:<br>   <span class="hljs-comment">// Code omitted for brevity.</span><br>   SpreadsheetApplication&amp; mTheApp;<br>&#125;;<br></code></pre></td></tr></table></figure><p>  这个定义将一个 SpreadsheetApplication 引用作为数据成员添加进来。在此情况下建议使用引用而不是指针，因为 Spreadsheet 总要引用一个 SpreadsheetApplication, 而指针则无法保证这一点。</p><p>  注意存储对应用程序的引用，仅是为了演示把引用作为数据成员的用法。不建议以这种方式把 Spreadsheet和 SpreadsheetApplication 类组合在一起，而应改用 MVC(模型-视图-控制器)范型(见第 4 章)。</p><p>  <strong>在构造函数中，每个 Spreadsheet 都得到了一个应用程序引用。</strong>如果不引用某些事物，引用将无法存在，因此在构造函数的 ctor-initializer 中必须给 mTheApp 指定一个值。</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++">Spreadsheet::<span class="hljs-built_in">Spreadsheet</span>(<span class="hljs-type">size_t</span> width, <span class="hljs-type">size_t</span> height, SpreadsheetApplication&amp; theApp)<br>: <span class="hljs-built_in">mid</span>(sCounter++)<br>, <span class="hljs-built_in">mWidth</span>(std::<span class="hljs-built_in">min</span>(width, kMaxWidth))<br>, <span class="hljs-built_in">mHeight</span>(std::<span class="hljs-built_in">min</span>(height, kMaxHeight))<br>, <span class="hljs-built_in">mTheApp</span>(theApp)<br>&#123;<br><span class="hljs-comment">// Code omitted for brevity.</span><br>&#125;<br></code></pre></td></tr></table></figure><p>  在复制构造函数中，必须初始化这个引用成员【指针不能保证这个对象的存在】。由于 Spreadsheet 复制构造函数委托给非复制构造函数(初始化引用成员)，因此这将自动处理。</p><p>  <strong>记住，在初始化一个引用后，不能改变它引用的对象，因此不可能在赋值运算符中对引用赋值。这意味着根据使用情形，可能无法为具有引用数据成员的类提供赋值运算符。如果属于这种情况，通常将赋值运算符标记为 deleted。</strong></p></blockquote><hr><h4 id="4-4常量引用数据成员"><a href="#4-4常量引用数据成员" class="headerlink" title="4.4常量引用数据成员"></a>4.4常量引用数据成员</h4><blockquote><p>  就像普通引用可引用常量对象一样，引用成员也可引用常量对象。例如，为让 Spreadsheet 只包含应用程序对象的常量引用，只需要在类定义中将 mTheApp 声明为常量引用：  </p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Spreadsheet</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Spreadsheet</span>(<span class="hljs-type">size_t</span> width, <span class="hljs-type">size_t</span> height,<br><span class="hljs-type">const</span> SpreadsheetApplication&amp; theApp);<br><span class="hljs-comment">// Code omitted for brevity.</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// Code omitted for brevity,</span><br><span class="hljs-type">const</span> SpreadsheetApplication&amp; mTheApp;<br>&#125;;<br></code></pre></td></tr></table></figure><p>  常量引用和非常量引用之间存在一个重要差别。常量引用 SpreadsheetApplication 数据成员只能用于调用 SpreadsheetApplication 对象上的常量方法。如果试图通过常量引用调用非常量方法，编译器会报错。</p><p>  还可创建静态引用成员或静态常量引用成员，但一般不需要这么做。</p></blockquote><hr><h3 id="9-5嵌套类"><a href="#9-5嵌套类" class="headerlink" title="9.5嵌套类"></a>9.5嵌套类</h3><blockquote><p>  类定义不仅可包含成员函数和数据成员，还可编写嵌套类和嵌套结构、声明 typedef 或者创建枚举类型。类中声明的一切内容都具有类作用域。如果声明的内容是公有的，那么可在类外使用 ClassName::作用域解析语法访问。</p><p>  可在类的定义中提供另一个类定义。例如，假定 SpreadsheetCell 类实际上是 Spreadsheet 类的一部分，因此不妨将 SpreadsheetCell 重命名为 Cell。可将二者定义为:</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Spreadsheet</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cell</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Cell</span>() = <span class="hljs-keyword">default</span>;<br><span class="hljs-built_in">Cell</span>(<span class="hljs-type">double</span> initialvalue);<br><span class="hljs-comment">// Omitted for brevity</span><br>&#125;;<br><span class="hljs-built_in">Spreadsheet</span>(<span class="hljs-type">size_t</span> width, <span class="hljs-type">size_t</span> height, <span class="hljs-type">const</span> SpreadsheetApplication&amp; theApp);<br><span class="hljs-comment">// Remainder of Spreadsheet declarations omitted for brevity</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>  现在 Cell 类定义位于 Spreadsheet 类内部，因此在 Spreadsheet 类外引用 Cell 必须用 Spreadsheet::作用域限定名称，即使在方法定义时也是如此。例如，Cell 的 double 构造函数应如下所示：  </p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">Spreadsheet::Cell::<span class="hljs-built_in">Cell</span>(<span class="hljs-type">double</span> initialvalue)<br>: <span class="hljs-built_in">mValue</span>(initialvalue)<br>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>  甚至在 Spreadsheet 类中方法的返回类型(不是参数)也必须使用这一语法:</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Spreadsheet::Cell&amp; <span class="hljs-title">Spreadsheet::getCellAt</span><span class="hljs-params">(<span class="hljs-type">size_t</span> x, <span class="hljs-type">size_t</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">verifyCoordinate</span>(x, y);<br><span class="hljs-keyword">return</span> mCells[x][y];<br>&#125;<br></code></pre></td></tr></table></figure><p>  如果在 Spreadsheet 类中直接完整定义嵌套的 Cell 类，将使 Spreadsheet 类的定义略显臃肿。为缓解这一点,只需要在 Spreadsheet 中为 Cell 添加前置声明，然后独立地定义 Cell 类，如下所示：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">class</span> <span class="hljs-title">Spreadsheet</span></span><br><span class="hljs-function"><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">public</span>:</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">class</span> Cell;</span></span><br><span class="hljs-params"><span class="hljs-function">Spreadsheet(<span class="hljs-type">size_t</span> width, <span class="hljs-type">size_t</span> height, <span class="hljs-type">const</span> SpreadsheetApplications theApp);</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-comment">// Remainder of Spreadsheet declarations omitted for brevity</span></span></span><br><span class="hljs-params"><span class="hljs-function">&#125;;</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">class</span> Spreadsheet::Cell</span></span><br><span class="hljs-params"><span class="hljs-function">&#123;</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">public</span>:</span></span><br><span class="hljs-params"><span class="hljs-function">Cell() = <span class="hljs-keyword">default</span>;</span></span><br><span class="hljs-params"><span class="hljs-function">Cell(<span class="hljs-type">double</span> initialvalue);</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-comment">// Omitted for brevity</span></span></span><br><span class="hljs-params"><span class="hljs-function">&#125;;</span></span><br><span class="hljs-params"><span class="hljs-function"></span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-comment">// 这样拆分定义有利于增强可读性</span></span></span><br></code></pre></td></tr></table></figure><p>  普通的访问控制也适用于嵌套类定义。如果声明了一个 private 或 protected 嵌套类，这个类只能在外围类(outer class, 即包含它的类)中使用。</p><p>  <strong>嵌套的类有权访问外围类中的所有 private 或 protected 成员；</strong></p><p>  <strong>而外围类却只能访问嵌套类中的 public 成员。</strong>  </p></blockquote><hr><h3 id="9-6类内的枚举类型"><a href="#9-6类内的枚举类型" class="headerlink" title="9.6类内的枚举类型"></a>9.6类内的枚举类型</h3><blockquote><p>  如果想在类内定义很多常量，应该使用枚举类型而不是一组 #define.例如，可在 SpreadsheetCell 类中支持单元格颜色，如下所示：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpreadsheetCell</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-comment">// Omitted for brevity</span><br>  <span class="hljs-keyword">enum class</span> <span class="hljs-title class_">Color</span> &#123; Red = <span class="hljs-number">1</span>, Green, Blue, Yellow&#125;;<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setColor</span><span class="hljs-params">(Color color)</span></span>;<br>  <span class="hljs-function">Color <span class="hljs-title">gerColor</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-comment">// Omitted for brevity</span><br>  Color mColor = Color::Red;<br>&#125;;<br></code></pre></td></tr></table></figure><p>  setColor() 和 getColor() 方法的实现简单明了：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SpreadsheetCell::setColor</span><span class="hljs-params">(Color color)</span></span><br><span class="hljs-function"></span>&#123;<br>   mColor = color;<br>&#125;<br><br><span class="hljs-function">SpreadsheetCell::Color <span class="hljs-title">SpreadsheetCell::getColor</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">return</span> mColor;<br>&#125;<br></code></pre></td></tr></table></figure><p>  可通过下面的方法使用这些新方法：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">SpreadsheetCell <span class="hljs-title">myCell</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>myCell.<span class="hljs-built_in">setColor</span>(SpreadsheetCelll::Color::Blue);<br><span class="hljs-keyword">auto</span> color = myColor.<span class="hljs-built_in">getColor</span>();<br></code></pre></td></tr></table></figure></blockquote><hr><h3 id="9-7运算符重载"><a href="#9-7运算符重载" class="headerlink" title="9.7运算符重载"></a>9.7运算符重载</h3><blockquote><p>  需要在对象上执行操作，例如，相加、比较、将对象输入文件或从文件中读取。对电子表格而言，只有能执行算术运算(例如将整行单元格相加)才算真正有用。</p></blockquote><hr><h4 id="7-1示例：为-SpreadsheetCell-实现加法"><a href="#7-1示例：为-SpreadsheetCell-实现加法" class="headerlink" title="7.1示例：为 SpreadsheetCell 实现加法"></a>7.1示例：为 SpreadsheetCell 实现加法</h4><ol><li><p><strong>使用 add() 方法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpreadsheeetCell</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// Omitted for brevity</span><br>    <span class="hljs-function">SpreadsheetCell <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">const</span> Spreadsheet&amp; cell)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">// Omitted for brevity</span><br>&#125;;<br><br><span class="hljs-function">SpreadsheetCell <span class="hljs-title">SpreadsheetCell::add</span><span class="hljs-params">(<span class="hljs-type">const</span> SpreadsheetCell&amp; cell)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">SpreadsheetCell</span>(<span class="hljs-built_in">getValue</span>() + cell.<span class="hljs-built_in">getValue</span>());<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">SpreadsheetCell <span class="hljs-title">myCell</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span>, <span class="hljs-title">anotherCell</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>SpreadsheetCell aThirdCell = myCell.<span class="hljs-built_in">add</span>(anotherCell);<br></code></pre></td></tr></table></figure></li><li><p><strong>加法运算符的重载方法</strong><br>用加号相加两个单元格会比较方便，就像相加两个 int 和 double 值那样，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">Spreadsheet <span class="hljs-title">myCell</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span>, <span class="hljs-title">anotherCell</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>Spreadsheet aThirdCell = myCell + anotherCell;<br></code></pre></td></tr></table></figure><p>C++ 允许编写自己的加号版本，以正确地处理类，称为 加运算符，为此可以编写一个名为 operator+ 的方法，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpreadsheetCell</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// Omitted for brevity</span><br>    <span class="hljs-function">SpreadsheetCell <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">const</span> Spreadsheet&amp; cell)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-comment">// Omitted for brevity</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>注意：</p><p>​在 operator+ 和加号之间可以使用空格，例如，可用 operator + 代替 operator+。这一点对所有运算符都成立。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 该方法与 add() 方法的实现一致</span><br>SpreadsheetCell SpreadsheetCell::<span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> SpreadsheetCell&amp; cell) <span class="hljs-type">const</span><br>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">SpreadsheetCell</span>(<span class="hljs-built_in">getValue</span>() + cell.<span class="hljs-built_in">getValue</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>现在可以使用两个加号将两个单元格相加，就像之前那样。</p><p>这种语法需要花点工夫去适应。不要过于担心这个奇怪的方法名称 opemto+ 这只是一个名称，就像 fbo或 add 一样。理解此处实际发生的事情有助于理解其余的语法。当 C++编译器分析一个程序，遇到运算符(例如， +、-、&#x3D;或 &lt;&lt;)时，就会试着查找名为 operate+、operator-、operator&#x3D; 或 operator&lt;&lt; , 且具有适当参数的函数或方法。  </p><p>运算符重载是函数重载的一种形式，函数重载对函数的返回类型并没有要求。</p><p><strong>隐式转换：</strong></p><p>令人震惊的是，一旦编写像前面那样的 operator+，就不仅仅可以实现两个单元格的相加，还可以将单元格和 string_view、double 或 int 值相加。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">SpreadsheetCell <span class="hljs-title">myCell</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span>, aThirdCell</span>;<br>string str = <span class="hljs-string">&quot;hello&quot;</span>;<br>aThirdCell = myCell + <span class="hljs-built_in">string_view</span>(str);<br>aThirdCell = myCell + <span class="hljs-number">5.6</span>;<br>aThirdCell = myCell + <span class="hljs-number">4</span>;<br></code></pre></td></tr></table></figure><p>上面的代码之所以可运行，是因为编译器会试着查找合适的 operator+, 而不是只查找指定类型的那个 operator+ 为找到 operator+，编译器还试图查找合适的类型转换，构造函数会对有问题的类型进行适当的转换。在上例中，当编译器看到 SpreadsheetCell 试图与 double 值相加时,发现了用 double 值作为参数的 SpreadsheetCell构造函数，就会构建一个临时的 SpreadsheetCell 对象，传递给 operator+。与此类似，当编译器看到试图将SpreadsheetCell 与 string_view 相加的行时，会调用把 string_view 作为参数的 SpreadsheetCell 构造函数，创建一个临时 SpreadsheetCell 对象，传递给 operator+.</p><p>隐式转换会带来方便，但是同样可能带来隐患，例如，使得 operator+ 失去原本意义。可使用 explicit 关键字标记构造函数，禁止将 string_view 隐式转换为 SpreadsheetCell：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Spreadsheet</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SpreadsheetCell</span>() = <span class="hljs-keyword">default</span>;<br>    <span class="hljs-built_in">SpreadsheetCell</span>(<span class="hljs-type">double</span> initialValue);<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">SpreadsheetCell</span><span class="hljs-params">(std::string_view initialValue)</span></span>;<br>    <span class="hljs-comment">// Remainder omitted for brevity</span><br>&#125;;<br><br><span class="hljs-comment">/* explicit 关键字只在类定义内使用，只适用于只有一个参数的构造函数，例如单参构造函数或为参数提供默认值的多参构造函数。*/</span><br></code></pre></td></tr></table></figure><p>由于必须创建临时对象，隐式使用构造函数的效率不高。为避免与 double 值相加时隐式地使用构造函数，可编写第二个 operator+, 如下所示：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">SpreadsheetCell SpreadsheetCell::<span class="hljs-keyword">operator</span>+(<span class="hljs-type">double</span> rhs) <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">SpreadsheetCell</span>(<span class="hljs-built_in">getValue</span>() + rhs);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>全局 operator+</strong></p><p>隐式转换允许使用 operator^方法将 SpreadsheetCell 对象与 int 和 double 值相加。然而，这个运算符不具有互换性，如下所示：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">aThirdCell = myCell + <span class="hljs-number">4</span>; <span class="hljs-comment">// Works fine</span><br>aThirdCell = myCell + <span class="hljs-number">5.6</span>; <span class="hljs-comment">// Works fine.</span><br>aThirdCell = <span class="hljs-number">4</span> + myCell; <span class="hljs-comment">// FAILS TO COMPILE!</span><br>aThirdCell = <span class="hljs-number">5.6</span> + myCell; <span class="hljs-comment">// FAILS TO COMPILE!</span><br><br><span class="hljs-comment">/*当 Spreadsheetcell 对象在运算符的左边时，隐式转换正常运行，但在右边时无法运行。加法是可互换的，因此这里存在错误。问题在于必须在 SpreadsheetCell 对象上调用 operator+方法，对象必须在 operato什的左边。这是 C++语言定义的方式，因此使用 operator+ 方法无法让上面的代码运行。*/</span><br></code></pre></td></tr></table></figure><p>然而，如果用不局限于某个特定对象的全局 operator+ 函数替换类内的 opemto什方法，上面的代码就可以运行，函数如下所示：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">SpreadsheetCell <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> SpreadsheetCell&amp; Ihs,<br>  <span class="hljs-type">const</span> SpreadsheetCell&amp; rhs)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">SpreadsheetCell</span>(Ihs.<span class="hljs-built_in">getValue</span>() + rhs.<span class="hljs-built_in">getValue</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>需要在头文件中声明运算符:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpreadsheetCell</span><br>&#123;<br><span class="hljs-comment">// Omitted for brevity</span><br>&#125;;<br><br>SpreadsheetCell <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> SpreadsheetCell&amp; Ihs,<span class="hljs-type">const</span> SpreadsheetCell&amp; rhs);<br></code></pre></td></tr></table></figure><p>这样，下面的 4 个加法运算都可按预期运行：  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">aThirdCell = myCell + <span class="hljs-number">4</span>; <span class="hljs-comment">// Works fine.</span><br>aThirdCell = myCell + <span class="hljs-number">5.6</span>; <span class="hljs-comment">// Works fine.</span><br>aThirdCell = <span class="hljs-number">4</span> + myCell; <span class="hljs-comment">// Works fine.</span><br>aThirdCell = <span class="hljs-number">5.6</span> + myCell; <span class="hljs-comment">// Works fine.</span><br></code></pre></td></tr></table></figure><p>那么，如果编写以下代码，会发生什么情况呢？  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">aThirdCell = <span class="hljs-number">4.5</span> + <span class="hljs-number">5.5</span>;<br></code></pre></td></tr></table></figure><p>这段代码可编译并运行，但并没有调用前面编写的 opeator+ 。这段代码将普通的 double 型数值 4.5 和 5.5相加，得到了下面所示的中间语句： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">aThirdCell = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>为了让赋值操作继续,运算符右边应该是 SpreadsheetCell 对象。编译器找到并非显式由用户定义的用 double 值作为参数的构造函数，然后用这个构造函数隐式地将 double 值转换为一个临时 SpreadsheetCell 对象，最后调用赋值运算符。</p><p>注意：</p><p>在 C++中，不能更改运算符的优先级。例如，*和&#x2F;始终在+和- 之前计算。对于用户定义的运算符，唯一能做的只是在确定运算的优先级后指定实现。C++也不允许发明新的运算符号，不允许更改运算符的实参个数。</p></li></ol><hr><h4 id="7-2重载算术运算符"><a href="#7-2重载算术运算符" class="headerlink" title="7.2重载算术运算符"></a>7.2重载算术运算符</h4><p>+、-、*、&#x2F; 略</p><p>+&#x3D;、-&#x3D;、*&#x3D;、&#x2F;&#x3D;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Spreadsheetcell</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// Omitted for brevity</span><br>SpreadsheetCell&amp; <span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> Spreadsheetcell&amp; rhs);<br>SpreadsheetCell&amp; <span class="hljs-keyword">operator</span>-=(<span class="hljs-type">const</span> Spreadsheetcell&amp; rhs);<br>SpreadsheetCell&amp; <span class="hljs-keyword">operator</span>*=(<span class="hljs-type">const</span> Spreadsheetcell&amp; rhs);<br>SpreadsheetCell&amp; <span class="hljs-keyword">operator</span>/=(<span class="hljs-type">const</span> Spreadsheetcell&amp; rhs);<br><span class="hljs-comment">// Omitted for brevity</span><br>&#125;;<br><br>Spreadsheetcell&amp; Spreadsheetcell::<span class="hljs-keyword">operator</span>+=(<span class="hljs-type">const</span> Spreadsheetcell&amp; rhs)<br>&#123;<br><span class="hljs-built_in">set</span>(<span class="hljs-built_in">getValue</span>() + rhs.<span class="hljs-built_in">getValue</span>());<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果既有某个运算符的普通版本，又有简写版本，建议你基于简写版本实现普通版本，以避免代码重复。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">Spreadsheetcell <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> SpreadsheetCell&amp; Ihs, <span class="hljs-type">const</span> Spreadsheetcell&amp; rhs)<br>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">result</span><span class="hljs-params">(Ihs)</span></span>; <span class="hljs-comment">// Local copy</span><br>    result += rhs; <span class="hljs-comment">// Forward to op=() version</span><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="7-3重载比较运算符"><a href="#7-3重载比较运算符" class="headerlink" title="7.3重载比较运算符"></a>7.3重载比较运算符</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">bool</span> <span class="hljs-built_in">operator</span>&lt;op&gt;(<span class="hljs-type">const</span> Spreadsheetcell&amp; Ihs, <span class="hljs-type">const</span> Spreadsheetcell&amp; rhs);<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><p><strong>前面重载的运算符使用 getValue()返回一个 double 值。大多数时候，最好不要对浮点数执行相等或不相等测试。应该使用 e 测试(epsilon test), 但这一内容超出了本书的讨论范围.</strong></p><p>当类中的数据成员较多时，比较每个数据成员可能比较痛苦。然而，当实现了&#x3D;&#x3D; 和 &lt;之后，可以根据这两个运算符编写其他比较运算符。例如，下面的 operator&gt;&#x3D;定义使用了 operator&lt;:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>&gt;=(<span class="hljs-type">const</span> Spreadsheetcell&amp; Ihs, <span class="hljs-type">const</span> Spreadsheetcell&amp; rhs)<br>&#123;<br><span class="hljs-keyword">return</span> !(Ihs &lt; rhs);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="7-4创建具有运算符重载的类型"><a href="#7-4创建具有运算符重载的类型" class="headerlink" title="7.4创建具有运算符重载的类型"></a>7.4创建具有运算符重载的类型</h4><p>这在之后再说，几乎所有的运算符均可以重载。这在 STL(标准库中) 极为有用。</p><hr><h3 id="9-8创建稳定的接口"><a href="#9-8创建稳定的接口" class="headerlink" title="9.8创建稳定的接口"></a>9.8创建稳定的接口</h3><blockquote><p>  理解了在 C++中编写类的所有语法后，回顾第 5 章和第 6 章的设计原则会对此有所帮助。在 C++中，类是主要的抽象单元，应将抽象原则应用到类，尽可能分离接口和实现。确切地讲，应该将所有数据成员设置为private, 并提供相应的 getter 和 setter 方法。这就是 SpreadsheetCell 类的实现方式：将 mValue 设置为 private, set() ,getValue(), getString() 。用于设置或获取这些值。</p><p>  <strong>使用接口类和实现类 ：</strong>  </p><p>  即使提前进行估算并采用最佳设计原则，C++语言本质上对抽象原则也不友好。<strong>其语法要求将 public 接口和 private(或 protected)数据成员及方法放在一个类定义中，从而将类的某些内部实现细节向客户公开</strong>。<strong>这种做法的缺点在于，如果不得不在类中加入新的非公有方法或数据成员，所有的客户代码都必须重新编译，对于较大项目而言这是负担</strong>。  </p><p>  <strong>有个好消息：可创建清晰的接口，并隐藏所有实现细节，从而得到稳定的接口。</strong></p><p>  <strong>还有个坏消息：这样做有点繁杂。</strong></p><p>  <strong>基本原则是为想编写的每个类都定义两个类：接口类和实现类。</strong>  </p><ul><li><p><strong>实现类与已编写的类相同(假定没有采用这种方法)，接口类给出了与实现类一样的 public 方法，但只有一个数据成员：指向实现类对象的一个指针</strong>。</p></li><li><p><strong>这称为 pimpl idiom(private implementation idiom, 私有实现习语)或 bridge 模式，接口类方法的实现只是调用实现类对象的等价方法</strong>。</p></li><li><p><strong>这样做的结果是无论实现如何改变，都不会影响 public 接口类，从而降低了重新编译的必要性。当实现改变(只有实现改变)时，使用接口类的客户不需要重新编译</strong>。</p></li><li><p><strong>注意只有在单个数据成员是实现类的指针时，这个习语才有效。如果它是 按值传递 的数据成员，在实现类的定义改变时，客户代码必须重新编译。</strong></p></li></ul><p>  为将这种方法应用到 Spreadsheet 类，需要定义如下 public 接口类 Spreadsheet：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;SpreadsheetCell.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-comment">// forward declarations</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpreadsheetApplication</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Spreadsheet</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Spreadsheet</span>(<span class="hljs-type">const</span> SpreadsheetApplication&amp; theApp,<br>   <span class="hljs-type">size_t</span> width = kMaxWidth, <br>                <span class="hljs-type">size_t</span> height = kMaxHeight);<br><span class="hljs-built_in">Spreadsheet</span>(<span class="hljs-type">const</span> Spreadsheet&amp; src);<br>~<span class="hljs-built_in">Spreadsheet</span>();<br><br>Spreadsheet&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Spreadsheet&amp; rhs);<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setCellAt</span><span class="hljs-params">(<span class="hljs-type">size_t</span> x, <span class="hljs-type">size_t</span> y, <span class="hljs-type">const</span> SpreadsheetCell&amp; cell)</span></span>;<br><span class="hljs-function">SpreadsheetCell&amp; <span class="hljs-title">getCellAt</span><span class="hljs-params">(<span class="hljs-type">size_t</span> x, <span class="hljs-type">size_t</span> y)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> kMaxHeight = <span class="hljs-number">100</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">size_t</span> kMaxWidth = <span class="hljs-number">100</span>;<br><br>    <span class="hljs-comment">// 友元函数</span><br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Spreadsheet&amp; first, Spreadsheet&amp; second)</span> <span class="hljs-keyword">noexcept</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 实现类，是 private 的嵌套类，用于限定访问权限</span><br>    <span class="hljs-comment">// 这里可能会有点疑惑，就是前面对嵌套类到底是干嘛的的疑问，明明我可以在外面进行直接定义，我干嘛在这里的内部定义？</span><br>    <span class="hljs-comment">// 可以说，嵌套类的左右就是去限定一种访问方式的，在外部是无法不通过 外层类而获取内层类的内容的。</span><br>    <span class="hljs-comment">// 同时，如果是作为 private 类进行存在，那么就无法通过外部类对其内部进行访问，实现了一种保护，以及底层的不可见</span><br>    <span class="hljs-comment">// 所以，嵌套类作为一种声明，不是一个数据成员，而下方指向这个数据成员的的智能指针才是真正的数据成员</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Impl</span>;<br><br>    <span class="hljs-comment">// 实现类的智能指针</span><br>std::unique_ptr&lt;Impl&gt; mImpl;<br>&#125;;<br><br><span class="hljs-comment">/*实现类 Impl 是一个 private 嵌套类，因为只有 Spreadsheet 需要了解这个实现类。Spreadsheet 现在只包含一</span><br><span class="hljs-comment">个数据成员：指向 Impl 实例的指针。public 方法与旧式的 Spreadsheet 相同*/</span><br><br><span class="hljs-comment">/*-------------------------------------------------------------------------------------------------------*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Spreadsheet.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;SpreadsheetImpl.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><br>Spreadsheet::<span class="hljs-built_in">Spreadsheet</span>(<span class="hljs-type">const</span> SpreadsheetApplication &amp;theApp, <span class="hljs-type">size_t</span> width, <span class="hljs-type">size_t</span> height)<br>&#123;<br>mImpl = std::<span class="hljs-built_in">make_unique</span>&lt;Impl&gt;(theApp, width, height);<br>&#125;<br><br>Spreadsheet::<span class="hljs-built_in">Spreadsheet</span>(<span class="hljs-type">const</span> Spreadsheet&amp; src)<br>&#123;<br>mImpl = std::<span class="hljs-built_in">make_unique</span>&lt;Impl&gt;(*src.mImpl);<br>&#125;<br><br>Spreadsheet::~<span class="hljs-built_in">Spreadsheet</span>() = <span class="hljs-keyword">default</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Spreadsheet::setCellAt</span><span class="hljs-params">(<span class="hljs-type">size_t</span> x, <span class="hljs-type">size_t</span> y, <span class="hljs-type">const</span> SpreadsheetCell&amp; cell)</span></span><br><span class="hljs-function"></span>&#123;<br>mImpl-&gt;<span class="hljs-built_in">setCellAt</span>(x, y, cell);<br>&#125;<br><br><span class="hljs-function">SpreadsheetCell&amp; <span class="hljs-title">Spreadsheet::getCellAt</span><span class="hljs-params">(<span class="hljs-type">size_t</span> x, <span class="hljs-type">size_t</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> mImpl-&gt;<span class="hljs-built_in">getCellAt</span>(x, y);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">Spreadsheet::getId</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> mImpl-&gt;<span class="hljs-built_in">getId</span>();<br>&#125;<br><br>Spreadsheet&amp; Spreadsheet::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Spreadsheet&amp; rhs)<br>&#123;<br>*mImpl = *rhs.mImpl;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Spreadsheet&amp; first, Spreadsheet&amp; second)</span> <span class="hljs-keyword">noexcept</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">using</span> std::swap;<br><br><span class="hljs-built_in">swap</span>(first.mImpl, second.mImpl);<br>&#125;<br><br><span class="hljs-comment">/*-------------------------------------------------------------------------------------------------------*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstddef&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Spreadsheet.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;SpreadsheetCell.h&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Spreadsheet</span>::Impl<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Impl</span>(<span class="hljs-type">const</span> SpreadsheetApplication&amp; theApp,<br><span class="hljs-type">size_t</span> width, <br>         <span class="hljs-type">size_t</span> height);<br><span class="hljs-built_in">Impl</span>(<span class="hljs-type">const</span> Impl&amp; src);<br>~<span class="hljs-built_in">Impl</span>();<br>Impl&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Impl&amp; rhs);<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setCellAt</span><span class="hljs-params">(<span class="hljs-type">size_t</span> x, <span class="hljs-type">size_t</span> y, <span class="hljs-type">const</span> SpreadsheetCell&amp; cell)</span></span>;<br><span class="hljs-function">SpreadsheetCell&amp; <span class="hljs-title">getCellAt</span><span class="hljs-params">(<span class="hljs-type">size_t</span> x, <span class="hljs-type">size_t</span> y)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">verifyCoordinate</span><span class="hljs-params">(<span class="hljs-type">size_t</span> x, <span class="hljs-type">size_t</span> y)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Impl&amp; other)</span> <span class="hljs-keyword">noexcept</span></span>;<br><br><span class="hljs-type">size_t</span> mId = <span class="hljs-number">0</span>;<br><span class="hljs-type">size_t</span> mWidth = <span class="hljs-number">0</span>;<br><span class="hljs-type">size_t</span> mHeight = <span class="hljs-number">0</span>;<br>SpreadsheetCell** mCells = <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-type">const</span> SpreadsheetApplication&amp; mTheApp;<br><br><span class="hljs-type">static</span> <span class="hljs-type">size_t</span> sCounter;<br>&#125;;<br><br><span class="hljs-comment">/*-------------------------------------------------------------------------------------------------------*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;SpreadsheetImpl.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Spreadsheet.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-type">size_t</span> Spreadsheet::Impl::sCounter;<br><br>Spreadsheet::Impl::<span class="hljs-built_in">Impl</span>(<span class="hljs-type">const</span> SpreadsheetApplication&amp; theApp,<br>  <span class="hljs-type">size_t</span> width, <span class="hljs-type">size_t</span> height)<br>: <span class="hljs-built_in">mId</span>(sCounter++)<br>, <span class="hljs-built_in">mWidth</span>(std::<span class="hljs-built_in">min</span>(width, Spreadsheet::kMaxWidth))<br>, <span class="hljs-built_in">mHeight</span>(std::<span class="hljs-built_in">min</span>(height, Spreadsheet::kMaxHeight))<br>, <span class="hljs-built_in">mTheApp</span>(theApp)<br>&#123;<br>mCells = <span class="hljs-keyword">new</span> SpreadsheetCell*[mWidth];<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; mWidth; i++) <br>    &#123;<br>mCells[i] = <span class="hljs-keyword">new</span> SpreadsheetCell[mHeight];<br>&#125;<br>&#125;<br><br>Spreadsheet::Impl::~<span class="hljs-built_in">Impl</span>()<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; mWidth; i++) &#123;<br><span class="hljs-keyword">delete</span>[] mCells[i];<br>&#125;<br><span class="hljs-keyword">delete</span>[] mCells;<br>mCells = <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br>Spreadsheet::Impl::<span class="hljs-built_in">Impl</span>(<span class="hljs-type">const</span> Impl&amp; src)<br>: <span class="hljs-built_in">Impl</span>(src.mTheApp, src.mWidth, src.mHeight)<br>&#123;<br><span class="hljs-comment">// The ctor-initializer of this constructor delegates first to the</span><br><span class="hljs-comment">// non-copy constructor to allocate the proper amount of memory.</span><br><br><span class="hljs-comment">// The next step is to copy the data.</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; mWidth; i++) <br>    &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> j = <span class="hljs-number">0</span>; j &lt; mHeight; j++) <br>        &#123;<br>mCells[i][j] = src.mCells[i][j];<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-type">void</span> Spreadsheet::Impl::<span class="hljs-built_in">verifyCoordinate</span>(<span class="hljs-type">size_t</span> x, <span class="hljs-type">size_t</span> y) <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-keyword">if</span> (x &gt;= mWidth || y &gt;= mHeight) <br>    &#123;<br><span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">out_of_range</span>(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-type">void</span> Spreadsheet::Impl::<span class="hljs-built_in">setCellAt</span>(<span class="hljs-type">size_t</span> x, <span class="hljs-type">size_t</span> y, <span class="hljs-type">const</span> SpreadsheetCell&amp; cell)<br>&#123;<br><span class="hljs-built_in">verifyCoordinate</span>(x, y);<br>mCells[x][y] = cell;<br>&#125;<br><br>SpreadsheetCell&amp; Spreadsheet::Impl::<span class="hljs-built_in">getCellAt</span>(<span class="hljs-type">size_t</span> x, <span class="hljs-type">size_t</span> y)<br>&#123;<br><span class="hljs-built_in">verifyCoordinate</span>(x, y);<br><span class="hljs-keyword">return</span> mCells[x][y];<br>&#125;<br><br><span class="hljs-type">void</span> Spreadsheet::Impl::<span class="hljs-built_in">swap</span>(Impl&amp; other) <span class="hljs-keyword">noexcept</span><br>&#123;<br><span class="hljs-keyword">using</span> std::swap;<br><br><span class="hljs-built_in">swap</span>(mWidth, other.mWidth);<br><span class="hljs-built_in">swap</span>(mHeight, other.mHeight);<br><span class="hljs-built_in">swap</span>(mCells, other.mCells);<br>&#125;<br><br>Spreadsheet::Impl&amp; Spreadsheet::Impl::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> Impl&amp; rhs)<br>&#123;<br><span class="hljs-comment">// check for self-assignment</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;rhs) &#123;<br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">// Copy-and-swap idiom</span><br><span class="hljs-function">Impl <span class="hljs-title">temp</span><span class="hljs-params">(rhs)</span></span>; <span class="hljs-comment">// Do all the work in a temporary instance</span><br><span class="hljs-built_in">swap</span>(temp); <span class="hljs-comment">// Commit the work with only non-throwing operations</span><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-type">size_t</span> Spreadsheet::Impl::<span class="hljs-built_in">getId</span>() <span class="hljs-type">const</span><br>&#123;<br><span class="hljs-keyword">return</span> mId;<br>&#125;<br></code></pre></td></tr></table></figure><p>  <strong>嵌套的 Spreadsheet::Impl 类的接口与原来的 Spreadsheet 类的接口完全相同。</strong>但由于 Impl 是 Spreadsheet 的private 嵌套类，因此不能有以下全局友元函数 swap(), 该函数交换两个 Spreadsheet::Impl 对象：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Spreadsheet::Impl&amp; first, Spreadsheet::Impl&amp; second)</span> <span class="hljs-keyword">noexcept</span></span>;<br></code></pre></td></tr></table></figure><p>  相反，为 Spreadsheet::Impl 类定义 private swapo方法，如下所示:</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(Impl&amp; other)</span> <span class="hljs-keyword">noexcept</span></span>;<br></code></pre></td></tr></table></figure><p>  实现方式十分简单，但需要记住，这是一个嵌套类，因此需要指定 Spreadsheet::Impl::swap(), 而非仅仅指定 Impl::swap()。其他成员同样如此。要了解细节，可查看前面介绍嵌套类的部分，下面是 swapo方法:</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">void</span> Spreadsheet::Impl::<span class="hljs-built_in">swap</span>(Impl&amp; other) <span class="hljs-keyword">noexcept</span><br>&#123;<br><span class="hljs-keyword">using</span> std::swap;<br><span class="hljs-built_in">swap</span>(mWidth, other.mWidth);<br><span class="hljs-built_in">swap</span>(mHeight, other.mHeight);<br><span class="hljs-built_in">swap</span>(mCells, other.mCells);<br>&#125;<br></code></pre></td></tr></table></figure><p>  注意，Spreadsheet 类有一个指向实现类的 unique_ptr, Spreadsheet 类需要一个用户声明的析构函数。我们不需要对这个析构函数进行任何处理，可在文件中设置&#x3D; defalut 如下所示：</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">Spreadsheet::-<span class="hljs-built_in">Spreadsheet</span>() = <span class="hljs-keyword">default</span>;<br></code></pre></td></tr></table></figure><p>  这说明不仅可在类定义中，也可在实现文件中给特殊成员函数设置&#x3D;defhult。</p><p>  Spreadsheet 方法(例如setCell()和 getCellAt())的实现只是将请求传递给底层的 Impl 对象:</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Spreadsheet::setCellAt</span><span class="hljs-params">(<span class="hljs-type">size_t</span> x, <span class="hljs-type">size_t</span> y, <span class="hljs-type">const</span> SpreadsheetCell&amp; cell)</span></span><br><span class="hljs-function"></span>&#123;<br>mImpl-&gt;<span class="hljs-built_in">setCellAt</span>(x, y, cell);<br>&#125;<br><span class="hljs-function">SpreadsheetCell&amp; <span class="hljs-title">Spreadsheet::getCellAt</span><span class="hljs-params">(<span class="hljs-type">size_t</span> x, <span class="hljs-type">size_t</span> y)</span></span><br><span class="hljs-function"><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">return</span> mImpl-&gt;getCellAt(x, y);</span></span><br><span class="hljs-params"><span class="hljs-function">&#125;</span></span><br></code></pre></td></tr></table></figure><p>  Spreadsheet 的构造函数必须创建一个新的 Impl 实例来完成这个任务  :</p>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++">Spreadsheet::<span class="hljs-built_in">Spreadsheet</span>(<span class="hljs-type">const</span> SpreadsheetApplication&amp; theApp,<br>   <span class="hljs-type">size_t</span> width, <span class="hljs-type">size_t</span> height)<br>&#123;<br>    <span class="hljs-comment">// 利用智能指针分配空间</span><br>mImpl = std::<span class="hljs-built_in">make_unique</span>&lt;Impl&gt;(theApp, width, height);<br>&#125;<br><br>Spreadsheet::<span class="hljs-built_in">Spreadsheet</span>(<span class="hljs-type">const</span> Spreadsheet&amp; src)<br>&#123;<br>    mImpl = std::<span class="hljs-built_in">make_unique</span>&lt;Impl&gt;(*src.mImpl);<br>&#125;<br></code></pre></td></tr></table></figure><p>  解释一下上面的代码：</p><ol><li><code>const Spreadsheets src</code> 是函数参数,表示传入一个 <code>const</code> 引用类型的 <code>Spreadsheet</code> 对象作为数据源。</li><li><code>mImpl</code> 是当前对象的一个数据成员,类型为 <code>std::unique_ptr&lt;Impl&gt;</code>。<code>std::unique_ptr</code> 是 C++11 引入的智能指针,用于自动管理动态分配的内存。</li><li><code>std::make_unique&lt;Impl&gt;(*src.mImpl)</code> 利用 <code>std:;make_unique</code> 在堆上创建一个新的 <code>Impl</code> 实例,并使用 <code>src.mImpl</code> 所指向的对象的值来初始化这个新实例。</li><li>将新创建的 <code>Impl</code> 实例的所有权转移给 <code>mImpl</code>。</li></ol><p>  剩下的代码就不讲了，没什么意思。</p><p>  <strong>总结一下：在 Spreadsheet 中使用嵌套类，将 Impl private 类只能由 Spreadsheet 类获取，然后，再为 Spreadsheet 声明构造函数和析构函数，新的 Spreadsheet 的构造函数的目的是调用 Impl 的构造函数，然后，我们思考该如何对 Impl 进行构造和析构，其实本质上和 Spreadsheet 类之前的一模一样，我们可以将 Impl 类看作是代理，将 Spreadsheet 类的需求通过这样一根智能指针进行传递，从而在 客户和类之间形成一个过渡层。过渡层的传递方式就是，先用 Spreadsheet 中存一个 Impl 的指针用于初始化和访问权限获取，在之后利用的 Impl 本质上就是 Spreadsheet 的实体，而 Spreadsheet 被作为了一个接口类</strong></p><p>  <strong>真正将接口和实现分离的技术功能强大。尽管开始时有点笨拙，但是一旦适应这种技术，就会觉得这么做很自然。然而，在多数工作环境中这并不是常规做法，因此这么做会遇到来自同事的一些阻力。支持这种方法最有力的论据不是将接口分离的美感，而是类的实现改变后大幅缩短构建时间。一个类不使用 pimpl idiom 时，对实现类的更改将触发一个长时间的构建过程。例如，给类定义增加数据成员时，将触发其他所有源文件(包括类定义)的重新构建；而使用 pimpl idiom, 可以修改实现类的定义，只要 public 接口类保持不变，就不会触发长时间的构建过程。</strong></p><p>  <strong>为将实现与接口分离，另一种方法是使用抽象接口以及实现该接口的实现类；抽象接口是只有纯虚方法(pure virtual method)的接口。第 10 章将讨论抽象接口。</strong></p></blockquote><hr><h3 id="9-9本章小结"><a href="#9-9本章小结" class="headerlink" title="9.9本章小结"></a>9.9本章小结</h3><blockquote><p>  没啥说的，就是一句话，上面的<strong>零规则</strong>在那里放着，这些只要能看懂，大致会用就可以了。</p><p>  其中，还有一些不是特别理解的，主要是常量引用相关的，但是之后会补上去。以及对 一些为安全而进行的函数书写方式，理解不深，比如 swap() 等。之后注意再复查一遍，仔细想象已经就可以理解了。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 复习教程第三章（C++编码风格）</title>
    <link href="/2024/03/14/C++%20%E5%A4%8D%E4%B9%A0%E6%95%99%E7%A8%8B%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%88C++%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC%EF%BC%89/"/>
    <url>/2024/03/14/C++%20%E5%A4%8D%E4%B9%A0%E6%95%99%E7%A8%8B%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%88C++%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="第3章-——-编码风格"><a href="#第3章-——-编码风格" class="headerlink" title="第3章 —— 编码风格"></a>第3章 —— 编码风格</h2><hr><blockquote><p>编写具有风格的代码才算真正掌握了编码；</p><p>简单地改变代码风格可以极大改变代码的外观；</p><p>不同种程序员的 C++ 代码风格有着本质的区别；</p></blockquote><h3 id="3-1良好外观的重要性"><a href="#3-1良好外观的重要性" class="headerlink" title="3.1良好外观的重要性"></a>3.1良好外观的重要性</h3><blockquote><p>编写文体上“良好” 的代码很费时，而编写出功能分离、注释充分、结构清晰的相同程序需要更长时间，那么就有一个问题这值吗？显然，既然提出那么结果必然是值得的；</p></blockquote><hr><h4 id="1-1事先考虑"><a href="#1-1事先考虑" class="headerlink" title="1.1事先考虑"></a>1.1事先考虑</h4><blockquote><p>实际中如果没有良好的编码风格会有以下问题：</p><ol><li>对于新手不友好；</li><li>几乎无法代码维护，代价极大；</li><li>难以复用代码实现；</li></ol></blockquote><hr><h4 id="1-2良好风格的元素"><a href="#1-2良好风格的元素" class="headerlink" title="1.2良好风格的元素"></a>1.2良好风格的元素</h4><blockquote><p>良好代码的共通原则：</p><ul><li>文档</li><li>分解</li><li>命名</li><li>语言的使用</li><li>格式</li></ul></blockquote><hr><h3 id="3-2为代码编写文档"><a href="#3-2为代码编写文档" class="headerlink" title="3.2为代码编写文档"></a>3.2为代码编写文档</h3><blockquote><p>在编程环境下，文档通常指源文件中的注释。当编写相关代码时，注释用来说明你当时的想法。这里给出的信息应当是不能轻易从代码中看出来的。</p></blockquote><hr><h4 id="2-1使用注释的原因"><a href="#2-1使用注释的原因" class="headerlink" title="2.1使用注释的原因"></a>2.1使用注释的原因</h4><blockquote><p>使用注释明显能够提高效率、易于理解代码等优点，下面给出全部使用注释的原因：</p><ol><li><p>说明用途的注释：</p><blockquote><p><strong>使用注释的原因之一是说明客户如何与代码交互。通常而言，开发人员应当能够根据函数名、返回值的类型以及参数的类型和名称来推断函数的功能。</strong>但是，代码本身不能解释一切。有时， 一个函数需要一些先置条件或后置条件，而这些需要在注释中解释。函数可能抛出的异常也应当在注释中解释。在笔者看来，只有当注释能提供有用的信息时才添加注释。因此，应由开发人员确定函数是否需要添加注释。经验丰富的程序员能可靠地确定这一点，但经验不足的开发人员则未必能做出正确的决策。<strong>因此，一些公司制定规则，要求头文件中每个公有访问的函数或方法都应该带有解释其行为的注释。某些组织喜欢将注释规范化，明确列出每个方法的目的、参数、返回值以及可能抛出的异常。</strong>  </p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*通过注释，可用自然语言陈述在代码中无法陈述的内容。例如，在 C++中无法说明：数据库对象的saveRecord()方法只能在 openDatabaseo方法之后调用，否则将抛出异常。但可以使用注释提示这一限制，如下所示：*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* This method throws a ,,DatabaseNotOpenedExceptionH</span><br><span class="hljs-comment">* if the openDatabase() method has not been called yet.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">saveRecord</span><span class="hljs-params">(Record&amp; record)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*C++语言强制要求指定方法的返回类型，但是无法说明返回值实际代表了什么。例如，saveRecord() 方法的声明可能指出这个方法返回 int 类型(这是一种不良的设计决策，见下一节的讨论)，但是阅读这个声明的客户不知道 int 的含义。注释可解释其含义：*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* Returns: int</span><br><span class="hljs-comment">* An integer representing the ID of the saved record.</span><br><span class="hljs-comment">* Throws:</span><br><span class="hljs-comment">* DatabaseNotOpenedException if the openDatabase() method has not</span><br><span class="hljs-comment">* been called yet.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">saveRecord</span><span class="hljs-params">(Record&amp; record)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*如前所述，有些公司要求用正式方式记录有关函数的所有信息。下例演示了遵守这个原则的 saveRecord()方法：*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* saveRecord( )</span><br><span class="hljs-comment">* Saves the given record to the database.</span><br><span class="hljs-comment">* Parameters:</span><br><span class="hljs-comment">* Records record: the record to save to the database.</span><br><span class="hljs-comment">* Returns: int</span><br><span class="hljs-comment">* An integer representing the ID of the saved record.</span><br><span class="hljs-comment">* Throws:</span><br><span class="hljs-comment">* DatabaseNotOpenedException if the openDatabase() method has not</span><br><span class="hljs-comment">* been called yet.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">saveRecord</span><span class="hljs-params">(Record&amp; record)</span></span>;<br><br><span class="hljs-comment">/* 但不建议使用这种风格的注释。前两行完全无用，因为函数名的含义不言自明。对形参的解释也不能添加任何附加信息。*/</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*更好的设计方式是返回 RecordID 而非普通的 int 类型，那样的话，就不需要为返回类型添加注释。RecordID 只是 int 的类型别名(见第 11 章)，但传达的信息更多。唯一必须保留的注释是异常。因此，建议使用如下 saveRecord() 方法：*/</span><br><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">* Throws:</span><br><span class="hljs-comment">* DatabaseNotOpenedException if the openDatabase() method has not</span><br><span class="hljs-comment">* been called yet.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">RecordID <span class="hljs-title">saveRecord</span><span class="hljs-params">(Record&amp; record)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*有时函数的参数和返回值是泛型，可用来传递任何类型的信息。在此情况下应该清楚地用文档说明所传递的确切类型。例如，Windows 的消息处理程序接收两个参数 LPARAM 和 WPARAM, 返回 LRESUUT。这些参数和返回值可以传递任何内容，但是不能改变它们的类型。使用类型转换，可以用它们传递简单的整数，或者传递指向某个对象的指针。文档应该是这样的：*/</span><br><br><span class="hljs-comment">/* Parameters:</span><br><span class="hljs-comment">* WPARAM wParam: (WPARAM)(int): An integer representing...</span><br><span class="hljs-comment">* LPARAM IParam: (LPARAM)(string*): A string pointer representing...</span><br><span class="hljs-comment">* Returns: (LRESULT)(Record*)</span><br><span class="hljs-comment">* nullptr in case of an error, otherwise a pointer to a Record object</span><br><span class="hljs-comment">* representing ...</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure></blockquote></li><li><p>用来说明复杂代码的注释</p><blockquote><p>在专业领域中，代码的算法往往复杂、深奥，很难理解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 实现插入排序算法。该算法将数组分为两部分——有序部分和无序部分。</span><br><span class="hljs-comment"> * 每个元素，从位置1开始，都会被检查。数组中早于当前位置的元素都在有序部分，</span><br><span class="hljs-comment"> * 因此算法会将每个元素向右移动，直到找到正确的位置以插入当前元素。</span><br><span class="hljs-comment"> * 当算法完成对最后一个元素的操作时，整个数组都已排序。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-type">int</span> inArray[], <span class="hljs-type">size_t</span> inSize)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 从位置1开始，检查每个元素。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">1</span>; i &lt; inSize; i++) <br>    &#123;<br>        <span class="hljs-comment">// 循环不变式：</span><br>        <span class="hljs-comment">// 在范围0到i-1（包括i-1）的所有元素都是有序的。</span><br>        <span class="hljs-type">int</span> element = inArray[i];<br>        <span class="hljs-comment">// j 标记在有序部分中，element 将要插入的位置之后。</span><br>        <span class="hljs-type">size_t</span> j = i - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 只要有序数组中的当前槽位的值大于 element，将值向右移动以为插入 element 腾出位置</span><br>        <span class="hljs-comment">//（因此称为 &quot;插入排序&quot;）。</span><br>        <span class="hljs-keyword">while</span> (j &gt;= <span class="hljs-number">0</span> &amp;&amp; inArray[j] &gt; element) &#123;<br>            inArray[j + <span class="hljs-number">1</span>] = inArray[j];<br>            j--;<br>        &#125;<br>        <span class="hljs-comment">// 此时有序数组中的当前位置不大于 element，因此这是 element 的新位置。</span><br>        inArray[j + <span class="hljs-number">1</span>] = element;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>新代码有所增长，但通过注释，使得不熟悉代码的读者也能理解这段代码；</p></blockquote></li><li><p>传递元信息的注释</p><blockquote><p>使用注释的另一个原因高于代码层次提供信息，元信息提供代码的详细信息，但是不涉及代码的特定行为。例如，某组织可能想使用元信息跟踪每个方法的原始作者。还可以使用元信息引用外部文档或其他代码；</p><p>下例给出了元信息的几个实例，包括文件的作者、创建日期、提供的特性。此外还包括表示元数据的行内注释，例如对应某行代码的 bug </p><p>编号，提醒以后重新访问时代码中某个可能的问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++">   &gt;<span class="hljs-comment">/*</span><br><span class="hljs-comment">   &gt;* Author: marcg </span><br><span class="hljs-comment">   &gt;* Date: 110412</span><br><span class="hljs-comment">   &gt;* Feature: PRD version 3, Feature 5.10</span><br><span class="hljs-comment">   &gt;*/</span> <br><br>   &gt;<span class="hljs-function">RecordID <span class="hljs-title">saveRecord</span><span class="hljs-params">(Records record)</span> </span><br><span class="hljs-function">   &gt;</span>&#123; <br>  <span class="hljs-keyword">if</span> (!mDatabaseOpen) <br>&#123; <br>      <span class="hljs-keyword">throw</span> <span class="hljs-built_in">DatabaseNotOpenedException</span>(); <br>   &#125; <br>RecordID id = <span class="hljs-built_in">getDB</span>()-&gt;<span class="hljs-built_in">saveRecord</span>(record);<br><span class="hljs-keyword">if</span> (id == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// Added to address bug #142 - jsmith 110428</span><br>record.<span class="hljs-built_in">setld</span>(id); <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> What if setld() throws an exception? - akshayr 110501</span><br>   &gt;&#125;<br>   &gt;<span class="hljs-comment">/*</span><br><span class="hljs-comment">   &gt;* Date   | Change</span><br><span class="hljs-comment">   &gt;*--------+-------------------------------------------</span><br><span class="hljs-comment">   &gt;* 110413 |REQ #005: &lt;marcg&gt; Do not normalize values.</span><br><span class="hljs-comment">   &gt;* 110417 | REQ #006: &lt;marcg&gt; use nullptr instead of NULL.</span><br><span class="hljs-comment">   &gt;*/</span><br></code></pre></td></tr></table></figure><p><strong>警告：</strong><br><strong>使用第 24 章讲述的源代码控制方案（也应当使用该方案）， 前几个示例中就不必使用所有元信息（TODO 注释除外）。 源代码控制方案提供了带注释的修改历史，包括修改日期、修改人、对每个修改的注释（假定使用正确），以及对修改请求和 bug 报告的引用。应 当使用描述性注释，分别签入（check-in）、提交每个修改请求或 bug修复。有了这样的系统，你不必手动跟踪元信息。</strong></p><p><strong>另一种元信息类型是版权声明。有些公司要求在每个源文件的开头添加此类版权信息。</strong></p><p><strong>注释很容易走向极端。最好与团队成员讨论哪种类型的注释最有用，并制定约定。例如，如果团队的某个成员使用 TODO 注释表明代码仍然需要加工，但是其他人不知道这个约定，这段代码就可能被忽略。</strong></p><p>具体略过了，看课本吧，这太麻烦了，不是我想学的东西；</p></blockquote></li></ol></blockquote><hr><p>2.2注释的风格</p><blockquote><ol><li>错误：每行均注释，完全没必要，可以写很多，但是要保证有用；</li><li>正确：前置注释，某些源代码控制系统，例如(Subversion(SVN))甚至可以帮忙填写元数据；<ul><li>最近的修改日期</li><li>原始作者</li><li>前面所讲的修改日志</li><li>文件给出的功能</li><li>版权信息</li><li>文件或类的简要说明</li><li>未完成的功能</li><li>已知的 bug</li></ul></li><li>固定格式的注释，关于 Doxygen 的学习之后再说。</li><li>特殊注释：<ul><li>注释之前，思考是否可以通过修改代码来避免注释，如：重命名变量、函数与类、重新排列代码步骤的顺序，引入完好命名的中间变量；</li><li>他人难以察觉的微妙之处应当注释；</li><li>不要在代码中加入姓名缩写，源代码控制解决方案会自动跟踪这些信息；</li><li>如果处理不太明显的 API，应当再解释 API 的地方对 API 文档进行引用；</li><li>更新代码时，记得更新注释；</li><li>如果使用注释将某个函数分为多节，那么考虑这个函数是否可以被分为多个更小的函数；</li></ul></li><li>自文档化代码<ul><li>编写良好的代码并非总是需要充裕的注释，优秀的代码本身就容易阅读。</li><li>如果给每行代码都加入注释，考虑是否可重写这些代码，以更好地配合注释内容。</li><li>例如给函数、参数、变量等使用描述性名称。</li><li>合理使用 const, 也就是说，如果不准备修改变量，就将其标记为 const </li><li>重新排列函数中步骤的顺序，使人更容易理解其作用。</li><li>引入命名良好的中间变量，使算法更易懂。</li></ul></li></ol></blockquote><hr><h3 id="3-3分解-decomposition"><a href="#3-3分解-decomposition" class="headerlink" title="3.3分解(decomposition)"></a>3.3分解(decomposition)</h3><blockquote><p>分解指将代码分为小段；</p><p>当有新要求或修订 bug 时，会对现有的代码进行少量修改，计算机术语 cruft 便是指的逐渐积累少量代码使得曾经优雅的代码编程一堆补丁和特例；</p></blockquote><hr><h4 id="3-1通过重构-refactoring-分解"><a href="#3-1通过重构-refactoring-分解" class="headerlink" title="3.1通过重构(refactoring)分解"></a>3.1通过重构(refactoring)分解</h4><blockquote><p>增强抽象的技术：</p><ul><li>封装字段：私有化字段，使用 get() 方法、set() 方法；</li><li>让类型通用：创建更通用类型，便于共享代码；</li></ul><p>分割代码使其更合理的技术：</p><ul><li>提取方法：将一个大方法的部分提取成为便于理解的方法；</li><li>提取类：将现有类的部分代码转移到新类中；</li></ul><p>增强代码名称和位置的技巧：</p><ul><li>移动方法或字段：移动到更合适的类或源文件中；</li><li>重命名方法或字段：使之名称更符合其含义；</li><li>上移(pull up)：在 OOP 中，移到基类；</li><li>下移(push down)：在 OOP 中，移到派生类；</li></ul><p>详细见课本内容，这对我目前意义不大。</p></blockquote><hr><h4 id="3-2通过设计来分解"><a href="#3-2通过设计来分解" class="headerlink" title="3.2通过设计来分解"></a>3.2通过设计来分解</h4><blockquote><p>略。</p></blockquote><hr><h4 id="3-3本书的分解"><a href="#3-3本书的分解" class="headerlink" title="3.3本书的分解"></a>3.3本书的分解</h4><blockquote><p>略。</p></blockquote><hr><h3 id="3-4命名"><a href="#3-4命名" class="headerlink" title="3.4命名"></a>3.4命名</h3><blockquote><p>编译器的几个命名规则：</p><ul><li><p>名称不以数字开头；</p></li><li><p>包含两个下划线的名称(例如 my__name) 是保留名称，不应当使用；</p><blockquote><p>C++标准（例如C++17）规定了使用双下划线开头或结尾的标识符是保留给实现的。这意味着用户代码不应该在标识符的开头或结尾使用双下划线，以免与实现的标识符冲突。</p></blockquote></li><li><p>以下划线开头(例如 _Name 或 __Name) 是保留名称，不应该使用；</p></li></ul></blockquote><hr><h4 id="4-1选择恰当的名称"><a href="#4-1选择恰当的名称" class="headerlink" title="4.1选择恰当的名称"></a>4.1选择恰当的名称</h4><blockquote><img src="https://bu.dusays.com/2024/03/15/65f445c1327d8.png" alt="image-20240204084416838"  /><p>如上。</p></blockquote><hr><h4 id="4-2命名约定"><a href="#4-2命名约定" class="headerlink" title="4.2命名约定"></a>4.2命名约定</h4><blockquote><ol><li>计数器：【i、j】【row、column】【outerLoopIndex、innerLoopIndex】</li><li>前缀：使用前缀会使得相关代码难以维护，例如，如果某个成员变量从静态变为非静态，这意味着所有用到这个名称的地方都要修改。这通常非常耗时，因此大多数程序员不会重命名这个变量。随着代码的演变,变量的声明变了，但是名称没有变。结果是名称给出了虚假的语义，实际上这个语义是错误的。</li></ol><p><img src="https://bu.dusays.com/2024/03/15/65f445c54d5dc.png" alt="image-20240204084721064"></p><ol start="3"><li><p>匈牙利表示法是关于变量和数据成员的命名约定，在 Microsc仕 Windows 程序员中很流行。其基本思想是使用更详细的前缀而不是一个字母(例如 m)表示附加信息。下面这行代码显示了匈牙利表示法的用法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span>* pszName; <span class="hljs-comment">// psz means &quot;pointer to a null-terminated string&quot;</span><br></code></pre></td></tr></table></figure><p>术语“匈牙利表示法”源于其发明者 Charles Simonyi 是匈牙利人。也有人认为这准确地反映了一个事实：使用匈牙利表示法的程序好像是用外语编写的。为此，一些程序员不喜欢匈牙利表示法。本书使用前缀，而不使用匈牙利表示法。合理命名的变量不需要前缀以外的附加上下文信息，例如，用 mName 命名数据成员就足够了。</p></li><li><p>get() 和 set()</p></li><li><p>大小写，统一即可</p></li><li><p>把常量放到名称空间</p><blockquote><p>假定编写一个带图形用户界面的程序。这个程序有几个菜单，包括 File、 Edit 和 Help。用常量代表每个菜单的 ID。kHelp 是代表 Help 菜单 ID 的一个好名字。</p><p>名称 kHelp一直运行良好，直到有一天在主窗口上添加了一个 Help 按钮。还需要一个常量来代表 Help 按钮的 ID, 但是 kHelp 已经被使用了。</p><p>在此情况下,建议将常量放到不同的名称空间中，名称空间参见第 1 章。可以创建两个名称空间: Menu 和 Button。</p><p>每个名称空间中都有一个 kHelp 常量，其用法为 Menu::kHelp 和 Button::kHelpo </p><p>另一个更好的方法是使用枚举器，参见第 1 章。</p></blockquote></li></ol></blockquote><hr><h3 id="3-5使用具有风格的语言特征"><a href="#3-5使用具有风格的语言特征" class="headerlink" title="3.5使用具有风格的语言特征"></a>3.5使用具有风格的语言特征</h3><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">i++ + ++i;<br>a[i] = ++i;<br><br>第一行完全没有标准，结果取决于平台；<br>第二行在 C++ <span class="hljs-number">17</span> 中是确定的：i先递增，再在 a[i] 中用作索引；<br></code></pre></td></tr></table></figure><p>但它们的共同特点就是：丑陋。</p></blockquote><hr><h4 id="5-1使用常量"><a href="#5-1使用常量" class="headerlink" title="5.1使用常量"></a>5.1使用常量</h4><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-type">double</span> result = <span class="hljs-number">2.71828</span> * <span class="hljs-number">5.0</span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br><br><span class="hljs-comment">// 推荐的方式，使用常量 M_E</span><br>result = M_E * <span class="hljs-number">5.0</span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure></blockquote><hr><h4 id="5-2使用引用代替指针"><a href="#5-2使用引用代替指针" class="headerlink" title="5.2使用引用代替指针"></a>5.2使用引用代替指针</h4><blockquote><p><strong>C++程序员通常开始学的是 C。在 C 中，指针是按引用传递的唯一机制</strong>，多年来一直运行良好。在某些情况下仍然需要指针，但在许多情况下可以用引用代替指针。如果开始学习的是 C, 可能认为引用实际上没有给C++语言增加新的功能，只是引入了一种新的语法，其功能己经由指针提供。  </p><p><strong>用引用替换指针有许多好处。</strong>首先，<strong>引用比指针安全</strong>，因为<strong>引用不会直接处理内存地址，也不会是 nullptr</strong>。其次，<strong>引用在文体上比指针好</strong>，因为引<strong>用使用与堆栈变量相同的语法，没有使用 * 和&amp;等符号</strong>。引用易于使用，因此将引用加入风格中没有任何问题。遗憾的是，某些程序员认为，如果在函数调用中看到&amp;，被调用的函数将改变对象；如果没有看到&amp;，对象一定是按值传递。而使用引用，就无法判断函数是否将改变对象，除非看到函数原型。这种思维方式是错误的。用指针传递未必意味着对象将改变，因为参数可能是 const T。<strong>传递指针或引用是否会修改对象，都取决于函数原型是否使用了 const T* 、T*、constT&amp;或 T&amp;。因此，只有查看函数原型，才能判断函数是否改变对象</strong>。  </p><p><strong>使用引用的另一个好处是它明确了内存的所有权。如果一个程序员编写了一个方法，另一个程序员传递给它一个对象的引用，很明显可以读取并修改这个对象，但是无法轻易地释放对象的内存。如果传递的是一个指针，就不那么明显。需要删除对象来清理内存吗？还是调用者需要这样做？处理内存的较好方法是使用第 1 章介绍的智能指针.</strong>  </p></blockquote><hr><h4 id="5-3使用自定义异常"><a href="#5-3使用自定义异常" class="headerlink" title="5.3使用自定义异常"></a>5.3使用自定义异常</h4><blockquote><p>C++可以很方便地忽略异常，这一语言的语法没有强制处理异常，可以很方便地用传统的机制（例如返回nullptr 或者设置错误标志）编写容错程序。</p><p>异常提供了更丰富的错误处理机制，自定义异常允许根据需要进行取舍。例如，Web 浏览器的自定义异常类型包含的字段可指定包含错误的页面、错误发生时的网络状态和附加的环境信息。  </p><p>第 14 章将详细讲述 C++中的异常 。</p></blockquote><hr><h3 id="3-6格式"><a href="#3-6格式" class="headerlink" title="3.6格式"></a>3.6格式</h3><blockquote><p>一句话，统一的就是好的。</p></blockquote><hr><h4 id="6-1关于大括号对齐的争论"><a href="#6-1关于大括号对齐的争论" class="headerlink" title="6.1关于大括号对齐的争论"></a>6.1关于大括号对齐的争论</h4><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">Staff<br>&#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>我都是这样用的；</p></blockquote><hr><h4 id="6-2关于空格和圆括号的争论"><a href="#6-2关于空格和圆括号的争论" class="headerlink" title="6.2关于空格和圆括号的争论"></a>6.2关于空格和圆括号的争论</h4><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">function</span>();<br><span class="hljs-keyword">if</span> ()<br><span class="hljs-keyword">for</span> ()<br></code></pre></td></tr></table></figure><p>函数不空格，判定循环语句空格；</p></blockquote><hr><h4 id="6-3空格和制表符"><a href="#6-3空格和制表符" class="headerlink" title="6.3空格和制表符"></a>6.3空格和制表符</h4><blockquote><p>没啥说的；</p></blockquote><hr><h3 id="3-7风格的挑战"><a href="#3-7风格的挑战" class="headerlink" title="3.7风格的挑战"></a>3.7风格的挑战</h3><blockquote><p>许多程序员在项目开始时都保证他们将做好每件事。只要变量或参数永远不变，就将其标记为 const。所有变量都具有清楚的、简明的、容易阅读的名称。每个开发人员都将左大括号放在后续行，采用标准文本编辑器,并遵循关于制表符和空格的约定。</p><p>维持这种层次的格式一致非常困难，原因有很多<strong>。当涉及 const 时，有些程序员不知道如何用它。总会遇到不支持 const 的旧代码或库函数。好的程序员会使用 const_cast 暂时取消变量的 const 属性，但缺少经验的程序员会取消来自调用函数的 const 属性，结果，程序从不使用 const。</strong></p><p>有时，标准化的格式会与程序员的个人口味和偏好发生冲突。或许团队文化无法强制使用严格的风格准则。此类情况下，必须判断哪些元素需要标准化(例如变量名称和制表符)，哪些元素可以由个人决定其风格(或许空格和注释格式可以这样)。甚至可以获取或编写脚本，自动纠正格式 bug, 或将格式问题与代码错误一起标记。一些开发环境，例如 Microsoft Visual C++ 2013, 支持根据指定的规则自动格式化代码，这样就很容易编写出始终遵循指定规则的代码</p></blockquote><hr><h3 id="3-8本章小结"><a href="#3-8本章小结" class="headerlink" title="3.8本章小结"></a>3.8本章小结</h3><blockquote><p>一句话，风格好就是NB。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 复习教程第一章（使用 string 和 string_view）</title>
    <link href="/2024/03/14/C++%20%E5%A4%8D%E4%B9%A0%E6%95%99%E7%A8%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%88%E4%BD%BF%E7%94%A8%20string%20%E5%92%8C%20string_view%EF%BC%89/"/>
    <url>/2024/03/14/C++%20%E5%A4%8D%E4%B9%A0%E6%95%99%E7%A8%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%88%E4%BD%BF%E7%94%A8%20string%20%E5%92%8C%20string_view%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="第2章-——-使用-string-和-string-view"><a href="#第2章-——-使用-string-和-string-view" class="headerlink" title="第2章 —— 使用 string 和 string_view"></a>第2章 —— 使用 string 和 string_view</h2><hr><blockquote><p>你编写的每个应用程序都会使用某种类型的字符串。<strong>使用老式 C 语言时，没有太多选择，只能使用普通的以 null 结尾的字符数组来表示字符串。遗憾的是，这种表示方式会导致很多问题，例如会导致安全攻击的缓冲区溢出。C++标准库包含了一个安全易用的 substring 类，这个类没有这些缺点；</strong>  </p></blockquote><h3 id="2-1动态字符串"><a href="#2-1动态字符串" class="headerlink" title="2.1动态字符串"></a>2.1动态字符串</h3><blockquote><p>在将字符串当成一等对象支持的语言中，字符串有很多有吸引人的特性，例如可扩展至任意大小，或能提取或替换子字符串。<strong>在其他语言（如 C 语言）中，字符串几乎就像后加入的功能；C 语言中并没有真正好用的 string数据类型，只有固定的字节数组。“字符串库”只不过是一组非常原始的函数，甚至没有边界检查的功能。C++ 提供了 string 类型作为一等数据类型。</strong></p></blockquote><hr><h4 id="1-1C风格的字符串"><a href="#1-1C风格的字符串" class="headerlink" title="1.1C风格的字符串"></a>1.1C风格的字符串</h4><blockquote><ul><li><p>在 C 语言中，字符串表示为字符的数组。<strong>字符串中的最后一个字符是 null 字符（’\0’）</strong>, 这样，操作字符串的代码就知道字符串在哪里<strong>结束</strong>。</p></li><li><p><strong>官方将这个 null 字符定义为 NUL, 这个拼写中只有一个 L, 而不是两个 L，NUL和 NULL 指针是两回事。</strong></p></li><li><p>尽管 C++提供了更好的字符串抽象，但<strong>理解 C 语言中使用的字符串技术非常重要</strong>，因为在 C++程序设计中仍可能使用这些技术。<strong>最常见的一种情况是 C++程序调用某个第三方库中（作为操作系统接口的一部分）用 C 语言编写的接口。</strong>  </p></li><li><p>目前，程序员最容易犯的错误是忘记为 <strong>‘\0’</strong> 分配空间。例如，<strong>字符串 “hello” 看上去有 5 个字符长，但是实际在内存上需要 6 个字符空间才能保存这个字符串的值</strong>。</p></li><li><p><strong>C++ 中包含一些来自 C 语言的字符串操作函数，它们被定义在 <cstring> 中定义，通常，这些函数不直接操作内存分配。</strong>例如，strcpy() 函数有两个字符串参数。这个函数将第二个字符串赋值到第一个字符串，而不考虑第二个字符串能否恰当地填入第一个字符串中。<strong>下面代码试图在 strcpy() 函数之上构建一个包装器，这个包装器能够分配正确数量的内存并返回结果，而不是接受一个已经分配好的字符串。这个函数通过 strlen() 函数获取字符串的长度。</strong>调用者则负责释放 copyString() 分配的空间：</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">copyString</span><span class="hljs-params">(cnost <span class="hljs-type">char</span>* str)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span>* result = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str)];<span class="hljs-comment">// BUG !!! OFF BY ONE !</span><br> <span class="hljs-built_in">strcpy</span>(result, str);<br> <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><p><strong>cpoyString() 函数的代码这样写是不正确的。</strong>strlen() 函数返回字符串长度，而不是保存这个字符串所需的内存量。对于字符串 “hello”，strlen() 返回的是 5，而不是 6。<strong>为字符串分配内存的正确方式是在实际字符所需空间 +1。一开始看到到处都要加 1 可能会感到有点奇怪，但这是其工作方式，所以在使用 C 风格的字符串时要注意记住这一点。</strong>正确的实现代码如下：</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">copyString</span><span class="hljs-params">(cnost <span class="hljs-type">char</span>* str)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span>* result = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-built_in">strlen</span>(str) + <span class="hljs-number">1</span>];<br> <span class="hljs-built_in">strcpy</span>(result, str);<br> <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><p><strong>要记住 strlen() 只返回字符串中实际字符数目的一种方式是：考虑如果为一个由几个其他字符串构成的字符串分配空间，应该怎么做。</strong>例如，如果函数接收 3 个字符串参数，并返回一个由这 3 个字符串串联而成的字符串，那么这个返回的字符串应该有多大？<strong>为精确分配足够空间，空间的大小应该是 3 个字符串的长度相加，然后加上 1 留给尾部的 ‘\0’ 字符。</strong>如果 strlen() 的字符串长度包含 strcpy() 和 strcat() 函数执行这个操作。strcat()中的 cat 表示串联：</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">appendStrings</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* str1, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* str2, cosnt <span class="hljs-type">char</span>* str3)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span>* result = <span class="hljs-keyword">new</span> str[<span class="hljs-built_in">strlen</span>(str1) + <span class="hljs-built_in">strlen</span>(str2) + <span class="hljs-built_in">strlen</span>(str3) + <span class="hljs-number">1</span>];<br> <span class="hljs-built_in">strcopy</span>(result, str1);<br> <span class="hljs-built_in">strcat</span>(result, str2);<br> <span class="hljs-built_in">strcat</span>(reslut, str3);<br><br> <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>C 和 C++中的 sizeof() 操作符可用于获得给定数据类型或变量的大小。例如，sizeof(char)返回 1, 因为字符的大小是 1 字节。<strong>但在 C 风格的字符串中，sizeof() 和 strlen() 是不同的，绝对不要通过 sizeof() 获得字符串的大小。它根据 C 风格的字符串的存储方式来返回不同大小。如果 C 风格的字符串存储为 char[]，则 sizeof() 返回字符串使用的实际内存，包括’\0’字符。</strong>例如：</p><blockquote><p><strong>存储为 char[] 下的 C 风格字符串：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> text1[] = <span class="hljs-string">&quot;abcdef&quot;</span>;<br><span class="hljs-type">size_t</span> s1 = <span class="hljs-built_in">sizeof</span>(text1);<span class="hljs-comment">// is 7</span><br><span class="hljs-type">size_t</span> s2 = <span class="hljs-built_in">strlen</span>(text1);<span class="hljs-comment">// is 6</span><br><span class="hljs-type">size_t</span> s0 = <span class="hljs-built_in">sizeof</span>(&amp;text1);<span class="hljs-comment">// is situation as sizeof(text2) below</span><br><br><span class="hljs-comment">// 这里返回的是这个数组的长度</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">优点：</span><br><span class="hljs-comment">占用的内存大小是在编译时确定的，sizeof() 可以直接获取数组的大小。</span><br><span class="hljs-comment">适用于需要修改字符串内容的场景，因为数组是可修改的。</span><br><span class="hljs-comment">缺点：</span><br><span class="hljs-comment">占用的内存空间较大，因为数组的大小包括了字符串内容和额外的 null 终止符。</span><br><span class="hljs-comment">不适用于常量字符串，因为数组的内容可修改</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><em><em>存储为 char</em> 下的 C 风格字符串：</em>*</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* text2 = <span class="hljs-string">&quot;abcdef&quot;</span>;<br><span class="hljs-type">size_t</span> s3 = <span class="hljs-built_in">sizeof</span>(text2);<span class="hljs-comment">// is platform-dependent</span><br><span class="hljs-type">size_t</span> s4 = <span class="hljs-built_in">strlen</span>(text2);<span class="hljs-comment">// is 6</span><br><br><span class="hljs-comment">// 在 32 位模式下编译时，s3 的值为 4；</span><br><span class="hljs-comment">// 在 64 位模式下编译时，s4 的值位 8；</span><br><span class="hljs-comment">// 原因是因为这返回的是 指针 const char* 的大小</span><br><br>std::cout &lt;&lt; (text1 == text2) &lt;&lt; <span class="hljs-string">&quot;    &quot;</span> &lt;&lt; (std::<span class="hljs-built_in">strcmp</span>(text2, text1) == <span class="hljs-number">0</span>) &lt;&lt; std::endl;<span class="hljs-comment">// 返回 0</span><br><br><span class="hljs-comment">// 这说明这完全不一样的两种东西</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">优点：</span><br><span class="hljs-comment">占用的内存大小是在编译时确定，sizeof() 得到的是指针大小，不受字符串内容影响。</span><br><span class="hljs-comment">适用于常量字符串，因为字符串内容是不可修改的。</span><br><span class="hljs-comment">占用的内存空间相对较小，因为只有指针的大小。</span><br><span class="hljs-comment">缺点：</span><br><span class="hljs-comment">不适用于需要修改字符串内容的场景，因为字符串是常量。</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-type">char</span>* ptr = <span class="hljs-keyword">new</span> <span class="hljs-type">char</span>[<span class="hljs-number">7</span>];<br><span class="hljs-built_in">strcpy_s</span>(ptr, <span class="hljs-number">7</span>, <span class="hljs-string">&quot;abcdef&quot;</span>);<br></code></pre></td></tr></table></figure></blockquote></li><li><p><strong>警告：</strong></p><blockquote><p><strong>在 Microsoft Visual Studio 中使用 C 风格的字符串函数时，编译器可能会给出安全相关的警告甚至错误，说明这些函数已经被废弃了</strong>。<strong>使用其他 C 标准库函数可以避免这些警告</strong>，例如 <strong>strcpy_s()<strong>和 <strong>strcat_s()</strong>, 这些函数是</strong>“安全 C 库”(ISO&#x2F;IEC TR24731)标准</strong>的一部分。然而，<strong>最好的解决方案是切换到 C++的 string 类，本章后面的”C++ std::string 类” 小节会讨论这个类</strong>；</p></blockquote></li></ul></blockquote><hr><h4 id="1-2字符串字面量-string-literal"><a href="#1-2字符串字面量-string-literal" class="headerlink" title="1.2字符串字面量*(string literal)*"></a>1.2字符串字面量*(string literal)*</h4><hr><h5 id="1-字面量池和不同类型定义方式"><a href="#1-字面量池和不同类型定义方式" class="headerlink" title="1.字面量池和不同类型定义方式"></a>1.<strong>字面量池和不同类型定义方式</strong></h5><blockquote><ul><li><strong>注意，C++ 程序中编写的字符串要用引号包围。</strong>例如，下面的代码输出字符串 “hello”，这段代码中包含这个字符串本身，而不是一个包含这个字符串的变量：</li></ul><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::cout &lt;&lt; <span class="hljs-string">&quot;hello&quot;</span> &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure></blockquote><ul><li><strong>与字符串字面量关联的真正内存位于内存的只读部分。通过这种方式，编辑器可重用等价字面量的引用，从而优化内存的使用。</strong>也就是说，即使一个程序使用了 500 次 “hello” 字符串字面量，编译器也只在内存中创建一个 “hello” 实例。**这种技术被称为字面量池 *(literal pooling)***；</li><li>字符串字面量可赋值给变量，但因为字符串字面量位于内存的只读部分，且使用了字面量池，所以这样做会产生风险——也就是说，<strong>字符串的字面量类型为 “n 个 const char 的数组”</strong>，但是显然为了兼容较老的不支持 const 的代码，<em><em>大部分编译器不会强制程序将字符串字面量赋值给 const char</em> 类型的变量</em>*。但是，如果试图修改字符串，一般情况下，这种行为是没有定义的，会使得程序崩溃；但也可能能够使得程序继续执行，却又一些很莫名其妙的副作用；可能不加通告地忽略修改行为；可能修改行为是有效的，这完全取决于编译器。</li><li><strong>下面的行为是未定义的：</strong></li></ul><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span>* ptr = <span class="hljs-string">&quot;hello&quot;</span>; <span class="hljs-comment">// Assign the string literal to a variable.</span><br>ptr[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;a&#x27;</span>; <span class="hljs-comment">// Undefined behavior!</span><br></code></pre></td></tr></table></figure></blockquote><ul><li><strong>但是，更好的代码习惯是更好的：</strong></li></ul><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* ptr = <span class="hljs-string">&quot;hello&quot;</span>; <span class="hljs-comment">// Assign the string literal to a variable.</span><br>ptr[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;a&#x27;</span>; <span class="hljs-comment">// Error! Attempts to write to read-only memory</span><br></code></pre></td></tr></table></figure></blockquote><ul><li><strong>此外，使用 array 方式存储能够实现修改，也就是说，这时的 C 风格字符串并不在字面量池中，而是可以进行修改的：</strong></li></ul><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> arr[] = <span class="hljs-string">&quot;hello&quot;</span>; <span class="hljs-comment">// Compiler takes care of creating appropriate sized</span><br><span class="hljs-comment">// character array arr.</span><br>arr[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;a&#x27;</span>;   <span class="hljs-comment">// The contents can be modified.</span><br></code></pre></td></tr></table></figure></blockquote></blockquote><h5 id="2-原始字符串字面量-raw-string-literal"><a href="#2-原始字符串字面量-raw-string-literal" class="headerlink" title="2.原始字符串字面量 (raw string literal)"></a>2.<strong>原始字符串字面量</strong> <em>(raw string literal)</em></h5><blockquote><ul><li><strong>原始字符串字面量是可横跨多行代码的字符串字面量，不需要转义嵌入的双引号</strong>，像 <strong>‘\t’</strong> 和 <strong>‘\n’</strong> 这种转义序列不按照转义序列的方式处理，<strong>而是按照普通文本的方式处理</strong>。转义字符在第 1 章讨论过了。如果像下面这样编写普通的字符串字面量，那么会收到一个编译器错误，因为字符串包含了未转义的双引号：</li></ul><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* str = <span class="hljs-string">&quot;Hello &quot;</span>World<span class="hljs-string">&quot;!&quot;</span>;<span class="hljs-comment">// Error!</span><br></code></pre></td></tr></table></figure></blockquote><ul><li><strong>对于普通字符串，必须转义双引号，如下所示：</strong></li></ul><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* str = <span class="hljs-string">&quot;Hello \&quot;World\&quot;!&quot;</span>;<br></code></pre></td></tr></table></figure></blockquote><ul><li><strong>对于原始字符串字面量，就不需要转义双引号了:</strong></li></ul><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 格式：</span><br><span class="hljs-comment">// R&quot;(......)&quot;</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* str = <span class="hljs-string">R&quot;(Hello &quot;World&quot;!)&quot;</span>;<br></code></pre></td></tr></table></figure></blockquote><ul><li><strong>换行转义：</strong></li></ul><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* str = <span class="hljs-string">&quot;Line 1\nLine 2&quot;</span>;<br></code></pre></td></tr></table></figure></blockquote><ul><li><strong>原始字符串字面量换行，直接 Enter 换行，与之前效果一样：</strong></li></ul><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">const char* <span class="hljs-built_in">str</span> = <span class="hljs-string">R&quot;(Line 1</span><br><span class="hljs-string">Line2)&quot;</span>;<br></code></pre></td></tr></table></figure></blockquote><ul><li><p><strong>注意：</strong></p><blockquote><p>原始字符串字面量会忽略掉转义序列，但是与转义序列情况中 <strong>“a”b”c”</strong> 一样的错误情况，原始字符串也会出现如下情况，不能在字符串中嵌入 <strong>)”</strong>，示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* str = <span class="hljs-string">R&quot;(Embedded )&quot;</span> characters)<span class="hljs-string">&quot;; // Error!</span><br></code></pre></td></tr></table></figure><p><strong>如果要需要嵌入 )”，则需要使用拓展的原始字符串字面量语法：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 格式：</span><br><span class="hljs-comment">// R&quot;d-char-sequence(r-char-sequence)d-char-sequence)-&quot;</span><br><span class="hljs-comment">// d-char-sequence 可以是任意小于 16 个字符的分割符序列</span><br><span class="hljs-comment">// r-char-sequence 是要输出的字符串代码</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* str = <span class="hljs-string">R&quot;-(Embedded)&quot; character)-&quot;</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* str = <span class="hljs-string">R&quot;10101(Embedded)&quot; character)10101&quot;</span>;<br><span class="hljs-comment">// Embedded)&quot; character 两行代码输出一致</span><br></code></pre></td></tr></table></figure><p><strong>在操作数据库查询字符串、正则表达式和文件路径时，原始字符串字面量可以令程序编写更加方便。第 19 章将会讨论正则表达式；</strong></p></blockquote></li></ul></blockquote><hr><h4 id="1-3C-std-string-类"><a href="#1-3C-std-string-类" class="headerlink" title="1.3C++ std::string 类"></a>1.3C++ std::string 类</h4><blockquote><p><strong>C++ 提供了一个得到极大改善的字符串概念，并作为标准库的一部分提供这个字符串的实现。在 C++ 中，std::string 是一个类，（实际上是 basic_string 模板类的一个实例），这个类支持 <cstring> 中提供的许多功能，还能自动管理内存分配。string 类在 std 名称空间的 <string> 头文件中定义，之前已经多次使用到 string 类了，下面深入学习：</strong></p></blockquote><h5 id="1-C-风格的字符串有什么问题"><a href="#1-C-风格的字符串有什么问题" class="headerlink" title="1.C 风格的字符串有什么问题"></a>1.C 风格的字符串有什么问题</h5><blockquote><p><strong>为理解 C++ string 类的必要性，需要考虑 C 风格字符串的优势和劣势：</strong></p><p><strong>优势：</strong></p><ul><li>很简单，<strong>底层使用基本的字符类型和数组结构</strong>，注意，C 数组是与指针强相关的，可以将 C 数组看作为指向数组第一个元素的指针，它具有数组指针的双重性；</li><li>轻量级，如果使用得当只会占用所需内存；</li><li>很低级，因此可以按操作原始内存方式轻松操作和赋值字符串；</li><li>能够很好地被 C 语言程序员理解——为什么还要学习新事物？</li></ul><p><strong>劣势：</strong></p><ul><li>为模拟一等字符串数据类型，需要付出很多努力；</li><li>使用难度大，而且很容易产生难以找到的内存 bug；</li><li>没有利用 C++ 的面向对象的特性；</li><li>要求程序员了解底层的表达方式；</li></ul><p>尤其注意，事实上，C 风格字符串的优点同样注定地导致了它的缺点；</p><p>上面的列表实际很精心被提出来的，从而能够让我们思考应该有更好的方式。如后面所述，C++ 的 string 类解决了字符串的所有问题，并且证明了 <strong>C 字符串相比一等数据类型的那些优势事实上是极其不恰当</strong>的。</p></blockquote><h5 id="2-使用-string-类"><a href="#2-使用-string-类" class="headerlink" title="2.使用 string 类"></a>2.使用 string 类</h5><blockquote><p>尽管 string 是一个类，但是几乎总可以将 string 当成内建类型使用，事实上，把 string 想象为简单类型更容易发挥它的特性。通过运算符重载的神奇作用，C++ 的 string 使用起来比 C 字符串简单容易很多。例如，给 string 重定义 + 运算符，以表示“字符串串联”。示例如下，将得到 1234：</p><p>+重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">&gt;<span class="hljs-function">string <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-string">&quot;12&quot;</span> <span class="hljs-string">&quot;21&quot;</span>)</span></span>;<br>&gt;<span class="hljs-comment">// string 的传入&quot;&quot;,中间如果是空白符，则连接在一起，例：(&quot;12&quot; &quot;21&quot;)会连接在一起相当于 &quot;1221&quot;</span><br>&gt;<span class="hljs-function">string <span class="hljs-title">B</span><span class="hljs-params">(<span class="hljs-string">&quot;34&quot;</span>)</span></span>;<br>&gt;string C;<br>&gt;C = A + B;<br></code></pre></td></tr></table></figure><p>+&#x3D;重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">&gt;<span class="hljs-function">string <span class="hljs-title">A</span><span class="hljs-params">(<span class="hljs-string">&quot;12&quot;</span>)</span></span>;<br>&gt;<span class="hljs-function">string <span class="hljs-title">B</span><span class="hljs-params">(<span class="hljs-string">&quot;34&quot;</span>)</span></span>;<br>&gt;A += B;<br></code></pre></td></tr></table></figure><p>此外，C 风格的字符串不能很好地执行 &#x3D;&#x3D; 比较：</p><p>假如有以下两个字符串：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++">&gt;<span class="hljs-type">char</span>* a = <span class="hljs-string">&quot;12&quot;</span>;<br>&gt;<span class="hljs-type">char</span> b[] = <span class="hljs-string">&quot;12&quot;</span>;<br><br>&gt;<span class="hljs-comment">// 按照如下方式比较总得到的结果是 false，因为它比较的是指针的值，而不是字符串的内容</span><br>&gt;<span class="hljs-keyword">if</span> (a == b)<br><br>&gt;<span class="hljs-comment">// 要比较 C 字符串要使用如下代码：</span><br>&gt;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(a, b) == <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>此外，C 字符串也无法通过 &lt;、 &gt;、 &lt;&#x3D;、 &gt;&#x3D; 的比较，因此仍需要通过 strcmp()  根据字符串字典的顺序返回 -1、0、1 的值进行判断，这样将会使得代码很笨拙而且很容易出错；</p><p>而在 C++ 中这些比较运算符，operate&#x3D;&#x3D;、opertae!&#x3D; 和 operate&lt; 等都被重载了，这些运算符可以操作真正的字符串字符，这样只需要通过运算符就可以完成基本操作，单独的字符可以通过运算符 operate[] 访问示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++">&gt;std::string myString = <span class="hljs-string">&quot;hello&quot;</span>;<br>&gt;myString += <span class="hljs-string">&quot;, there&quot;</span>;<br>&gt;std::string myOtherString = mystring;<br>&gt;<span class="hljs-keyword">if</span> (myString == myOtherString)<br>&gt;&#123;<br>myOtherString[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;H&#x27;</span>;<br>&gt;&#125;<br><br>&gt;std::cout &lt;&lt; myString &lt;&lt; std::endl;<br>&gt;std::cout &lt;&lt; myOtherString &lt;&lt; std::endl;<br><br>&gt;<span class="hljs-comment">// 以上代码输出：</span><br>&gt;hello, there <br>&gt;Hello, there<br></code></pre></td></tr></table></figure><p>注意，从上述代码中，我们还 能够看出，<strong>string 类能够自动处理内存需求被再次分配和调整大小，因此不会出现内存溢出的情况，这使得对字符串的处理变得更安全方便</strong>；所有的这些 string 类对象都创建为堆栈变量。尽管 string 类可定需要完成大量分配内存和调整大小的工作，但是 string 类的析构函数会在 string 对象离开作用域的时候清理内存；</p><p><strong>另外需要注意的是，运算符总能以预期的方式方式工作。</strong>例如， &#x3D; 运算符复制字符串（这种复制不是复制指针，因此改变被复制指针不会对复制者有任何影响），这是最有可能预期的操作。如果习惯使用基于数组的字符串，那么这种方式可能会带来全新的体验，也可能令你感到迷惑，不用担心，一旦学会信任 string 类总能做出正确的行为，那么代码就会变得很简单了；</p><p>为达到兼容目的，<strong>还可以应用 string 类中的 c_str() 方法返回 C 风格字符串的 const 字符指针。不过，一旦 string 执行任何内存重分配或 string 对象被销毁了，那么这个 cosnt 指针就永久失效了</strong>。因此，当使用这个操作时需要谨慎明白这种指针丢失风险；所以，应当在使用结果之前调用这个方法，以便它能够准确地反映 string 的当前内容，并且永远不要从函数中返回在基于堆栈的 string 上调用 c_str() 的结果。</p><p>此外，<em><em>还有一个 data() 方法，在 C++14 以及更早的版本中，始终与 c_str() 一样返回 const char</em> 。从 C++ 17 开始，在非 const 字符上调用时， data() 方法将返回 char</em>**；</p><p>除此以外，可以查看这本书的附录 B，查看可在 string 类对象上执行的所受对象操作；</p></blockquote><h5 id="3-std-string-字面量"><a href="#3-std-string-字面量" class="headerlink" title="3.std::string 字面量"></a>3.std::string 字面量</h5><blockquote><p><strong>源代码中的字符串字面量通常被解释为 const char</strong>*。<strong>使用用户定义的标准字面量 s 可以把字符串字面量解释为 std::string</strong>，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> string1 = <span class="hljs-string">&quot;Hello World&quot;</span>;<br><span class="hljs-keyword">auto</span> stirng2 = <span class="hljs-string">&quot;Hello World&quot;</span>s;<br><br><span class="hljs-comment">// 用户定义的标准字面量 s 需要 using namespace std::string_literals;</span><br><span class="hljs-comment">// 或者需要 using namespace std;</span><br></code></pre></td></tr></table></figure></blockquote><h5 id="4-高级数值转换"><a href="#4-高级数值转换" class="headerlink" title="4.高级数值转换"></a>4.高级数值转换</h5><blockquote><p><strong>std 名称空间包含很多辅助函数，以便完成数值和字符串之间的转换。下面的函数可用于将数值转换为字符串。所有的这些函数都负责内存分配，它们会创建一个新的 string 对象并返回。</strong></p><ul><li><strong>string to_string(int val);</strong></li><li><strong>string to_string(unsigned val);</strong></li><li><strong>stirng to_string(long val);</strong></li><li><strong>string to_string(unsigned long val);</strong></li><li><strong>string to_string(long long val);</strong></li><li><strong>string to_string(unsigned long long val);</strong></li><li><strong>string to_string(float val);</strong></li><li><strong>string to_string(double val);</strong></li><li><strong>string to_string(long double val);</strong></li></ul><p>这些函数的使用简单直观，例如，下面示例中将 long double 值转化为字符串:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">long</span> <span class="hljs-type">double</span> d = <span class="hljs-number">3.14L</span>;<br>string s = <span class="hljs-built_in">to_string</span>(d);<br></code></pre></td></tr></table></figure><p>下面同样是定义在 std 名称空间中的函数，其中，<strong>str 表示将要进行转换的字符串；idx 是一个指针，这个指针将接收第一个未完成转换的字符的索引；base 表示转换过程中使用的进制</strong>。idx 可以是空指针，如果是空指针则被忽略。</p><p>如果不能执行任何转换，这些函数将抛出 invalid_argument 异常；</p><p>如果转换的值超出返回类型的范围，则抛出 out_of_range 异常；</p><ul><li><p><em><em>int stoi(const string&amp; str, size_t</em> idx &#x3D; 0, int base &#x3D; 10);</em>*</p></li><li><p><em><em>long stoi(const string&amp; str, size_t</em> idx &#x3D; 0, int base &#x3D; 10);</em>*</p></li><li><p><em><em>unsigned long stol(const string&amp; str, size_t</em> idx &#x3D; 0, int base &#x3D; 0);</em>*</p></li><li><p><em><em>long long stoll(const string&amp; str, size_t</em> idx &#x3D; 0, int base &#x3D; 0);</em>*</p></li><li><p><em><em>unsigned long long stoull(const string&amp; str, size_t</em> idx &#x3D; 0, int base &#x3D; 0);</em>*</p></li><li><p><em><em>float stof(const string&amp; str, size_t</em> idx &#x3D; 0);</em>*</p></li><li><p><em><em>double stod(const string&amp; str, size_t</em> idx &#x3D; 0);</em>*</p></li><li><p><em><em>long double stold(const string&amp; str, size_t</em> idx &#x3D; 0);</em>*</p><p><strong>上面的使用时要加 std:，下面的不需要。</strong></p></li><li><p><em><em>int strtoi(const string&amp; str, size_t</em> idx &#x3D; 0, int base &#x3D; 10);</em>*</p></li><li><p><em><em>long strtoi(const string&amp; str, size_t</em> idx &#x3D; 0, int base &#x3D; 10);</em>*</p></li><li><p><em><em>unsigned long strtol(const string&amp; str, size_t</em> idx &#x3D; 0, int base &#x3D; 0);</em>*</p></li><li><p><em><em>long long strtoll(const string&amp; str, size_t</em> idx &#x3D; 0, int base &#x3D; 0);</em>*</p></li><li><p><em><em>unsigned long long strtoull(const string&amp; str, size_t</em> idx &#x3D; 0, int base &#x3D; 0);</em>*</p></li><li><p><em><em>float strtof(const string&amp; str, size_t</em> idx &#x3D; 0);</em>*</p></li><li><p><em><em>double strtod(const string&amp; str, size_t</em> idx &#x3D; 0);</em>*</p></li><li><p><em><em>long double strtold(const string&amp; str, size_t</em> idx &#x3D; 0);</em>*</p></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> std::string toParse = <span class="hljs-string">&quot;123USB&quot;</span>;<br><span class="hljs-type">size_t</span> index = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> value = std::<span class="hljs-built_in">stoi</span>(toParse, &amp;index);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Parsed value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;First non-parsed character: &quot;</span> &lt;&lt; <span class="hljs-string">&quot;&#x27;&#x27;&quot;</span> &lt;&lt; toParse[index] &lt;&lt; <span class="hljs-string">&quot;&#x27;&quot;</span> &lt;&lt;std::endl;<br></code></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">Parsed value: <span class="hljs-number">123</span><br>First non-parsed character: <span class="hljs-string">&#x27;U&#x27;</span><br></code></pre></td></tr></table></figure></blockquote><h5 id="5-低级数值转换"><a href="#5-低级数值转换" class="headerlink" title="5.低级数值转换"></a>5.低级数值转换</h5><blockquote><p>使用思路就是：用 s.data() 获取起始指针，利用 s.data() + s.size() 或者 s.data() + s.strlen() 获取终止指针，然后都是将值传递给相应需要的需要得到的变量中；</p></blockquote><blockquote><p><strong>C++17 也提供了许多低级数值转换函数，这些都在 <charconv> 头文件中定义。这些函数不执行内存分配，而使用由调用者分配的缓存区。另外，对它们进行优化，以实现高性能，并独立于本地化(有关本地化的内容，详见第 19 章)。最终结果是，与其他更高级的数值转换函数相比，这些函数的运行速度要快几个数量级。如果性能要求高，需要进行独立于本地化的转换，则应当使用这些函数；例如，在数值数据与人类可读格式(如 JSON、XML 等)之间进行序列化&#x2F;反序列化；</strong></p><p>要将<strong>整数转化为字符</strong>使用下面一组函数，这里，<strong>IntegerT</strong> 可以是<strong>任意有符号或无符号的整数类型或字符类型</strong>，<strong>结果的类型</strong>是 <strong>to_chars_result</strong> ：</p><p><em><em>to_chars_result to_chars(char</em> first, char</em> last,IntegerT value, int base &#x3D; 10);**</p><p><strong>to_chars_result 类型定义如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">to_chars_result</span><br>&#123;<br><span class="hljs-type">char</span>* ptr;<br>errc ec;<br>&#125;<br><br><span class="hljs-comment">// 如果转换成功，那么 ptr 成员等于写入字符的下一位置(one-past-the-end)的指针；</span><br><span class="hljs-comment">// 如果转换失败，即： ec == errc::value_too_large，则 ptr 成员等于 last;</span><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;charconv&gt;</span></span><br><br><span class="hljs-keyword">using</span> std::cout;<br><span class="hljs-keyword">using</span> std::endl;<br><span class="hljs-keyword">using</span> std::string;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-function">string <span class="hljs-title">out</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27; &#x27;</span>)</span></span>;<br> <span class="hljs-keyword">auto</span> result = std::<span class="hljs-built_in">to_chars</span>(out.<span class="hljs-built_in">data</span>(), out.<span class="hljs-built_in">data</span>() + out.<span class="hljs-built_in">size</span>(), <span class="hljs-number">12345</span>);<br> <span class="hljs-keyword">if</span> (result.ec == std::<span class="hljs-built_in">errc</span>()) <br> &#123;<br>     cout &lt;&lt; <span class="hljs-string">&quot;Converted value: &quot;</span> &lt;&lt; out &lt;&lt; endl;<br> &#125;<br> <span class="hljs-keyword">else</span> &#123;<br>     std::cerr &lt;&lt; <span class="hljs-string">&quot;Conversion error&quot;</span> &lt;&lt; std::endl;<br> &#125;<br><br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 使用结构化绑定可以将其写为：</span><br><span class="hljs-function">std::string <span class="hljs-title">out</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-string">&#x27;&#x27;);</span></span></span><br><span class="hljs-string"><span class="hljs-params"><span class="hljs-function">auto [ptr, ec] = std::to_chars(out.data(), out.data() + out.size(), 12345);</span></span></span><br><span class="hljs-string"><span class="hljs-params"><span class="hljs-function">if (result.ec == std::cerr()) &#123;...&#125;</span></span></span><br></code></pre></td></tr></table></figure><p><strong>类似的，以下为浮点型的转换函数：</strong></p><p><em><em>to_chars_result to_chars(char</em> first, char</em> last, FloatT value);**</p><p><em><em>to_chars_result to_chars(char</em> first, char</em> last, FloatT value, chars_format fomat);**</p><p><em><em>to_chars_result to_chars(char</em> first, char</em> last, FloatT value, chars_format fomat, int precision);**</p><p>这里，FloatT 可以是 float、double 或 long double。可使用 chars_format 标志的组合来指定格式：</p><p><strong>chars_format 类型定义如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">chars_format</span><br>&#123;<br>scientific;<span class="hljs-comment">// Style: (-)d.ddde±dd</span><br> fixed;<span class="hljs-comment">// Style: (-)ddd.dd</span><br> hex;<span class="hljs-comment">// Style: (-)h.hhhp±d (Note: no 0x)</span><br> general = fixed | scientific  <span class="hljs-comment">// See the following staff</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>默认格式是 chars_format::general, 这将导致 to_chars()将浮点值转换为 (-)ddd.ddd 形式的十进制表示形式，或(.)d.ddde土dd 形式的十进制指数表示形式，得到最短的表示形式，小数点前至少有一位数字(如果存在)。如果指定了格式，但未指定精度，将为给定格式自动确定最简短的表示形式，最大精度为 6 个数字</strong>；</p><p><strong>对于相反的转换，即将字符序列转换为数值，可使用下面的一组函数：</strong></p><p><em><em>from_chars_result from_chars(const char</em> first, const char</em> last, IntegerT&amp; value, int base &#x3D; 10);**</p><p><em><em>from_chars_result from_chars(const char</em> first, const char</em> last. FloatT&amp; value, chars_format format &#x3D; chars_format::general);**</p><p><strong>from_chars_result 类型定义：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">from_chars_result</span> <br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* ptr;<br>errc ec;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>结果类型的 ptr 成员是指向未转换的第一个字符的指针；如果所有字符都成功转换，则它等于 last。如果所有字符都未转换，则 ptr 等于 first, 错误代码的值将为 errc::invalid_argument。如果解析后的值过大，无法由给定类型表示，则错误代码的值将是 errc::result_out_range。注意，from_chars()不会忽略任何前导空白。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 手动移动指针到第一个非空白字符</span><br><span class="hljs-keyword">while</span> (std::<span class="hljs-built_in">isspace</span>(*str)) <br>&#123;<br> ++str;<br>&#125;<br><span class="hljs-comment">// 使用这种方法来移到要使用的数字前</span><br><br><span class="hljs-comment">// 示例如何使用：</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;charconv&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* str = <span class="hljs-string">&quot;123.456&quot;</span>;<br> <span class="hljs-type">double</span> value;<br><br> <span class="hljs-comment">// 使用 std::from_chars 进行字符串到浮点数的转换</span><br> <span class="hljs-keyword">auto</span> result = std::<span class="hljs-built_in">from_chars</span>(str, str + std::<span class="hljs-built_in">strlen</span>(str), value);<br><br> <span class="hljs-keyword">if</span> (result.ec == std::<span class="hljs-built_in">errc</span>()) <br> &#123;<br>     <span class="hljs-comment">// 转换成功</span><br>     std::cout &lt;&lt; <span class="hljs-string">&quot;Converted value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;<br> &#125; <br> <span class="hljs-keyword">else</span> <br> &#123;<br>     <span class="hljs-comment">// 转换失败</span><br>     std::cerr &lt;&lt; <span class="hljs-string">&quot;Conversion error&quot;</span> &lt;&lt; std::endl;<br> &#125;<br><br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><hr><h4 id="1-4std-string-view-类"><a href="#1-4std-string-view-类" class="headerlink" title="1.4std::string_view 类"></a>1.4std::string_view 类</h4><blockquote><p>在 C++17 之前，为了接收只读字符串而选择怎样的形参类型始终是个问题：</p><ul><li><p>如果选择 <code>const char*</code>，那么用户在使用 std::string 的话，就必须调用其上的 c_str() 或 data() 来获取 const char *，更糟糕的是，函数将失去 std::string 的良好面向对象性和良好的辅助方法。</p></li><li><p>我们这样想的话为什么不使用 <code>const string&amp;</code> ？这种情况，需要始终使用 std::string。比如，如果传递一个字符串字面量，编译器将不加通告地创建一个临时字符串对象（其中包含字符串字面量的副本），并将该对象传递给函数，因此会增加一些开销。</p></li><li><p>在 C++ 中，<strong>字符串字面量（如 <code>&quot;hello&quot;</code>）是以字符数组的形式存在的</strong>，<strong>类型为 <code>const char[N]</code><strong>，其中 N 是字符串的长度。当将字符串字面量传递给接受 <code>const std::string&amp;</code> 的函数时，由于函数参数是引用，编译器会尝试将字符串字面量</strong>隐式地转换</strong>为 <code>std::string</code> 对象。</p><p><strong>为了进行这种转换，<code>std::string</code> 类型有一个接受 <code>const char*</code> 的构造函数。因此，编译器会创建一个临时的 <code>std::string</code> 对象，将字符串字面量的内容复制到该对象中，然后将这个临时对象传递给函数。</strong></p><p>这种隐式的转换可能会引入一些性能开销，因为它涉及到内存分配和复制操作。如果函数只是需要读取字符串而不修改它，使用 <code>const std::string&amp;</code> 可能会显得不够高效。</p></li><li><p>因此，人们有时会为此编写函数的 const char* 和 const string&amp; 两个函数接收版本，这显然不够优雅。</p></li><li><p><strong>在 C++17 中，通过引入 std::string_view 类解决了所有这些问题，std::string_view 类 std::basic_string_view类模板的实例化，在 <string_view> 头文件中定义。string_view 基本上就是 const string&amp; 的简单替代品，但不会产生开销。它从不复制字符串，string_view 支持与 std::string 类似的接口。一个例外是缺少 c_str(), 但 data() 是可用的。另外，string_view 确实添加了 remove_prefix(size_t) 和 remove_suffix(size_t) 方法；前者将起始指针前移给定的偏移量来收缩字符串，后者则将结尾指针倒退给定的偏移量来收缩字符串。</strong></p></li><li><p><strong>具体操作上就是用 std::string_view() 构造函数 替代 const std::string&amp; 样式的传参方式，来减小开支，因为<code>std::string_view()</code> 构造函数并不会引起额外的动态内存分配或拷贝，因为它只是一个视图，不拥有字符串的所有权。这个构造函数创建了一个空的 <code>std::string_view</code> 对象，但并不分配内存或复制字符串。</strong></p></li></ul><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::string_view myString = <span class="hljs-string">&quot;Hello, World!&quot;</span>;<br><span class="hljs-comment">// 移除末尾的前7个字符</span><br>myString.<span class="hljs-built_in">remove_suffix</span>(<span class="hljs-number">7</span>);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;After removing suffix: &quot;</span> &lt;&lt; myString &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure></blockquote><ul><li>注意，<strong>无法连接一个 string 和一个 string_view 类型</strong>，下面的代码将无法编译：</li></ul><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">string str = <span class="hljs-string">&quot;Hello&quot;</span>; <br>string_view sv = <span class="hljs-string">&quot; world&quot;</span>; <br><span class="hljs-keyword">auto</span> result = str + sv;<br><br><span class="hljs-comment">// 最后一行改为：</span><br><span class="hljs-keyword">auto</span> result = str + sv.<span class="hljs-built_in">data</span>();<br></code></pre></td></tr></table></figure></blockquote><ul><li>如果知道如何使用 std::string, 那么使用 string_view 将变得十分简单，如下面的代码片段所示。extractExtension() 函数提取给定文件名的扩展名并返回：</li></ul><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">string_view <span class="hljs-title">extractExtension</span><span class="hljs-params">(string_view fileName)</span></span><br><span class="hljs-function"></span>&#123;<br> <span class="hljs-keyword">return</span> fileName.<span class="hljs-built_in">substr</span>(fileName.<span class="hljs-built_in">rfind</span>(<span class="hljs-string">&#x27;.&#x27;</span>));<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><ul><li>该函数可用于所有不同类型的字符串：</li></ul><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">string fileName = <span class="hljs-string">R&quot;(c:\temp\my file.ext)&quot;</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;C++ string: &quot;</span> &lt;&lt; <span class="hljs-built_in">extractExtension</span>(fileName) &lt;&lt; endl;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* cString = <span class="hljs-string">R&quot;(c:\temp\my file.ext)&quot;</span>;<br>cout « <span class="hljs-string">&quot;C string: &quot;</span> &lt;&lt; <span class="hljs-built_in">extractExtension</span>(cString) &lt;&lt; endl;<br>cout « <span class="hljs-string">&quot;Literal: &quot;</span> « <span class="hljs-built_in">extractExtension</span>(<span class="hljs-string">R&quot;(c:\temp\my file.ext)&quot;</span>) &lt;&lt; endl;<br></code></pre></td></tr></table></figure></blockquote><ul><li><strong>注意，通常按值传递 string_views, 因为它们的复制成本极低</strong>。</li><li><strong>复制成本极低原因：它们只包含指向字符串的指针以及字符串的长度。</strong>  </li><li>在对 extractExtension() 的所有这些调用中，并非进行单次复制。<strong>extractExtension() 函数的 fileName 参数只是指针和长度</strong>，该函数的返回类型也是如此。这都十分高效。</li></ul><p><strong>string_view 构造函数的使用：</strong></p><ul><li>它可以接收任意原始缓存区和长度，这可用于从字符串缓冲区(并非以 NUL 终止) 构建 string_view。如果确实有一个以 NUL 终止的字符串缓冲区，但是如果已经知道了字符串长度，构造函数不必再统计字符串数目</li></ul><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">size_t</span> length = <span class="hljs-number">3</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* cString = <span class="hljs-string">R&quot;(c:\temp\my file.ext)&quot;</span>;<br>cout &lt;&lt; std::<span class="hljs-built_in">string_view</span>(cString, length) &lt;&lt; endl;<br>cout &lt;&lt; std::<span class="hljs-built_in">string</span>(cString, length) &lt;&lt; endl;<br><br><span class="hljs-comment">// 使用 string_view 更高效</span><br></code></pre></td></tr></table></figure></blockquote><ul><li>总结起来就是，string_view 比 string 强的地方就是，它不用再进行隐式的 string 类型构造，因为 C 风格字符串和 string 字面量 会进行隐式转换，复制构造，这里会有开销差距。</li><li>我上面说了，既然没有隐式构造，那么我们的返回值是 string_view 那么就不能被当作 string 参量看待也就是我接下来举出的例子说明的事情：</li></ul><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">handleExtension</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; extension)</span></span>&#123;...&#125;<br><br><span class="hljs-comment">// 没有隐式转换存在，不能使用以下方式调用函数：</span><br><span class="hljs-built_in">handleExtension</span>(<span class="hljs-built_in">extractExtension</span>(<span class="hljs-string">&quot;my file.ext&quot;</span>));<br><br><span class="hljs-comment">// 可选用以下方法：</span><br><span class="hljs-comment">// 1.显式转换explitcit ctor</span><br><span class="hljs-built_in">handleExtension</span>(<span class="hljs-built_in">string</span>(<span class="hljs-built_in">extractExtension</span>(<span class="hljs-string">&quot;my file.ext&quot;</span>)));<br><span class="hljs-comment">// 2.data() 方法</span><br><span class="hljs-built_in">handleExtension</span>(<span class="hljs-built_in">extractExtension</span>(<span class="hljs-string">&quot;my file.ext&quot;</span>).<span class="hljs-built_in">data</span>());<br><br><span class="hljs-comment">/* 注意，即使原本的传入参数应该为 const string&amp; 类型，但是 C 风格的字符串会首先隐式地调用 string 构造函数，然后再调用 const string&amp; 构造函数，以完成代码 */</span><br><span class="hljs-built_in">handleExtension</span>(C-String);<br></code></pre></td></tr></table></figure></blockquote><p><em><em>注意：在每当使用只读字符串作为参数时，可以使用 std::string_view 代替 const char</em> 或 const string&amp;。</em>*</p><p><strong>std::string_view 字面量：</strong></p><ul><li><p>可使用标准的用户定义的字面量 sv，将字符串字面量解释为 std::string_view，例如：</p><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> sv = <span class="hljs-string">&quot;My string_view&quot;</span>sv;<br></code></pre></td></tr></table></figure></blockquote></li><li><p>标准的用户定义的字面量 sv 需要 using namespace std::string_view_literals; 或 using namespace std;</p></li></ul></blockquote><p><strong>总结：</strong></p><blockquote><p>自动调用隐式构造函数的情况：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span>* ---&gt; string_view可行<br>string ---&gt; string_view可行<br>string_view ---&gt; string_view可行<br><br><span class="hljs-type">char</span>* ---&gt; string可行<br>string ---&gt; string可行<br>string_view ---&gt; string不可行<br><br>...---&gt; <span class="hljs-type">char</span>*都不可行<br><span class="hljs-comment">// 以上的左侧是实际参数，右边是函数期待的参数，可行代表可以运行，不可行代表不接受</span><br></code></pre></td></tr></table></figure><p>字面量在不告知的情况下，是 const char* 类型或者说是 const char[] 类型；</p></blockquote><hr><h4 id="1-5非标准字符串"><a href="#1-5非标准字符串" class="headerlink" title="1.5非标准字符串"></a>1.5非标准字符串</h4><blockquote><p><strong>许多 C++程序员都不使用 C++风格的字符串，这有几个原因。</strong>一些程序员只是不知道有 string 类型，因为它并不总是 C++ 规范的一部分。其他程序员发现，C++ string 没有提供他们需要的行为，所以开发了自己的字符串类型。也许最常见的原因是，开发框架和操作系统有自己的表达字符串的方式，例如 Micros。仕 MFC 中的CString 类。它常用于向后兼容或解决遗留的问题。在 C++ 中启动新项目时，提前确定团队如何表示字符串是非常重要的。务必注意以下几点：</p><ol><li>不应当选取 C 风格的字符串表示。</li><li>可对自己所用框架中的可用字符串进行标准化，如 MFC、QT 内置的字符串功能。</li><li>如果为字符串使用 std::string，应当使用 std::string_view 将只读字符串作为参数传递给函数；否则，看一下框架是否支持类似于它的类。</li></ol></blockquote><hr><h3 id="2-2本章小结"><a href="#2-2本章小结" class="headerlink" title="2.2本章小结"></a>2.2本章小结</h3><blockquote><p>一句话，用 string，传只读字符串用 string_view。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 复习教程第五章（面向对象设计）</title>
    <link href="/2024/03/14/C++%20%E5%A4%8D%E4%B9%A0%E6%95%99%E7%A8%8B%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%EF%BC%89/"/>
    <url>/2024/03/14/C++%20%E5%A4%8D%E4%B9%A0%E6%95%99%E7%A8%8B%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="第5章-——-面向对象设计"><a href="#第5章-——-面向对象设计" class="headerlink" title="第5章 —— 面向对象设计"></a>第5章 —— 面向对象设计</h2><blockquote><p>本章讨论对象之间的不同关系，包括创建面向对象程序时可能遇到的陷阱，还将学习抽象原则如何与对象联系起来；</p><p>思考过程式编程或面向对象编程时，要记住的重要一点是：面向对象编程只是以不同的方式看待程序；</p></blockquote><hr><h3 id="5-1过程化的思考方式"><a href="#5-1过程化的思考方式" class="headerlink" title="5.1过程化的思考方式"></a>5.1过程化的思考方式</h3><blockquote><p>过程语言(例如 C) 将代码分割为小块，每个小块(理论上)完成单一的任务。如果在 C 中没有过程，所有代码都会集中在 main() 中。代码将会难以阅读，同事会恼火，这还是最轻的；</p><p>过程式编程思想，在大型应用程序中很难满足线性序列事件发生的条件，此外，过程思想对数据的表示没有任何说明。</p></blockquote><hr><h3 id="5-2面向对象思想"><a href="#5-2面向对象思想" class="headerlink" title="5.2面向对象思想"></a>5.2面向对象思想</h3><blockquote><p>与基于“程序做什么”的面向过程的编程不同，面向对象思想提出了另一种看待问题的方法：“模拟哪些实际的对象？”</p></blockquote><hr><h4 id="2-1类"><a href="#2-1类" class="headerlink" title="2.1类"></a>2.1类</h4><blockquote><p>类，将对象及其定义区分开来；</p><p>类，用来封装定义对象分类的信息；</p><p>类，通过特征将类实例化；</p><p>类与对象 &lt;–类比–&gt; 类型与对象</p></blockquote><hr><h4 id="2-2组件"><a href="#2-2组件" class="headerlink" title="2.2组件"></a>2.2组件</h4><blockquote><p>本质上，组件与类相似，但是组件更小，更具体；</p></blockquote><hr><h4 id="2-3属性"><a href="#2-3属性" class="headerlink" title="2.3属性"></a>2.3属性</h4><blockquote><p>属性，将一个对象与其他对象区分开来；</p><p>类的属性，由所有的类成员共享，而类的所有对象都有对象属性，但具有自身特定的值；</p></blockquote><hr><h4 id="2-4行为"><a href="#2-4行为" class="headerlink" title="2.4行为"></a>2.4行为</h4><blockquote><p>行为，回答 “对象做什么？” 和 “能对对象作什么？”；</p><p>因此，许多功能性的代码从过程转移到类，通过建立某些行为的对象并定义对象的交互方式，OPP 以更丰富的机制将代码和代码的操作的数据联系起来。类的行为由类的方法实现；</p></blockquote><hr><h4 id="2-5综合考虑"><a href="#2-5综合考虑" class="headerlink" title="2.5综合考虑"></a>2.5综合考虑</h4><blockquote><p><img src="https://bu.dusays.com/2024/03/15/65f4463fdaa72.png" alt="image-20240209150140169"></p><p>不扯淡，学会 UML 就明白了；</p></blockquote><hr><h3 id="5-3生活在对象世界里"><a href="#5-3生活在对象世界里" class="headerlink" title="5.3生活在对象世界里"></a>5.3生活在对象世界里</h3><blockquote><p>彻底采用 OPP 范式 和 仅仅使用对象代表数据和功能的良好封装都不是佳境；</p><p>理想方法往往介于这两者之间；</p></blockquote><hr><h4 id="3-1过度使用对象"><a href="#3-1过度使用对象" class="headerlink" title="3.1过度使用对象"></a>3.1过度使用对象</h4><blockquote><p>事无巨细地都转化为对象，这是要警惕的，因为完全没必要；</p></blockquote><hr><h4 id="3-2过于通用的对象"><a href="#3-2过于通用的对象" class="headerlink" title="3.2过于通用的对象"></a>3.2过于通用的对象</h4><blockquote><p>能包含太多种类对象的类，也是完全没有必要的，因为它自身几乎不含有任何信息，如 data、Media等；</p></blockquote><hr><h3 id="5-4对象之间的关系"><a href="#5-4对象之间的关系" class="headerlink" title="5.4对象之间的关系"></a>5.4对象之间的关系</h3><blockquote><p>不同类具有共同的特征，至少看起来彼此有联系；</p><p>面向对象的语言提供了许多机制来处理对象之间的这种关系；</p><p>其中，主要有两种关系：“有一个(has a)” 和 “是一个(is a)”；</p></blockquote><hr><h4 id="4-1“有一个”关系"><a href="#4-1“有一个”关系" class="headerlink" title="4.1“有一个”关系"></a>4.1“有一个”关系</h4><blockquote><p>“有一个”关系或聚合关系的模式是：A有一个B，或者A 包含一个B。在此类关系种，可以认为某个对象是另一个对象的一部分。</p></blockquote><hr><h4 id="4-2“是一个”关系-继承"><a href="#4-2“是一个”关系-继承" class="headerlink" title="4.2“是一个”关系(继承)"></a>4.2“是一个”关系(继承)</h4><blockquote><p>“是一个”关系是面向对象编程中非常常见的的基本概念，因此有许多名称，包括派生(deriving)、子类(subclass)、扩展(extending)和继承(inheriting)。类模拟了现实世界包含具有属性和行为的对象这一事实，继承模拟了这些对象通常以层次方式来组织这一事实。“是一个”正说明了这种层次关系。</p><p>基本上，继承的模式是：A是一个B，或者A实际上与B非常相似——这可能比较棘手。</p><p>A是B(的一种)，但是反过来B却不都是A；</p><p>当类之间具有“是一个”关系时，目标之一就是将通用功能放入基类(base class)，其他类可扩展基类。如果所有子类都有相似或完全相同的代码，就应该考虑将一些代码或全部代码放入基类。这样，可以在一个地方完成所需的改动，将来的子类可“免费”获取这些共享的功能。</p><ol><li><p><strong>继承技术</strong></p><p>前面的示例非正式地讲述了继承中使用的一些技术。当生成子类时，程序员有多种方法将某个类与其父类(parent class)、基类或者超类(superclass)区分开来。可使用多种方法生成子类，生成子类实际上就是完成语句 A is a B that…的过程。</p><p><strong>添加功能：</strong></p><p><strong>派生类可在基类的基础上添加功能。</strong></p><p><strong>替换功能：</strong></p><p><strong>派生类可完全替代或重写父类的行为。当然，如果对基类的所有功能都进行替换，就可能意味着采用继承的方式根本就不正确，除非基类是一个抽象基类。抽象基类会强制每个子类实现未在抽象基类中实现的所有方法。无法为抽象基类创建实例，第 10 章将介绍抽象类。此处，略。</strong></p><p><strong>添加属性：</strong></p><p><strong>除了从基类继承属性以外，派生类还可添加新属性。</strong></p><p><strong>替换属性：</strong></p><p><strong>与重写方法类似，C++ 提供了重写属性的方法。然而，这样做通常是不合适的，因为这会隐藏基类的属性，例如，基类可谓具有特定名称的属性指定一个值，而派生类可给该属性指定另一个值。有关“隐藏”的内容，详见第 9 章。不要把替换属性的概念与子类具有不同属性值的概念混淆。</strong></p></li><li><p><strong>多态性和代码重用</strong></p><p>多态性(Polymorphism)指具有标准属性和方法的对象可互换使用。类定义就像对象和与之交互的代码之间的契约。根据定义，一个对象必须支持其类的属性和行为；</p><p>这个概念可以推广到基类。即，当 A 是 B 时，那么 A 对象必然支持 B 类的属性和行为；</p><p>多态性是面向对象编程的两点，因为多态性真正利用了继承所提供的功能。即，当 A 是 B 时，那么当遍历 B 执行某个特定操作，即使因为归属于不同的 A 但是都是 B，所以这一特定操作即使被重写，依旧会执行相应的特定改写后动作。这就是亮点——代码只告诉让 B 执行某个特定操作，但是不需要知道是哪种 A，即可根据自己的特定改写后代码执行此操作，不必告诉需要如何执行此操作；</p><p>除多态性外，使用继承还有一个原因，通常是为了复用，为了避免做重复的工作，而使得两个独立的类之间产生关联；</p></li></ol></blockquote><hr><h4 id="4-3“有一个”-与-“是一个”-的区别"><a href="#4-3“有一个”-与-“是一个”-的区别" class="headerlink" title="4.3“有一个” 与 “是一个” 的区别"></a>4.3“有一个” 与 “是一个” 的区别</h4><blockquote><p>在现实中，“是一个” 与 “有一个” 两者是很好区分的，但是在代码中，有时候却显得不是那么明显；</p><ul><li><p>比如，在考虑一个标准哈希表时，每个键(数字)对应有一个值(量)，且当为一个已有值的键添加第二个值的时候，第一个值就会消失。</p></li><li><p>因此，不难想象，如果创建一个类似哈希表但允许一个键有多个值的数据结构的用法(比如，保险公司一个家庭可能有多个名称对应同一个 ID)。这种数据结构非常类似于哈希表，因此可用某种方式使用哈希表功能。哈希表的键只能由一个值，但是这个值可以是任意类型的。除字符串外，这个值还可以是一个包含多键值的集合(例如，数组或列表)。当像已有 ID 添加新成员时，可将其添加入集合中。(示例见课本 p88)</p></li><li><p>使用集合而不是字符串有些繁琐，需要大量重复代码。因此，最好再一个单独的类中封装多值功能，可将这个类叫做 MultiHush 。MultiHush 类的运行与 Hashtable 类似，只是背后将每个值存储为字符串的集合，而不是单个字符串。很明显，MultiHush 与 Hashtable 有某种联系，因为它依然可以使用哈希表存储数据。不明显的是，这是“是一个” 关系 还是 “有一个” 关系？</p></li><li><p>先考虑 “是一个” 关系，假定 MultiHush 是 Hashtable 的派生类，它必须重写在表中添加任何项的行为，从而既可创建集合添加新元素又可检索已有集合并添加新元素。此外，还必须重写检索值的行为。例如，可将给定键的所有值集中到一个字符串中。这好像是一种相当合理的设计。即使<strong>派生类重写了基类的所有方法</strong>，也<strong>仍可在派生类中使用原始行为</strong>，从而使用基类的行为。  </p></li><li><p>再考虑 “有一个” 关系，MultiHush 属于自己的类，但是包含了 Hushtable 对象，这个类的接口可能与 Hashtable 非常相似，但并不需要相同。在幕后，当用户向 MultiHash 添加项时，会将这个项封装到一个集合并送入 Hashtable 对象。</p></li></ul><p><img src="https://bu.dusays.com/2024/03/15/65f44642ddfdd.png" alt="image-20240218121232851"></p><ul><li>那么，哪个方案是正确的？没有明确的答案，笔者的一个朋友认为这是“有一个”关系，他编写了一个MultiHash 类供产品使用。主要原因是允许修改公开的接口，而不必考虑维护哈希表的功能。例如，将图 5.7 中的 get 方法改成 getAlL 以清楚表明将获取 MultiHash 中某个特定键的所有值。此外，在“有一个”关系中，不需要担心哈希表的功能会渗透。例如，如果 Hashtable 类提供了获取值的总数的方法，只 MultiHash 不重写这个方法，就可以用这个方法报告集合的项数。</li></ul><p><img src="https://bu.dusays.com/2024/03/15/65f446450da7a.png" alt="image-20240218121948463"></p><p><img src="https://bu.dusays.com/2024/03/15/65f44646d5ac8.png" alt="image-20240218122011286"></p><ul><li>反对“是一个”关系的理由在这种情况下非常有力。LSP（Liskov Substitution Principle, 里氏替换原则）可帮助从“是一个”和“有一个”关系中选择。这个原则指出，你应当能在不改变行为的情况下，用派生类替代基类。将这个原则应用于本例，则表明应当是“有一个”关系，因为你无法在以前使用 Hashtable 的地方使用MultiHash 否则，行为就会改变。例如，Hashtable 的 insert。方法会删除映射中同一个键的旧值，而 MultiHash 不会删除此类值。</li><li>因此，推荐使用 “有一个” 关系，而不是 “是一个” 关系。</li><li>注意，这里使用 Hashtable 和 MultiHash 说明了“有一个”和“是一个”关系的不同之处。在代码中，建议使用标准 Hashtable 类，而不是自己写 一个。C++ 标准库中提供了 unordered m 类，用来代替 Hashtable, 此外还提供了 unordered_multimap 类，用来代替 MultiHash 类。第 17 章将讨论这两个标准类。</li></ul></blockquote><hr><h4 id="4-4not-a-关系"><a href="#4-4not-a-关系" class="headerlink" title="4.4not-a 关系"></a>4.4not-a 关系</h4><blockquote><p>当考虑类之间的关系时，应该考虑类之间是否真的存在关系。不要把对面向对象设计的热情全部转换为许多不必要的类&#x2F;子类关系。  </p><p>当实际事物之间存在明显关系，而代码中没有实际关系时，问题就出现了。0PP（面向对象）层次结构需要模拟功能关系，而不是人为制造关系。图 5-8 显示的关系作为概念集或层次结构是有意义的，但在代码中并不能代表有意义的关系。  </p><p><img src="https://bu.dusays.com/2024/03/15/65f44648b4a1e.png" alt="屏幕截图 2024-02-18 124133">避免不必要继承的最好方法是首先给出大概的设计。为每个类和派生类写出计划设置的属性和行为。如果发现某个类没有自己特定的属性或方法，或者某个类的所有属性和方法都被派生类重写，只要这个类不是前面提到的抽象基类，就应该重新考虑设计。</p></blockquote><hr><h4 id="4-5层次结构"><a href="#4-5层次结构" class="headerlink" title="4.5层次结构"></a>4.5层次结构</h4><blockquote><p>类根据层次使得各个派生共性更系统化，另外强调，根据不同划分方式，会得到不同的派生方式，得到不同的层次结构。因此，要点——在代码中，需要平衡现实关系和共享功能关系。</p><p>即使在现实中的两种事物紧密联系，但是在代码中也可能没有任何关系，因为它们没有共享功能。</p><p>优秀的面向对象层次结构优点：</p><ul><li>使用类之间存在有意义的功能关系；</li><li>将共同的功能放入基类，从而支持代码重用；</li><li>避免子类过多地重写父类的功能，除非父类是一个抽象类；</li></ul></blockquote><hr><h4 id="4-6多重继承"><a href="#4-6多重继承" class="headerlink" title="4.6多重继承"></a>4.6多重继承</h4><blockquote><p>到目前为止，所有示例都是单一继承链，换句话说，是一种类似于森林的结构。但这不是必需的，在多重渲染中，一个类可以又多个基类。</p><p><img src="https://bu.dusays.com/2024/03/15/65f4464b6d3a5.png" alt="image-20240218131129845"></p><p>考虑用户界面环境，假定用户可单击某张图片。这个对象好像既是按钮又是图片，因此其实现同时继承了 Image 类和 Button 类，如图 5.12所示。</p><p><img src="https://bu.dusays.com/2024/03/15/65f4464ce5367.png" alt="image-20240218131236153"></p><p>某些情况下多重继承可能很有用，但必须记住它也有很多缺点。许多程序员不喜欢多重继承，C++明确支持这种关系，而 Java 语言根本不予支持，除非通过多个接口来继承(抽象基类)。批评多重继承是有原因的：</p><ul><li>首先，用图形表示多重继承十分复杂。如图 5-11 所示，当存在多重继承和交叉线时，即使简单的类图也会变得非常复杂。类层次结构旨在让程序员更方便地理解代码之间的关系。而在多重继承中，类可有多个彼此没有关系的父类。将这么多类加入对象的代码中，能跟踪发生了什么吗？</li><li>其次，多重继承会破坏清晰的层次结构。  </li><li>最后，多重继承的实现很复杂。</li></ul><p>其他语言取消多重继承的原因是：通常可以避免使用多重继承。在控制某种项目设计时，重新考虑层次结构，通常可以避免引入多重继承。</p></blockquote><hr><h4 id="4-7混入类"><a href="#4-7混入类" class="headerlink" title="4.7混入类"></a>4.7混入类</h4><blockquote><p><strong>混入(mix-in) 类</strong>代表类之间的另一种关系。在 C++中，混入类的语法类似于多重继承，但语义完全不同。混入类回答“<strong>这个类还可以做什么</strong>”这个问题，<strong>答案经常以 “-able” 结尾</strong>。<strong>使用混入类，可向类中添加功能，而不需要保证是完全的“是一个”关系。</strong>可将它当作一种<strong>分享(share-with)关系</strong>。  </p><p>混入类经常在用户界面中使用。可以说 Image 能够单击(Clickable), 而不需要说 PictureButton 类既是 Image又是 Button。桌面上的文件夹图标可以是一张可拖动(Draggable)、可单击(Clickable)的图片(Image)。软件开发人员总是喜欢弄一大堆有趣的形容词。  </p><p>当考虑类而不是代码的差异时，混入类和基类的区别还有很多。因为范围有限，混入类通常比多重层次结构容易理解。Pettable 混入类只是在己有类中添加了一个行为，Clickable 混入类或许仅添加了“按下鼠标”和 “释放鼠标”行为。此外，混入类很少会有庞大的层次结构，因此不会出现功能的交叉混乱。第 28 章将详细介绍混入类。  </p></blockquote><hr><h3 id="5-5抽象"><a href="#5-5抽象" class="headerlink" title="5.5抽象"></a>5.5抽象</h3><blockquote><p>第 4 章讲述了抽象的概念一将实现与访问方式分离的概念。前面说过，抽象是一种优秀的思想，也是面向对象设计的基础。  </p></blockquote><hr><h4 id="5-1接口与实现"><a href="#5-1接口与实现" class="headerlink" title="5.1接口与实现"></a>5.1接口与实现</h4><blockquote><p><strong>抽象的关键在于有效分离接口与实现。</strong>实现是用来完成任务的代码，接口是其他用户使用代码的方式。在 C 中，描述库函数的头文件是接口，在面向对象编程中，类的接口是公有属性和方法的集合。优秀的接口只包含共有行为，类的属性&#x2F;变量绝不应该公有，但是可以通过公有方法公开，这些方法被称为获取器和设置器。</p></blockquote><hr><h4 id="5-2决定公开的接口"><a href="#5-2决定公开的接口" class="headerlink" title="5.2决定公开的接口"></a>5.2决定公开的接口</h4><blockquote><p>编写接口又很多理由。在编写代码前，甚至在决定要公开的功能之前，必须理解接口的目的。</p><p>当设计类时，其他程序员如何与你的对象交互是一个问题。<strong>在 C++中，类的属性和方法可以是公有的(public)、受保护的(protected)和私有的(private)<strong>。 将属性或行为设置为 <strong>public 意味着其他代码可以访问它们。protected 意味着其他代码不能访问这个属性或行为，但子类可以访问。private 是最严格的控制，意味着不仅其他代码不能访问这个属性或行为，子类也不能访问，只有自身可以将属性转化为行为，然后根据行为来体现属性，最后只能使用自身来实现类的功能</strong>。注意，</strong>访问修饰符在类级别而非对象级别发挥作用。例如,这意味着类的方法可访问同一个类的其他对象的私有属性或私有方法。</strong>  </p><p><strong>应用程序编程接口(API)</strong></p><p>API 是一种外部可见机制，用于在其他环境中扩展产品或者使用其功能。如果说内部的接口是契约，那么API 更接近于雕刻在石头上的法律。一旦用户开始使用你的 API, 哪怕他们不是公司的员工，他们也不希望 API发生改变，除非加入帮助他们的新功能。在交给用户使用之前，应该关心 API 的设计，并与用户进行商谈。  </p><p>设计 API 时主要考虑易用性和灵活性。由于接口的目标用户并不熟悉产品内部的运行方式，因此学习使用API 是一个循序渐进的过程。毕竟，公司向用户公开这些 API 的目的是想让用户使用 API。如果使用难度太大, API 就是失败的。灵活性常与此对立，产品可能有许多不同的用途，我们希望用户能使用产品提供的所有功能。然而，如果一个 API 让用户做产品可做的任何事，那么它肯定会过于复杂。   </p><p>正如编程格言所说，“好的 API 使容易的情况变得更容易，使艰难的情况变得容易”。也就是说，API 应该很容易使用。大多数程序员想要做的事情就是访问。然而，<strong>API 应该允许更高级的用法</strong>，因此在罕见的复杂情况和常见的简单情况之间做出折中是可以接受的。</p><p><strong>工具类或库</strong></p><p><strong>通常，程序员的任务是设计某些特定的功能，供应用程序中的其他部分使用，这可能是一个随机数库或日志类</strong>。在此情况下比较容易确定接口，因为要公开大多数功能或全部功能，<strong>理想情况下不应该给出与实现有关的内容。</strong>通用性是需要考虑的重要问题，由于类或库是通用的，因此在设计中应该考虑设置可能的用例集。</p><p><strong>子系统接口</strong></p><p><strong>你可能设计程序中两个主要子系统之间的接口，例如访问数据库的机制。</strong>在此情况下，将接口与实现分离异常重要，其他程序员可能会在你的实现完成之前依靠你的接口编写他们的实现。当处理子系统时，首先考虑子系统的主要目的是什么。一旦定义子系统的主要任务，就可以考虑子系统的具体用法以及如何将它展示给代码的其他部分。试着从他人的角度考虑问题，而不要身陷实现的细节而不能自拔。</p><p><strong>组件接口</strong></p><p><strong>我们定义的大多数接口可能都小于子系统接口或 API。组件是在其他代码中会用到的类。</strong>这些情况下，当接口逐渐增大，变得难以控制时，就可能会出现问题。哪怕这些接口是供自己使用的，也要当成不是。与子系统接口类似，此时应该考虑每个类的主要目的，不要公开对这个目的没有贡献的功能。</p><p><strong>在设计接口时，应该考虑将来的需求。你会在这个设计上花费数年时间吗？如果是这样，就可能需要使用插件架构，从而留出扩展空间。能够确定人们使用接口的目的与当初设计的目的相同吗？与他们交流，以更好地理解他们的使用情况。否则以后就要重写接口，或者更糟糕的是，以后可能需要不时地添加新功能，使接口变得凌乱不堪。要小心！如果将来的用途不明，就不要设计包含一切的日志类，因为这样做会不必要地将设计、实现和公有接口复杂化 。</strong></p></blockquote><hr><h4 id="5-3设计成功的抽象"><a href="#5-3设计成功的抽象" class="headerlink" title="5.3设计成功的抽象"></a>5.3设计成功的抽象</h4><blockquote><p>经验和重复是良好抽象的基础。只有经历过多年编写代码和使用抽象，才能真正地设计良好的接口。也可通过标准设计模式，重用己有的、设计优秀的抽象代码，利用他人多年编写和使用抽象的经验。当遇到其他抽象时，试着记住什么可行，什么不可行。</p><p>良好的抽象意味着接口只有公有行为。所有代码都应该在实现文件而不是类定义文件中。这意味着包含类定义的接口文件是稳定的，不会改变。与此对应的技术称为私有实现习语或 pimpl idiom, 详见第 9 章。    </p><p>小心单一类的抽象。如果编写的代码非常深奥，应该考虑用其他类配合主接口。例如，如果公开一个完成数据处理的接口，那么还要考虑编写一个结果对象，从而提供一种简单的方法来查看并说明结果。  </p><p><strong>始终将属性转换为方法。</strong>换句话说，不要让外部代码直接操作类的数据。不要让一些粗心或怀有恶意的程序员把兔子对象的高度设置为负数，为此可对“设置高度”方法进行边界检查。  </p></blockquote><hr><h3 id="5-6本章小结"><a href="#5-6本章小结" class="headerlink" title="5.6本章小结"></a>5.6本章小结</h3><blockquote><p>层次清晰化，属性方法化，使用 “有一个” 而非 “是一个”，“是一个” 关系变多，会使得基类的概念模糊，耦合性过大)；</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 复习教程第六章（设计可重用代码）</title>
    <link href="/2024/03/14/C++%20%E5%A4%8D%E4%B9%A0%E6%95%99%E7%A8%8B%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%88%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%87%8D%E7%94%A8%E4%BB%A3%E7%A0%81%EF%BC%89/"/>
    <url>/2024/03/14/C++%20%E5%A4%8D%E4%B9%A0%E6%95%99%E7%A8%8B%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%88%E8%AE%BE%E8%AE%A1%E5%8F%AF%E9%87%8D%E7%94%A8%E4%BB%A3%E7%A0%81%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="第6章-——-设计可重用代码"><a href="#第6章-——-设计可重用代码" class="headerlink" title="第6章 —— 设计可重用代码"></a>第6章 —— 设计可重用代码</h2><blockquote><p>在程序中，重用库和其他代码是一项重要的设计策略。然而，这只是重用策略的一半，另外一半是设计并编写在程序中的可重用代码。你可能己经发现，设计良好的库和设计不当的库之间存在显著差别。设计良好的库用起来很舒服，而设计糟糕的库会让人觉得非常难受，以至于放弃使用，自己编写代码。<strong>无论是编写供其他程序员使用的库，还是仅仅设计某个类层次结构，在设计代码时都应该考虑重用。你永远不知道后续项目什么时候会用到相似的功能段。</strong>  </p><p>第 4 章介绍了重用的设计主题，并阐述了如何通过在设计中整合库和其他代码来应用这个主题。<strong>本章讨论重用的另一方面：设计可重用代码。</strong>这一内容建立在第 5 章介绍的面向对象设计原则基础之上，并引入了新的策略和指导方针。</p></blockquote><hr><h3 id="6-1重用哲学"><a href="#6-1重用哲学" class="headerlink" title="6.1重用哲学"></a>6.1重用哲学</h3><blockquote><p>应该设计自己和其他程序员都可以重用的代码。这条规则不仅是用于专供其他程序员使用的库或框架，还适用于程序中用到的类、子系统和组件。</p><p>牢记格言：</p><ul><li>编写一次，经常使用；</li><li>尽量避免代码重复；</li><li>DRY(Don’t Repeat Yourself)；</li></ul><p>原因如下：</p><ul><li>代码不大可能只在一个程序中使用，代码总会被重用；</li><li>重用设计可节省时间和金钱，减少过多重复性工作；</li><li>团队中的其他程序员必须能够使用你编写的代码，因为大部分工程都不可能独自完成，因此，重用设计可以称为协作编程；</li><li>缺乏重用性会导致代码重复，代码重复会导致维护困难，因为一旦发现 bug 那么就必须在所有地方都进行改变，这很容易出错；</li><li>你自己是主要受益人，因为经验丰富的程序员永远不会扔掉代码，随着时间推移，他们会创建个人工具库，你永远不会事先知道要在什么时候使用到类似的代码；</li></ul><p>警告：</p><p>​公司员工设计或编写代码时，通常拥有知识产权的时公司而不是员工本人。当员工终止劳动合同时，保留设计或代码的副本通常是违法的；</p></blockquote><hr><h3 id="6-2如何设计可重用代码"><a href="#6-2如何设计可重用代码" class="headerlink" title="6.2如何设计可重用代码"></a>6.2如何设计可重用代码</h3><blockquote><p>可重用代码目标：</p><ol><li>代码必须通用，太过特定的组件很难被重用；</li><li>代码应当易于使用，而不需要花费大量时间理解他们的接口或功能；</li></ol><p>将库“递交”给客户的方法也很重要。可以源代码形式递交，这样客户只需要将源代码整合到他们的项目中。另一种选择是递交一个静态库，客户可以将该库连接到他们的应用程序中，也可以给 Windows 客户递交一个动态链接库(DLL)，给 Linux 客户递交一个共享对象(.so)。这些递交方式会对编写库的方式施加额外限定；</p><p>注意：</p><p><strong>本章用术语 “客户”代表使用接口的程序员。</strong>不要将客户与使用程序的 “用户”混淆。本章还使用了短语“客户代码”，这代表使用接口的代码。</p><p>重中之重：</p><p>重用代码的本质是——抽象；</p><p>抽象将代码分为接口和实现，因此设计可重用代码会关注这两个关键领域；实现代码，是重用的实现；只要理解代码接口，即可使用；</p></blockquote><hr><h4 id="2-1使用抽象"><a href="#2-1使用抽象" class="headerlink" title="2.1使用抽象"></a>2.1使用抽象</h4><blockquote><p>抽象的优点：</p><ul><li><p>通过分离实现和接口，首先，使得客户只需要明白接口的用途就可以使用代码；而程序员在维护时，不需要修改接口，因此不需要征求客户的同意，只需改变代码本身就可以；如果使用动态链接库(DLL)，甚至不需要重新生成可执行文件；</p></li><li><p>总之，获得好处的是因为作为库的编写者，可在接口明确指定希望的交互方式和支持方式的功能；接口与实现的明确分离可以杜绝用户以不希望的方式使用库，而这些方式可能导致意料之外的行为和 bug。</p></li><li><p>当在设计界面时，不要向客户公开实现细节；</p></li><li><p><strong>有时为将某个接口返回的信息传递给其他接口，库要求客户代码保存这些信息。这一信息有时叫作句柄（handle）, 经常用来跟踪某些特定的实例，这些实例调用时的状态需要被记住。如果库的设计需要句柄，不要公开句柄的内部情况。可将句柄放入某个不透明类，程序员不能“直接访问这个类的内部数据成员，也不能通过公有的获取器或设置器来访问”。</strong></p><blockquote><p>这种设计决策有以下目的和优势：</p><ol><li><strong>封装内部实现：</strong> 将句柄放入一个不透明类中，允许库在内部更改实现细节而不会影响客户代码。客户代码只需要与句柄进行交互，而不需要了解其内部结构。</li><li><strong>隐藏实现细节：</strong> 隐藏句柄的内部情况可以防止客户代码直接访问或修改句柄的状态。这种信息隐藏有助于维护库的一致性和稳定性，因为客户代码无法非法地操作句柄。</li><li><strong>提高安全性：</strong> 不透明类的使用可以提高安全性，防止客户代码意外地破坏库内部的状态。通过限制对内部成员的访问，可以减少潜在的错误和不当操作。</li></ol></blockquote></li><li><p>不要要求客户代码改变句柄内部的变量。一个不良设计的示例是，一个库为了启用错误日志，要求设置某个结构的特定成员，而这个结构所在的句柄本来应该是不透明的</p></li></ul></blockquote><hr><h4 id="2-2构建理想的重用代码"><a href="#2-2构建理想的重用代码" class="headerlink" title="2.2构建理想的重用代码"></a>2.2构建理想的重用代码</h4><blockquote><ol><li><p><strong>避免组合不相干的概念或者逻辑上独立的概念，当设计组件时，应该关注单个任务或一组任务，即“高聚合”， 也称为 SRP（Single Responsibility Principle,单一责任原则）。</strong> 不要将无关概念组合在一起，例如随机数生成器和 XML 解析器。  </p><p><strong>即使设计的代码并不是专门用来重用的，也应该记住这一策略。</strong>整个程序本身很少会被重用，但是程序的片段或子系统可直接组合到其他应用程序中，也可以在稍作变动后用于大致相同的环境。因此，设计程序时，应将逻辑独立的功能放到不同的组件中，以便在其他程序中使用。其中的每个组件都应当有明确定义的责任。</p><p><strong>这个编程策略模拟了现实中可互换的独立部分的设计原则。</strong>例如，可编写一个 Car 类，在其中放入引擎的所有属性和行为。但引擎是独立组件，未与小汽车的其他部分绑定。可将引擎从一辆小汽车卸下，安装在另一辆小汽车中。<strong>合理的设计是添加一个 Engine 类，其中包含与引擎相关的所有功能。此后，Car 实例将包含 Engine实例。</strong></p><p><strong>将程序分为逻辑子系统  ，将子系统设计为可单独重用的分立组件，即“低耦合”。</strong> 每个子系统都应该遵循抽象原则。将每个子系统当作微型库，必须为其提供稳定的、便于使用的接口。即使你是使用这个微型库的唯一程序员，设计良好的接口和从逻辑上分离不同功能的实现也是有益的。  </p><p> <strong>用类层次结构分离逻辑概念，除了将程序分为逻辑子系统以外，在类级别上应该避免将无关概念组合在一起。</strong>  <strong>总结：组织内部高聚合，组件之间低耦合；</strong></p><p>用聚合分离逻辑概念。第 5 章讨论的聚合（Aggregation）模拟了“有一个”关系：为完成特定功能，对象会包含其他对象。当不适合使用继承方法时，可以使用聚合分离没有关系的功能或者有关系但独立的功能。</p><p>例如，假定要编写一个 Family 类来存储家庭成员。显然，树数据结构是存储这些信息的理想结构。不应该把树数据结构的代码整合到 Family 类中，而是应该编写一个单独的 Tree 类。然后 Family 类可以包含并使用 Tree实例。用面向对象的术语来说，Family 有一个 Tree。通过这种方法，可以在其他程序中方便地重用树数据结构。</p><p>消除用户界面的依赖性</p><p>如果是一个操作数据的库，就需要将数据操作与用户界面分离开来。这意味着对于这些类型的库，不应该假定哪种类型的用户界面会使用库，因此不应该使用 cout、cerr、cin、stdout、stderr 或 stdin, 因为如果在图形用户界面的环境下使用库，这些概念将没有意义。例如，基于 Windows GUI 的应用程序通常不会有任何形式的控制台 I&#x2F;O。即使库只用于基于 GUI 的程序，也不应该向最终用户弹出任何类型的消息窗口或者其他类型的提示，这是客户代码需要做的事情。这种类型的依赖不仅降低了重用性，还阻止了客户代码正确响应错误以及在后台自动处理错误。</p></li></ol><p>以下是一些实现这一目标的常见策略：</p><ol><li><strong>使用回调函数：</strong> 允许客户代码提供回调函数，这些函数用于处理特定事件或错误。例如，库可以定义一些回调函数，如处理错误、进度更新或异步操作完成等。客户代码负责实现这些回调函数，以便在适当的时候进行响应。</li><li><strong>定义接口或抽象类：</strong> 将用户界面相关的操作定义为接口或抽象类，使得客户代码可以根据自己的需要实现这些接口。这种方式使得库不依赖于具体的用户界面实现，而只依赖于接口。</li><li><strong>使用事件机制：</strong> 如果库支持事件，客户代码可以注册感兴趣的事件处理器。这样，库可以触发事件，而客户代码则负责处理这些事件，例如更新界面或处理错误。</li><li><strong>提供配置选项：</strong> 允许客户代码通过配置选项来自定义库的行为，而不是在库中直接使用特定的用户界面元素。例如，客户代码可以通过设置配置选项来指定日志输出的目标，而不是直接使用 cout 或者其他特定的输出流。</li><li><strong>避免直接的用户界面代码：</strong> 在库中避免直接调用与用户界面相关的库或函数。将这些调用封装在特定的接口或者类中，使得用户界面的具体实现对于库来说是可替换的。</li><li><strong>提供适配器模式：</strong> 如果必须在库中处理用户界面相关的逻辑，可以考虑使用适配器模式。通过定义一个接口，允许不同的用户界面实现提供适配器，以便库可以与不同的用户界面进行交互。</li></ol><p>第 4 章介绍的 Model-View-Controner（MVC）范型是一种将数据存储和数据显示分开的著名设计模式。在这种范型中，模型可放在库中，客户代码可提供视图和控制器。</p><p>2.<strong>对泛型数据结构和算法使用模板：</strong>  </p><p>​<strong>C++模板的概念允许以类型或类的形式创建泛型结构。</strong>例如，假定为整型数组编写了代码。如果以后要使用 double 数组，就需要重写并复制所有代码。模板的概念将类型变成一个需要指定的参数，这样就可以创建一个适用于任何类型的代码体。模板允许编写适用于任何类型的数据结构和算法。</p><p>最简单的示例是std::vector类,这个类是C++标准库的一部分。为创建整型的 vector, 可编写 std::vector<int>;,为创建 double 类型的 vector, 可编写 std::vector<double>。模板编程通常功能强大，但非常复杂。幸运的是，可以创建简单的、使用类型作为参数的模板用例。第 12 和 22 章讲述编写自定义模板的技巧，本节讨论模板的一些重要设计特征。</p><p><strong>只要有可能，就应该设计泛型（而不是局限于某个特定程序的）数据结构和算法。</strong>不要编写只存储 book 对象的平衡二叉树结构，要使用泛型，这样就可以存储任何类型的对象。通过这种方法，可将其用于书店、音乐商店、操作系统或需要平衡二叉树的任何地方。这个策略是标准库的基础。标准库提供可用于任何类型的泛型数据结构和算法。</p><p><strong>模板优于其他泛型程序设计的原因：</strong></p><ol><li>void* (用于不指定类型的指针)，类型不安全，，欸有类型检测，无论删除还是转换都存在一定风险；</li><li>为特定类编写数据结构，通过多态性(统一操作作用于不同对象，行为不同)，这个类的所有子类都可以存储在这个结构中。Java 将这种方法发挥到极致，指定所有的类都从 Object 类直接或间接派生。<strong>早期 Java 版本的容器存储 Object, 因此可以存储任何类型的对象。然而，这种方法也不是真正类型安全的。从容器中删除某个对象时，必须记得其真实的类型，并向下转换（down-cast）为合适的类型。向下转换意味着转换为类层次结构中更具体的类，即沿着类层次结构“向下”转换。</strong></li></ol><p><strong>模板并不是完美的：</strong></p><ol><li>首先，语法较为迷惑；</li><li>其次，模板要求相同类型的数据节后，在一个结构中只能存储相同的数据类型。这就是说，一个模板创建出的数据结构，只能用于存储同种类型。这种限制是由模板的类型安全性质决定的。从 C++17开始，可以采用一种标准方式来绕过这种“相同类型”限制。可编写数据结构来存储 std::variant 或 std::any 对象。std::any 对象可存储任意类型的值，std::variant对象可存储所选类型的值。第 20 章将详细介绍这两种对象以及它们的变体。</li></ol><p>模板与继承的区别：</p><ol><li><strong>如果打算为不同的类型提供相同的功能，则使用模板。</strong>例如，如果要编写一个适用于任何类型的泛型排序算法，应该使用模板。如果要创建一个可以存储任何类型的容器，应该使用模板。关键的概念在于模板化的结构或算法会以相同方式处理所有类型。但是，如有必要，可给特定的类型特殊化模板，以区别对待这些类型。模板特殊化参见第 12 章  </li><li><strong>当需要提供相关类型的不同行为时，应该使用继承。</strong>例如，如果要提供两个不同但类似的容器，例如队列和优先队列，应该使用继承；</li><li>把二者结合起来。可以编写一个模板基类，此后从中派生一个模板化的类。(这也就叫做抽象，抽象出来这个，然后给出接口)第 12 章将详细讲述模板语法；</li></ol><p><strong>提供适当的检测和安全措施：</strong></p><p>第一种方法是按契约设计，这表示函数或类的文档是契约，详细描述客户代码的作用以及函数或类的作用。按契约设计有三个重要方面：前置条件(precondition)、后置条件(postcondition)和不变量(invariant)。前置条件列出为调用函数或方法，客户代码必须满足的条件。后置条件列出完成执行后，函数或方法必须满足的条件。最后，不变量列出在函数或方法执行期间，必须一直满足的条件；</p><blockquote><p>这种方法常用于标准库。例如，std::vector 定义了一个契约，以使用数组记号获取 vector 中的某个元素。契约指定，vector 不进行边界检查，这是客户代码的责任。也就是说，使用数组记号从 vector 获取元素的前置条件对于给定索引是有效的。这样可提高客户代码的性能，因为客户代码知道其索引在指定范围内。vector 还定义了 at()方法，用来获取进行边界检查的特定元素。所以客户代码可以选择是使用不带边界检查的数组记号，还是使用带有边界检查的 at()方法。  </p></blockquote><p>第二种方法是以尽可能安全的方式设计函数和类。这个指导方针的最主要特征就是在代码中执行错误检测。例如，如果随机数生成器要求一个处于指定范围的种子，不要相信用户一定会正确地传递一个有效的种子。应该检测传递过来的值，如果无效，就拒绝调用。前面讨论的 at() 方法是另一个考虑安全的示例。如果用户提供了无效索引，该方法将抛出异常。  </p><p>有些技巧和语言特征有助于编写安全代码，有助于在程序中加入检测和安全措施。<strong>首先，可返回错误代码或特定的值(例如 fhlse 或 nullptr), 或者抛出异常，以提醒客户代码发生了错误，第 14 章将详细讲述异常。****其次,为编写安全代码，可使用智能指针管理动态分配的内存等资源。从概念上说，智能指针是指向动态分配的资源的指针，当超出作用域时会自动释放资源。</strong>第 1 章讨论过智能指针。</p><p><strong>扩展性:</strong></p><p>设计的类应当具有扩展性，可通过从这些类派生其他类来扩展它们。不过，设计好的类应当不再修改；也就是说，其行为应当是可扩展的，而不必修改其实现。这称为开放&#x2F;关闭原则(Open&#x2F;Closed Principle, OCP)。</p><p>  例如，假设开始实现绘图应用程序。第一个版本只支持绘制正方形，设计中包含两个类：Square() 和 Renderer0 前者包含正方形的定义，如边长；后者负责绘制正方形。得到的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span><br>&#123;<br><span class="hljs-comment">// Details not important for this example.</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Renderer</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">render</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;Square&gt;&amp; squares)</span></span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Renderer::render</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;Square&gt;&amp; squares)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; square : squares)<br>&#123;<br><span class="hljs-comment">// Render this square object.</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，添加对绘制圆的支持，因此创建 Circle 类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span><br>&#123;<br><span class="hljs-comment">// Details not important for this example.</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>下面给出一种愚蠢的 render() 解决方案:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Renderer::render</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;Square&gt;&amp; squares,</span></span><br><span class="hljs-params"><span class="hljs-function">  <span class="hljs-type">const</span> vector&lt;Circle&gt;&amp; circles)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; square : squares)<br>&#123;<br><span class="hljs-comment">// Render this square object.</span><br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; circle : circles)<br>&#123;<br><span class="hljs-comment">// Render this circle object.</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时的设计应当使用继承，虽然稍微超前，但是仍然给出，只需要理解其中的精妙，只需要知道 Square 从 Shape 类中派生即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> : <span class="hljs-keyword">public</span> Shape &#123;&#125;;<br></code></pre></td></tr></table></figure><p>下面使用继承语法的设计：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">render</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> : <span class="hljs-keyword">public</span> Shape<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">render</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">/* Render square */</span> &#125;<br><span class="hljs-comment">// Other members not important for this example.</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">render</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123; <span class="hljs-comment">/* Render circle */</span> &#125;<br><span class="hljs-comment">// Other members not important for this example.</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Renderer</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">render</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;shared_ptr&lt;Shape&gt;&gt;&amp; objects)</span></span>;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Renderer::render</span><span class="hljs-params">(<span class="hljs-type">const</span> vector&lt;shared_ptr&lt;Shape&gt;&gt;&amp; objects)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; object : objects)<br>&#123;<br>object-&gt;<span class="hljs-built_in">render</span>();<br>&#125;<br>&#125;<br><span class="hljs-comment">/*看到这里没有这个多态，实在是优美，利用抽象把多态给搞出来，再利用抽象把将有特点的类从基类中派生出来，注意到没有 auto* 的使用，这是不是特别引人入胜，一下子把很多需要说的东西给解决了，而且是类型安全的，而且使用 const &amp; 的常量引用方式，只能说结构实在是清晰*/</span><br><br><span class="hljs-comment">// 因为后面介绍了 DIP 这种比较高级的方式，下面给出这种写法(看后面，已经觉得这种方式不是很好了，下面有鲁棒的)：</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 渲染器接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Renderer</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">renderShape</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 具体的方形渲染器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SquareRenderer</span> : <span class="hljs-keyword">public</span> Renderer<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">renderShape</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Rendering square.&quot;</span> &lt;&lt; std::endl;<br><span class="hljs-comment">// 具体的方形渲染逻辑</span><br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体的圆形渲染器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CircleRenderer</span> : <span class="hljs-keyword">public</span> Renderer<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">renderShape</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Rendering circle.&quot;</span> &lt;&lt; std::endl;<br><span class="hljs-comment">// 具体的圆形渲染逻辑</span><br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 通过渲染器接口实现依赖反转</span><br><span class="hljs-built_in">Shape</span>(Renderer* renderer) : <span class="hljs-built_in">renderer</span>(renderer) &#123;&#125;<br><br><span class="hljs-comment">// 渲染形状的方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">render</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>renderer-&gt;<span class="hljs-built_in">renderShape</span>();<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>Renderer* renderer;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 创建具体的渲染器实例</span><br>SquareRenderer squareRenderer;<br>CircleRenderer circleRenderer;<br><br><span class="hljs-comment">// 创建具体的形状实例，并传入相应的渲染器</span><br><span class="hljs-function">Shape <span class="hljs-title">square</span><span class="hljs-params">(&amp;squareRenderer)</span></span>;<br><span class="hljs-function">Shape <span class="hljs-title">circle</span><span class="hljs-params">(&amp;circleRenderer)</span></span>;<br><br><span class="hljs-comment">// 渲染形状</span><br>square.<span class="hljs-built_in">render</span>();  <span class="hljs-comment">// 输出：Rendering square.</span><br>circle.<span class="hljs-built_in">render</span>();  <span class="hljs-comment">// 输出：Rendering circle.</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*这样看上去是不是更 NB 了？这样使得依赖注入了*/</span><br><span class="hljs-comment">/*我想强调的是：依赖注入(DIP)实现的是对功能的多态化处理，将类与类的功能分开，是向实现功能的特定类进行派生类注入，然后实现同一操作的多态化。所以，给出下面更好的方法。*/</span><br><br><span class="hljs-comment">// 理论角度上，下面这种方式也是可行的：</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 渲染器接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">renderShape</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">// 具体的方形渲染器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Square</span> : <span class="hljs-keyword">public</span> Shape<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">renderShape</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Rendering square.&quot;</span> &lt;&lt; std::endl;<br><span class="hljs-comment">// 具体的方形渲染逻辑</span><br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 具体的圆形渲染器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">renderShape</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Rendering circle.&quot;</span> &lt;&lt; std::endl;<br><span class="hljs-comment">// 具体的圆形渲染逻辑</span><br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Render</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 通过渲染器接口实现依赖反转</span><br><span class="hljs-built_in">Render</span>(Shape* shape) : <span class="hljs-built_in">shape</span>(shape) &#123;&#125;<br><br><span class="hljs-comment">// 渲染形状的方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">render</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>shape-&gt;<span class="hljs-built_in">renderShape</span>();<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>Shape* shape;<br>&#125;;<br><br><span class="hljs-comment">/*这里我们看到了两种依赖方式：</span><br><span class="hljs-comment">    1.Shape 类依赖于 Renderer 接口(派生类为渲染器)：</span><br><span class="hljs-comment">优点：Shape 类可以直接依赖于渲染器接口，更加直观。添加新的形状时，只需创建一个新的实现了 Renderer 接口的类，而不需要修改 Shape 类。</span><br><span class="hljs-comment">缺点：Shape 类需要知道渲染器的存在，这可能在一些情况下被视为 Shape 类的责任过重，不够单一。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">2.Render 类依赖于 Shape 接口(派生类为图形)：</span><br><span class="hljs-comment">优点：在这种情况下，Shape 类并不关心具体的渲染器是什么，只关心渲染的形状。这种设计更加符合单一责任原则，因为每个类都有一个清晰的责任。</span><br><span class="hljs-comment">缺点：可能存在大量的渲染器类，每个都需要实现 renderShape() 方法。这种情况下，添加新的形状可能需要创建一个新的渲染器类。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">在实际应用中，选择哪种方法通常取决于具体的系统需求和设计目标。</span><br><span class="hljs-comment">如果系统中存在多种形状和多种渲染器，并且它们的变化原因不同，那么第一种方法可能更为合适。</span><br><span class="hljs-comment">如果系统中形状的变化和渲染器的变化相对独立，那么第二种方法可能更为直观和灵活。</span><br><span class="hljs-comment">嗯，事实上，第二种更符合最上面没有 DIP 化的形式，但是明显第一种也是可行的。虽然，我也认为第一种是极其不合适的，因为它作为 Shape 类太过“随便”了！仿佛是个图形都可以触发，这显得很轻浮，可以到处沾花惹草，也就是换成人话说，耦合性太强，责任太强。真的不如后面的第二个向 Render 中注入 Shape 的方式；</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>现在，设想一下，我们要添加一个新形状类型，那么只需要对基类 Shape 进行派生就可以了，而不需要对 render() 方法进行修改，这完全是多态的体现，这是一种动态的多态，也叫运行时多态。(PS: 另外一种静态多态，多被体现为函数的复写)。因此我们可以说，多态是拓展是开放的，对修改是关闭的。</p><p>我来解释一下，什么叫做 OPC:</p><p>开放：开放对新派生类的扩充，对其属性和行为的规范；</p><p>关闭：关闭对行为(可重用代码)的修改，利用抽象派生实现；</p></blockquote><hr><h4 id="2-3设计有用的接口"><a href="#2-3设计有用的接口" class="headerlink" title="2.3设计有用的接口"></a>2.3设计有用的接口</h4><blockquote><p>没有优美的接口，实现再美好，都是扯淡。</p><p>良好接口有利于重用。</p><p>创新从实现上入手，不要对接口又什么创新想法，那只会变得很蠢；</p><p>回到 C++, 开发的接口应该遵循 C++程序员熟悉的标准。例如，C++程序员希望构造函数初始化对象，析构函数清理对象。当设计类时，应该遵循这个标准。如果要求程序员调用initialize。方法初始化对象，调用 cleanup。方法清理对象，而不是将这些功能放在构造函数和析构函数中，就会让所有用户感到迷惑。因为这个类与其他 C++类的行为不同，程序员需要花费更长的时间学习如何使用这个类，并可能由于忘记调用initialize。或 cleanup。方法而出错。  </p><p><strong>注意：</strong></p><p>​<strong>设计从使用者角度进行考虑；</strong></p><p>运算符重载可以作为一种帮助为对象开发易于使用的接口的语言特性；但不要使用过度，那样很笨拙，而且反人性，之后会详细讨论；</p><p><strong>不要省略必需的功能：</strong></p><p><strong>该策略分为两部分：</strong></p><ul><li>尽量包括用户所有的可能行为，虽然不可能完美，但是代码本身就没有完美，只有优雅；</li><li>在实现中尽量包含多的功能，不要要求客户端代码指定在实现中已经知道的信息(例如，库需要一个临时文件，不要让库的客户指定路径，他们应当不必担心库使用什么文件，应该用其他方法决定合适的临时文件路径)；</li></ul><p></p><p><strong>走向极端：</strong></p><p>部分程序员认为需要完美，比如曾经的我，但是现在我们认识到，优雅比完美更好。上面两个策略任何一个走向极端都是糟糕的事情，那会使得接口混乱至极；</p><p>从本质上说，设计简洁接口的思想看似简单，但是那是主观的规则，实践起来其实相当困难；这个规则基本上是主观的：由你决定什么是必需的，什么不是。当然，当这个判断出错时，客户一定会通知你。  </p><p><strong>提供文档和注释：</strong></p><p>这不是当前的重点，我一带而过，这部分单独学习；</p><p>无论接口多么便于使用，都应该提供使用文档。如果不告诉程序员如何使用，不能期望他们会正确使用库。应该将库或代码称为供其他程序员使用的产品。产品应该带有说明其正确用法的文档。</p><p>提供接口文档有两种方法：接口自身内部的注释和外部的文档。应该尽量提供这两种文档。大多数公开的API 只提供外部文档：许多标准 UNIX 和 Windows 头文件中都缺少注释。在 UNIX 中，文档形式通常是名为man pages 的在线手册。在 Windows 中，集成开发环境通常附带文档。</p><p>虽然多数 API 和库都取消了接口本身的注释，但我们认为，这种形式的文档才是最重要的。绝不应该给出一个只包含代码的“裸”头文件。即使注释与外部文档完全相同，具有友好注释的头文件也比只有代码的头文件看上去舒服，即使最优秀的程序员也希望经常看到书面语言。</p><p>有些程序员使用工具将注释自动转换为文档，第 3 章详细讨论了这一技术。(但我还是没学)</p><p><strong>无论提供注释、外部文档还是二者都提供，文档都应该描述库的行为而不是实现。行为包括输入、输出、错误条件和处理、预定用法和性能保障。</strong>例如，描述生成单个随机数的调用的文档应该说明这个调用不需要参数，返回一个预先指定范围的整数，还应该列出当出现问题时可能抛出的所有异常。文档不应该详细解释实际生成数字的线性同余算法，在接口注释中提供太多的实现细节可能是接口开发中最常见的错误。适用于库维护者(而不是客户)的注释会破坏接口和实现的良好分离，许多开发人员都见到过这种情况。当然，内部的实现也应该有文档记录，只是不要把它作为接口的一部分公开。第 3 章详细讨论了如何在代码中恰当地使用注释。  </p><p><strong>设计通用接口：</strong></p><p><strong>提供执行相同功能的多种方法：</strong></p><p>例如：std::vector 提供了两种方法来访问特定索引处的元素。可使用at()方法，该方法执行边界检查；也可使用 operator口方法，该方法不执行边界检查。如果知道索引是有效的，那么使用 operator口方法更合适，这样可省去使用 at()方法时的边界检查开销；</p><p>注意，这一策略应该当作接口设计中“整洁”规则的例外。有些情况下这个例外是恰当的，但大多数情况下应该遵循“整洁”规则；</p><p><strong>提供定制：</strong></p><p>为增强接口的灵活性，可提供定制。定制可以很简单，如允许用户打开或关闭错误日志。定制的基本前提是向每个客户提供相同的基本功能，但给予用户稍加调整的能力。</p><p>通过函数指针和模板参数，可提供更强的定制。例如，可允许客户设置自己的错误处理例程。</p><p><strong>标准库将定制策略发挥到极致，允许客户为容器指定自己的内存分配器。如果要使用这些特性，就必须编写一个遵循标准库指导方针和符合接口要求的内存分配器对象。</strong>标准库中的每个容器都将分配器作为模板参数，第 21 章将详细讲述。</p><p><strong>协调通用性和使用性：</strong> </p><p>通用意味着复杂，使用意味着简洁，统一这两者即可得到想要的优雅接口；</p><p>太通用，太模板化，不利于使用；太简介，不一定能够完全满足需求；</p><p>但它们并不是互斥的；</p><p><strong>提供多个接口：</strong></p><p>为在提供足够功能的同时，使用这种方法，提供多个独立的接口，这样可以使得复杂度极大降低。也就是说，实现虽然差不多，但是，使用不同接口，进行功能定制；<strong>这称为接口隔离原则(Interface Segregation Principle, ISP)。</strong>例如，编写的通用网络库可以具有两个独立的方向：一个为游戏提供网络接口，另一个为超文本传输协议(HTTP, 一种网络浏览协议)提供网络接口。 </p><p><strong>让常用功能易于使用：</strong> </p><p>当提供通用接口时，某些功能的使用频率会高于其他功能。应该让常用功能易于使用，同时仍提供高级功能选项。例如，多语言设置，给定一种语言作为默认语言，其余仍可设置使用；</p></blockquote><hr><h4 id="2-4-SOLID-原则"><a href="#2-4-SOLID-原则" class="headerlink" title="2.4 SOLID 原则"></a>2.4 SOLID 原则</h4><blockquote><p>常使用易记的首字母缩写词 SOLID 来指代面向对象设计的基本原则。表 6 汇总了 SOLID 原则。其中的大多数原则都在本章讨论过；对于本章未讨论的原则，则指明相关的章号。 </p><p><img src="https://bu.dusays.com/2024/03/15/65f44669c2a41.png" alt="image-20240220042235720"></p><p>原则如下：</p><p>S：内部高聚合，之间低耦合；</p><p>O：多态+继承实现对象开放，多态+复用实现功能修改关闭；</p><p>L：用于区分“有一个”和“是一个”，意思是说，当选择进行“是一个”的派生时，派生类的行为应当与其基类保持一致，如果程序能够保持一致，那么认为应该继续认为选择“是一个”的关系(因为关系为“是一个”，所以当进行使用时，保持前后行为的一致性，功能没有特殊性的前提下，这样的行为不会引起歧义，而且这样做还可以使得多态性得以增强，因为行为是一致的，因为如果一旦复写方法，那么就有可能存在定义上的偏差，这种偏差随着积累可能会很突兀，而且继承之下，潜在的基类属性也会一并继承，这种渗透事实上很糟糕)；如果不能保证的话，也就是派生类的行为与基类不一致时，应该舍弃“是一个”的派生关系，而转为“有一个”的包含关系(因为要包含对行为的修改，用有一个部分再进行修改的方式去写逻辑上更清晰。这种凡是则更加灵活，不会出现复写方法时的逻辑混乱问题)；</p><p>I：接口兼顾通用、实用，通过独立接口实现接口特异化，高效；</p><p>D：高层模块不应该依赖于底层模块，两者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。</p><ol><li><strong>高层模块（抽象）定义接口，低层模块实现接口。</strong></li><li><strong>具体实现依赖于抽象，而不是抽象依赖于具体实现。</strong></li><li><strong>使用接口或抽象类来定义高层模块的行为，而不是依赖于具体的实现类。</strong></li></ol><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-comment">// 定义抽象接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Report</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> std::string <span class="hljs-title">generate</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Report</span>() &#123;&#125;  <span class="hljs-comment">// 增加虚析构函数以正确释放资源</span><br>&#125;;<br><br><span class="hljs-comment">// 具体实现类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PDFReport</span> : <span class="hljs-keyword">public</span> Report &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::string <span class="hljs-title">generate</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// 生成 PDF 报告的具体实现</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;PDF Report&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HTMLReport</span> : <span class="hljs-keyword">public</span> Report &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">std::string <span class="hljs-title">generate</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// 生成 HTML 报告的具体实现</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;HTML Report&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 高层模块使用抽象接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ReportGenerator</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    Report* report;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 通过构造函数注入依赖</span><br>    <span class="hljs-built_in">ReportGenerator</span>(Report* report) : <span class="hljs-built_in">report</span>(report) &#123;&#125;<br><br>    ~<span class="hljs-built_in">ReportGenerator</span>() &#123;<br>        <span class="hljs-keyword">delete</span> report;  <span class="hljs-comment">// 释放资源</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">generateReport</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 生成报告</span><br>        std::string result = report-&gt;<span class="hljs-built_in">generate</span>();<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Generated Report: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 在使用时，可以通过传入不同的 Report 实现来生成不同类型的报告</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Report* pdfReport = <span class="hljs-keyword">new</span> <span class="hljs-built_in">PDFReport</span>();<br>    Report* htmlReport = <span class="hljs-keyword">new</span> <span class="hljs-built_in">HTMLReport</span>();<br><br>    <span class="hljs-function">ReportGenerator <span class="hljs-title">pdfReportGenerator</span><span class="hljs-params">(pdfReport)</span></span>;<br>    pdfReportGenerator.<span class="hljs-built_in">generateReport</span>();<br><br>    <span class="hljs-function">ReportGenerator <span class="hljs-title">htmlReportGenerator</span><span class="hljs-params">(htmlReport)</span></span>;<br>    htmlReportGenerator.<span class="hljs-built_in">generateReport</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*和上面的图形类似，这是在说，我的每个派生类要有一个抽象的拥有共同属性的基类，然后，每个积累包含有自己函数名相同但是实现内容不同的函数(多态的实现),然后对于高一级的应用，因为虽然是想对派生类进行操作，但是考虑到复用和不依赖关系，则使用注入基类的方式，来实现多态的实现*/</span><br></code></pre></td></tr></table></figure><p>优点如下：</p><ol><li><strong>松耦合：</strong> 依赖注入通过在对象的构造函数、方法参数或者属性中注入依赖，降低了组件之间的耦合度。这使得各个组件可以更独立地开发、测试和维护，而不容易受到彼此的变化影响。</li><li><strong>可测试性：</strong> 通过依赖注入，可以轻松地替换实际依赖的实现，使用模拟对象或者测试替身。这样，在单元测试中，我们可以注入模拟对象，更方便地对组件进行隔离测试，而不受到真实依赖的影响。</li><li><strong>可维护性：</strong> 依赖注入使得代码的结构更清晰，依赖关系更明确。这有助于理解和维护代码，因为每个组件的依赖都是显式的，而不是隐藏在组件内部。</li><li><strong>灵活性：</strong> 通过依赖注入，可以在运行时动态地替换依赖的实现。这为系统提供了更大的灵活性，使得在不修改现有代码的情况下，可以更容易地切换或升级依赖的版本或实现。</li><li><strong>可扩展性：</strong> 依赖注入使系统更容易扩展，因为新增的组件可以通过依赖注入的方式接入系统，而不需要修改现有代码。</li></ol></blockquote><hr><h3 id="6-3本章小结"><a href="#6-3本章小结" class="headerlink" title="6.3本章小结"></a>6.3本章小结</h3><blockquote><p>SOLID！！！</p></blockquote><hr><h2 id="第三部分-——-专业的-C-编码方法"><a href="#第三部分-——-专业的-C-编码方法" class="headerlink" title="第三部分 —— 专业的 C++ 编码方法"></a>第三部分 —— 专业的 C++ 编码方法</h2><hr><blockquote><p>- </p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 复习教程第八章（熟悉类和对象）</title>
    <link href="/2024/03/14/C++%20%E5%A4%8D%E4%B9%A0%E6%95%99%E7%A8%8B%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%88%E7%86%9F%E6%82%89%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%89/"/>
    <url>/2024/03/14/C++%20%E5%A4%8D%E4%B9%A0%E6%95%99%E7%A8%8B%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%88%E7%86%9F%E6%82%89%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="第8章-——-熟悉类和对象"><a href="#第8章-——-熟悉类和对象" class="headerlink" title="第8章 —— 熟悉类和对象"></a>第8章 —— 熟悉类和对象</h2><blockquote><p>作为面向对象语言，C++ 提供了使用对象和定义对象的工具，称为类。</p><p>编写没有类的 C++ 程序就像去巴黎吃麦当劳一样。</p><p>类是 C++ 中最基本、最有用的特性。</p><p><strong>本章讲述与类和对象的使用有关的基本概念，包括编写类定义、定义方法、在堆和堆栈中使用对象，以及编写构造函数、默认构造函数、编译器生成的构造函数、构造函数初始化器(称为 ctor-initialize())、复制构造函数、构造函数初始化列表、析构函数和赋值运算符。</strong>即使已经熟悉了类和对象，也应该大致了解一下本章的内容，因为本章包含了各种细节信息，其中一些你可能并不熟悉。  </p></blockquote><hr><h3 id="8-1电子表格示例介绍"><a href="#8-1电子表格示例介绍" class="headerlink" title="8.1电子表格示例介绍"></a>8.1电子表格示例介绍</h3><blockquote><p>本章和第 9 章将列举一个可运行的、简单的电子表格示例。电子表格是一种二维的 “单元格” 网格，每个单元格包含一个数字或字符串。专业的电子表格(例如 Microsoft Excel) 提供了执行数学计算的功能，例如，对一组单元格的值求和。这里的电子表格示例不想抢占 Mircosoft 的市场，只是用来说明类和对象。</p><p>这个电子表格使用了两个基本类：Spreadsheet 和 SpreadsheetCell。每个 Spreadsheet 对象都包括了若干 SpreadsheetCell 对象。此外，SpreadsheetApplication 类管理 Spreadsheet 集合。本章重点介绍 SpreadsheetCell，第 9 章开发 Spreadsheet 和 SpreadsheetApplication 类。</p><p>注意：</p><p>​为循序渐进地讲解概念，本章显示了几个不同版本的 SpreadsheetCell 类。因此，本章关于类的各种尝试并非总是说明编写类的 “最佳” 方法。特别是早期的示例省略了一些通常会包含但还没有介绍重要的特性。</p></blockquote><hr><h3 id="8-2编写类"><a href="#8-2编写类" class="headerlink" title="8.2编写类"></a>8.2编写类</h3><blockquote><p><strong>编写类时，需要指定行为或方法(应用于类的对象)，还需要指定属性和数据成员(每个对象都会包含)。编写类有两个要素：定义类本身和定义类的方法。</strong></p></blockquote><hr><h4 id="2-1类定义"><a href="#2-1类定义" class="headerlink" title="2.1类定义"></a>2.1类定义</h4><blockquote><p>下面开始尝试编写一个简单的 SpreadsheetCell 类，其中每个单元格都只存储一个数字：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpreadsheetCell</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(<span class="hljs-type">double</span> inValue)</span></span>;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">double</span> mValue;<br>&#125;;<br></code></pre></td></tr></table></figure><p>每个类定义都以关键字 class 和 类名 开始。类定义是一条 C++ 语句，因此必须用分号结束。如果类定义结束时，不使用分号，编译器将给出几个错误，这些错误十分模糊，似乎与缺少分号毫不相干。</p><p>类定义所在的文件通常根据类命名。例如， SpreadsheetCell 类定义可放在 SpreadsheetCell.h 文件中。这并不是一条强制规则，可用自己喜欢的名称命名文件。</p><ol><li><p><strong>类的成员：</strong></p><p><strong>类可以有许多成员，可以是：成员函数(方法、构造函数或者析构函数)，成员变量(也成为数据成员)、成员枚举、类型别名和嵌套类等。</strong></p><p>下面两行声明了类支持的方法，这类似于函数原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(<span class="hljs-type">double</span> inValue)</span></span>;<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br></code></pre></td></tr></table></figure><p><strong>需要指出：最好将不改变对象的成员函数声明为 const。</strong></p><p>下面这行声明了类的数据成员，看上去有点像变量的声明。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">double</span> mValue;<br></code></pre></td></tr></table></figure><p>类定义的成员函数和数据成员，但它们只作用于类的特定实例，也就是对象。这条规则的唯一例外就是静态成员，参见第九章。类定义概念，对象包含实际的位。因此，每个对象都会包含自己的 mValue 变量值。成员函数的实现被所有对象共享，类可以包含任意数量的成员函数和数据成员。成员函数和数据成员不能同名。  </p></li><li><p>访问控制：</p><blockquote><p>类中的每个方法和成员都可用三种访问说明符(access specifiers)之一来说明：public、protected 或 private。访问说明符将应用于其后声明的所有成员，直到遇到另一个访问说明符。在 SpreadsheetCell 类中，setValue() 和 getValue() 方法是公有访问的，而 mValue 数据成员是私有访问的。</p><p>类的默认访问说明符是：private，即在第一个访问说明符之前声明的所有成员的访问都是私有的。例如，将 public 访问说明符转移到 setValue() 方法声明的下方， setValue() 方法就会称为私有访问而不是公有访问。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpreadsheetCell</span><br>&#123;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(<span class="hljs-type">double</span> inValue)</span></span>;<span class="hljs-comment">// now has private access</span><br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">double</span> mValue;<br>&#125;;<br></code></pre></td></tr></table></figure><p>与类相似，C++ 中的结构(struct)也可拥有方法。实际上，唯一的区别就是结构的默认访问说明符是：public，而类的默认是：private。例如，SpreadsheetCell 类可以用就够重写，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SpreadsheetCell</span><br>&#123;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(<span class="hljs-type">double</span> inValue)</span></span>;<br><span class="hljs-function">doubel <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">double</span> mValue;<br>&#125;;<br></code></pre></td></tr></table></figure><p>如果只需要一组可供公共访问的数据成员，没有方法或方法数量极少，习惯上用 struct 替代 class。一个简单的 struct 的示例是用于存储点坐标的结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span><br>&#123;<br><span class="hljs-type">double</span> x;<br><span class="hljs-type">double</span> y;<br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>下表给出了三种访问说明符的含义：</strong></p><p><strong>私密性强到弱：private &gt; protected &gt; public</strong></p><p><strong>友元可以破坏这种私密性，使得 上述成员都可访问；</strong></p><p><img src="D:/tem/Lvo4ErQOS3s5RFb.png" alt="image-20240225032900275"></p></blockquote></li><li><p>声明顺序：</p><p>可使用任何顺序声明成员和访问控制说明符：C++ 没有施加任何限制，例如 成员函数在数据成员之前，或者 public 在 private 之前。此外，可重复使用访问说明符。这没什么说的。</p></li><li><p>类内成员初始化器：</p><p>可直接在类定义中初始化成员变量。例如，默认情况下，在 SpreadsheetCell 类定义中直接将 mValue 初始化为 0，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpreadsheetCell</span><br>&#123;<br>    <span class="hljs-comment">// Remainder of the class definition omitted for brevity.</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> mValue;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol></blockquote><hr><h4 id="2-2定义方法"><a href="#2-2定义方法" class="headerlink" title="2.2定义方法"></a>2.2定义方法</h4><blockquote><p>前面的 SpreadsheetCell 类的定义足以创建类的对象。然而，如果试图调用 setValue() 或 getValue() 方法，链接器将发出警告，因为方法没有实现定义。这是因为类定义指明了方法的原型，但是没有定义方法的是实现。与编写独立的函数的原型和定义类似，必须编写方法的原型和定义。注意，类定义必须在方法定义之前。通常类定义在头文件中，方法定义在包含头文件的源文件中。下面是 SpreadsheetCell 类中两个方法的定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;SpreadsheetCell&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SpreadsheetCell::setValue</span><span class="hljs-params">(<span class="hljs-type">double</span> inValue)</span></span><br><span class="hljs-function"></span>&#123;<br>mValue = inValue;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SpreadsheetCell::getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> mValue;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：每个方法名前都出现了类名和两个冒号(作用域解析运算符(scope resolution operator))。在此环境中，这个语法告诉编辑器，要定义的 setValue() 方法是 SpreadsheetCell 类的一部分。此外还要注意，定义方法时，不要重复使用访问说明符。</p><p>注意：</p><blockquote><p>如果使用 Microsoft Visual C++ IDE，会发现默认情况下，所有源文件都以 #include “stdafx.h” 开始。</p><p>在 Visual C++ 项目中，默认情况下，每个文件都应该以这一行开始，自己包含的文件必须在这一行后面。如果将自己包含的文件放在 stdafx.h 之前，这一行就会失效，编译器会给出各种错误。对预编译的头文件概念的说明超出了这本书的范围，更多看关于预编译头文件的 Microsoft 文档。</p></blockquote><ol><li><p>访问数据元素</p><p>类的非静态方法，例如 setValue() 和 getValue()，总是在类的特定对象上执行。在类的方法体中，可以访问对象所属类的所有数据成员。在前面的 setValue() 定义中，无论哪种对象调用这个方法，下面这行代码都会改变 mValue 变量的值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">mValue = inValue；<br></code></pre></td></tr></table></figure><p>如果两个不同的对象调用 setValue()，这行代码(对每个对象执行一次)会改变两个不同对象内的变量值。</p></li><li><p>调用其他方法</p><p>内部的某个方法可调用其他方法，考虑扩展后的 SpreadsheetCell 类。实际的电子表格应用程序允许在单元格中保存文本数据和数字。试图将文本单元格解释为数字时，电子表格会试着将文本转换为数字。如果这个文本不能代表一个有效的值，单元格的值会被忽略。在这个程序中，非数字的字符串会生成值为 0 的单元格。为让 SpreadsheetCell 支持文本数据，下面对类定义进行修改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string_view&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpreadsheetCell</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(<span class="hljs-type">double</span> inValue)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setString</span><span class="hljs-params">(std::string_view inString)</span></span>;<br>    <span class="hljs-function">std::string <span class="hljs-title">getString</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function">std::string <span class="hljs-title">doubleToString</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">double</span>&amp; inValue)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">stringToDouble</span><span class="hljs-params">(std::string_view inString)</span> <span class="hljs-type">const</span></span>;<br>    <span class="hljs-type">double</span> mValue;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个类版本只能存储 double 数据。如果客户将数据设置为 string，数据就会转换为 double。如果文本不是有效数字，就将 double 值设置为 0.0。这个类定义显示了两个设置并获取单元格文本的新方法，还有两个新的用于将 double 转换为 string、将 string 转换为 double 的私有帮助方法。下面是这些方法的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;SpreadsheetCell.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SpreadsheetCell::setValue</span><span class="hljs-params">(<span class="hljs-type">double</span> inValue)</span></span><br><span class="hljs-function"></span>&#123;<br>    mValue = inValue;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">SpreadsheetCell::getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> mValue;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SpreadsheetCell::setString</span><span class="hljs-params">(std::string_view inString)</span></span><br><span class="hljs-function"></span>&#123;<br>    mValue = <span class="hljs-built_in">stringToDouble</span>(inString);<br>&#125;<br><br><span class="hljs-function">std::string <span class="hljs-title">SpreadsheetCell::getString</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">doubleToString</span>(mValue);<br>&#125;<br><span class="hljs-comment">// 不要用 std::string_view 作为返回值，一般情况下都不好。</span><br><span class="hljs-comment">// 因为 std::string_view 是 一个对 【现有的】 string 的引用</span><br><span class="hljs-comment">// 而一般情况下，我们都是在函数内部得到的一个局部 string 变量，在执行完函数后就销毁了，没法再引用了</span><br><span class="hljs-comment">// 这种情况下，使用之后学习的 RVO,也就是 Return Value Optimization,返回值优化，也称为 复制省略</span><br><br><span class="hljs-function">std::string <span class="hljs-title">SpreadsheetCell::doubleToString</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">double</span>&amp; inValue)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">to_string</span>(inValue);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">SpreadsheetCell::stringToDouble</span><span class="hljs-params">(std::string_view inString)</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">strtod</span>(inString.<span class="hljs-built_in">data</span>(), <span class="hljs-literal">nullptr</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><p>​doubleToString() 方法的这种实现方式，例如，将值 6.1 转换为 6.100000。但由于这是一个私有帮助方法，因此不必修改任何客户代码即可实现该实现。</p></li><li><p>this 指针</p><p>每个普通方法调用都会传递一个指向对象的指针，这就是称为 “隐藏” 参数的 this 指针，使用这个指针可访问数据成员或调用方法，也可将其传递给其他方法或函数。有时还用它来消除名称的歧义。例如，可使用 value 而不是 mValue 作为 SpreadsheetCell 类的数据成员，用 value 而不是 inValue 作为 setValue() 方法的参数。在此情景下，setValue() 如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SpreadsheetCell::setValue</span><span class="hljs-params">(<span class="hljs-type">double</span> value)</span></span><br><span class="hljs-function"></span>&#123;<br>    value = value;<span class="hljs-comment">// Ambiguous!</span><br>&#125;<br></code></pre></td></tr></table></figure><p>明显上述代码存在歧义，而这个歧义一般情况下，会编译成功，而且不会有任何警告或错误信息，但得到的结果绝对不是我们所期望看到的。</p><p>未避免歧义，就可以使用 this 指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SpreadsheetCell::setValue</span><span class="hljs-params">(<span class="hljs-type">double</span> value)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">this</span>-&gt;value = value;<br>&#125;<br>      <br><span class="hljs-comment">// 然而，如果遵循第 3 章所讲述的命名规则，那么永远不会遇到这样的问题</span><br></code></pre></td></tr></table></figure><p>如果方法的某个对象调用了某个函数(或方法)，而这个函数采用指向对象的指针作为参数，就可以使用 this 指针调用这个函数。例如，假定编写了一个独立的 printCell() 函数(不是方法)，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printCell</span><span class="hljs-params">(<span class="hljs-type">const</span> SpreadsheetCell&amp; cell)</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; cell.<span class="hljs-built_in">getCell</span>() &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果想要用 setValue() 调用 printCell()，就必须将 *this 指针作为参数传给 printCell()，这个指针指向 setValue() 操作的 SpreadsheetCell 对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SpreadsheetCell::setValue</span><span class="hljs-params">(<span class="hljs-type">double</span> value)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">this</span>-&gt;value = value;<br>    <span class="hljs-built_in">printCell</span>(*<span class="hljs-keyword">this</span>);<span class="hljs-comment">// 对 this 指针解引用 得到 this 指针所指对象，得到方法的操作对象</span><br>    <span class="hljs-comment">// 从某种角度说，this 指针相当于是一种间接的传引用方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><p>​上述问题将在之后被重载运算符取代，因为更简洁方便：重载 &lt;&lt; 后，即可使用下面的行输出 SpreadsheetCell：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::cout &lt;&lt; *<span class="hljs-keyword">this</span> &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure></li></ol></blockquote><hr><h4 id="2-3使用对象"><a href="#2-3使用对象" class="headerlink" title="2.3使用对象"></a>2.3使用对象</h4><blockquote><p>以前面的 SpreadsheetCell 类为例，它事实上没有创建任何类，而是建筑它的蓝图。但是绘制蓝图并没有创建任何对象，对象必须依据蓝图在后面进行创建。</p><p>但是使用类就代表着，存在两种方式的使用：在堆栈中和在堆中使用。</p><ol><li><p>堆栈中的对象：</p><p>下面的代码在堆栈中创建并使用了 SpreadsheetCell 对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++">SpreadsheetCell myCell, anotherCell;<br><span class="hljs-built_in">myCellsetValue</span>(<span class="hljs-number">6</span>);<br>anotherCell.<span class="hljs-built_in">setValue</span>(<span class="hljs-string">&quot;3.2&quot;</span>);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;cell 1 : &quot;</span> &lt;&lt; myCell.<span class="hljs-built_in">getValue</span>() &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;cell 2 : &quot;</span> &lt;&lt; anotherCell.<span class="hljs-built_in">getValue</span>() &lt;&lt; std::endl;<br><br><span class="hljs-comment">// 输出为：</span><br>cell <span class="hljs-number">1</span> : <span class="hljs-number">6</span><br>cell <span class="hljs-number">2</span> : <span class="hljs-number">3.2</span><br></code></pre></td></tr></table></figure></li><li><p>堆中的对象：</p><ul><li><p>使用 new 方法动态分配对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">SpreadsheetCell* myCellp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ShpreadsheetCell</span>();<br>myCellp-&gt;<span class="hljs-built_in">setValue</span>(<span class="hljs-number">3.7</span>);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;cell 1 : &quot;</span> &lt;&lt; myCellp-&gt;<span class="hljs-built_in">getValue</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; myCellp-&gt;<span class="hljs-built_in">getString</span>() &lt;&lt; std::endl;<br><span class="hljs-keyword">delete</span> myCellp;<br>myCellp = <span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">-&gt;      &lt;==&gt;().<br></code></pre></td></tr></table></figure></li><li><p>使用 智能指针 分配对象：</p><p>就如同必须释放对中分配的其他内存一样，也必须使用 delete 释放对象所占据的内存，为避免发生内存错误，强烈建议使用智能指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> myCellp = <span class="hljs-built_in">make_nuique</span>&lt;SpreadsheetCell&gt;();<br><span class="hljs-comment">// Equivalent to:</span><br><span class="hljs-comment">// unique_ptr&lt;SpreadsheetCell&gt; myCell(new SpreadsheetCell());</span><br>myCellp-&gt;<span class="hljs-built_in">setVale</span>(<span class="hljs-number">3.7</span>);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;cell 1 : &quot;</span> &lt;&lt; myCellp-&gt;<span class="hljs-built_in">getValue</span>() &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; myCellp-&gt;<span class="hljs-built_in">getValue</span>() &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure><p>警告：</p><ul><li><p>如果用 new 为某个对象分配内存，那么使用完对象后，要用 delete 销毁对象，或者使用智能指针自动管理内存。</p></li><li><p>如果没有使用智能指针，当删除指针所指的对象时，最好将指针重置为 null。 这并非强制要求，但这样做可以防止在删除对象后意外使用这个指针，以便于调试。</p></li></ul></li></ul></li></ol></blockquote><hr><h3 id="8-3对象的生命周期"><a href="#8-3对象的生命周期" class="headerlink" title="8.3对象的生命周期"></a>8.3对象的生命周期</h3><blockquote><p><strong>对象的生命周期涉及三个活动：</strong></p><ol><li><strong>创建</strong></li><li><strong>销毁</strong></li><li><strong>赋值</strong></li></ol><p>理解对象什么时候被创建、销毁、赋值，以及如何定制这些行为很重要。</p><p><strong>下面的自动生成的 拷贝构造函数 和 复制赋值运算符 均为浅拷贝，深拷贝需要自行构造。</strong></p></blockquote><hr><h4 id="3-1创建对象"><a href="#3-1创建对象" class="headerlink" title="3.1创建对象"></a>3.1创建对象</h4><blockquote><ol><li><strong>分配内存空间：</strong> 首先，需要为对象分配内存空间。这包括对象的数据成员、虚表指针（对于包含虚函数的类），以及可能的填充字节。</li><li><strong>调用构造函数：</strong> 执行对象的构造函数，进行对象的初始化。构造函数负责设置对象的数据成员，确保对象处于有效的初始状态。</li><li><strong>执行成员初始化列表：</strong> 如果在类的构造函数中使用了成员初始化列表，那么在构造函数体执行之前，成员初始化列表中的初始化操作会被执行。</li><li><strong>执行构造函数体：</strong> 构造函数体中的代码会按照书写顺序被执行，可以包括其他的初始化逻辑和操作。</li></ol></blockquote><blockquote><p>在声明对象(如果是在堆栈中)或使用 new、new[] 或智能指针显式分配空间时，就会创建对象。当创建对象时，会同时内嵌的对象。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCalss</span><br>&#123;<br><span class="hljs-keyword">private</span>:<br>std::string mName;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>MyClass obj;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 main() 函数中，创建 MyClass 对象时，同时创建内嵌的 string 对象，当包含它的对象被销毁时，string 也被销毁。</p><p>在声明变量时，最好给它们赋初始化值 。例如，通常应该将 int 变量初始化为 0；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> x = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>与此类似，也应该初始化对象。声明并编写一个名为构造函数的方法，可以提供这一功能，在构造函数中可以执行对象的初始化任务。无论任何时候创建对象，都会执行其构造函数。</p><p><strong>注意：</strong></p><p>​<strong>C++ 程序员有时将构造函数称为 ctor;</strong></p><ol><li><p><strong>编写构造函数</strong></p><p>从语法上，构造函数是与类同名的方法。构造函数没有返回类型，可以有也可以没有参数，没有参数的构造函数称为默认构造函数。可以是无参构造函数，也可以让所有参数都使用默认值。许多情况下，都必须提供默认构造函数，如果不提供，就会导致编译器错误，默认构造函数将在稍后讨论。</p><p>下面试着在 SpreadsheetCell 类中添加一个构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpreadsheetCell</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SpreadsheetCell</span>(<span class="hljs-type">double</span> initialValue);<br>    <span class="hljs-comment">// Remainder of the class definition omitted for brevity</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>必须提供普通方式的实现一样，也必须提供构造函数的实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">SpreadsheetCell::<span class="hljs-built_in">SpreadsheetCell</span>(<span class="hljs-type">double</span> initialValue)<br>&#123;<br>    <span class="hljs-built_in">setValue</span>(initialValue);<br>&#125;<br></code></pre></td></tr></table></figure><p>SpreadsheetCell 构造函数是 SpreadsheetCell 类的一个成员，因此 C++ 在构造函数的名称之前要求正常的 SpreadsheetCell:: 作用域解析。由于构造函数本身的名称也是 SpreadsheetCell，因此代码的 SpreadsheetCell::SpreadsheetCell 结尾看起来有点很好笑。这个现实只是简单地调用了 setValue() 方法。</p></li><li><p><strong>使用构造函数</strong></p><p>构造函数用来创建并初始化其值。在基于堆栈和堆进行分配时可以使用构造函数。</p><ul><li><p><strong>在堆栈中分配 SpreadsheetCell 对象时，可这样使用构造函数：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">SpreadsheetCell <span class="hljs-title">myCell</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span>, <span class="hljs-title">anotherCell</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;cell 1 : &quot;</span> &lt;&lt; myCell.<span class="hljs-built_in">getValue</span>() &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;cell 2 : &quot;</span> &lt;&lt; another.<span class="hljs-built_in">getValue</span>() &lt;&lt; std::endl;<br><br><span class="hljs-comment">// 注意！不要显式地调用 SpreadsheetCell 构造函数。例如，不要使用下面的做法：</span><br>SpreadsheetCell myCell.<span class="hljs-built_in">SpreadsheetCell</span>(<span class="hljs-number">5</span>);<span class="hljs-comment">// Will Not Compile!</span><br><br><span class="hljs-comment">// 同样，在后来也不能调用构造函数。下面的代码也是不正确的：</span><br>SpreadsheetCell myCell;<br>myCell.<span class="hljs-built_in">SpreadsheetCell</span>(<span class="hljs-number">5</span>);<span class="hljs-comment">// Will Not Compile!</span><br></code></pre></td></tr></table></figure></li><li><p>在堆中使用构造函数</p><p>当动态分配 SpreadsheetCell 对象时，可这样使用构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> smartCellp = <span class="hljs-built_in">make_unique</span>&lt;SpreadsheetCell&gt;(<span class="hljs-number">4</span>);<br><span class="hljs-comment">// ... do something with the cell, no need to delete the smart pointer.</span><br>    <br><span class="hljs-comment">// Or with raw pointers, without smart pointers (not recommended)</span><br>SpreadsheetCell* myCellp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SpreadsheetCell</span>(<span class="hljs-number">5</span>);<br>SpreadsheetCell* anotherCellp = <span class="hljs-literal">nullptr</span>;<br>anotherCellp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SpreadsheetCell</span>(<span class="hljs-number">4</span>);<br><span class="hljs-comment">// ... do something with the cells</span><br><span class="hljs-keyword">delete</span> myCellp;<br>myCellp = <span class="hljs-literal">nullptr</span>;<br><span class="hljs-keyword">delete</span> anotherCellp;<br>anotherCellp = <span class="hljs-literal">nullptr</span>;<br>    <br><span class="hljs-comment">// 注意可以声明一个指向 SpreadsheetCell 对象的指针，而不立即调用构造函数。堆栈中对象在声明时会调用构造函数</span><br></code></pre></td></tr></table></figure><p>无论在堆栈中(在函数中)还是在类中(作为类的数据成员)声明指针，如果没有立即初始化指针，都应该像前面声明 anotherCellp 时一样，先将其初始化为 nullptr。如果不赋予 nullptr 值，指针就是未定义。意外地使用未定义的指针可能会导致无法预料的、难以诊断的内存问题。如果将指针初始化为 nullptr，在大多数操作环境下使用这个指针，都会引起内存访问错误，而不是难以预料的结果。</p><p>同样，要记得使用 new 动态分配的对象使用 delete，或者使用智能指针。</p></li></ul></li><li><p><strong>提供多个构造函数</strong></p><p>在一个类中可提供多个构造函数。所有构造函数的名称相同(类名)，但不同的构造函数具有不同数量的参数或者不同的参数类型。<strong>在 C++ 中，如果多个函数具有相同的名称，那么当调用时编译器会选择参数类型匹配的那个函数。这叫做重载，第 9 章将详细讨论。</strong></p><p>在 SpreadsheetCell 类中，编写两个构造函数是有益的：一个采用 double 初始值，另一个采用 string 初始值。下面的类型一具有两个构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpreadsheetCell</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SpreadsheetCell</span>(<span class="hljs-type">double</span> initialValue);<br>    <span class="hljs-built_in">SpreadsheetCell</span>(std::string_view initialValue);<br>    <span class="hljs-comment">// Remainder of the class definition omitted for brevity.</span><br>&#125;;<br><br>SpreadsheetCell::<span class="hljs-built_in">SpreadsheetCell</span>(std::string_view initialValue)<br>&#123;<br>    <span class="hljs-built_in">setString</span>(initialValue);<br>&#125;<br><br><span class="hljs-comment">// 下面是使用两个不同构造函数的代码：</span><br><span class="hljs-function">SpreadsheetCell <span class="hljs-title">aThirdCell</span><span class="hljs-params">(<span class="hljs-string">&quot;test&quot;</span>)</span></span>;<span class="hljs-comment">// Uses std::string_view ctor</span><br><span class="hljs-function">SpreadsheetCell <span class="hljs-title">aFourthCell</span><span class="hljs-params">(<span class="hljs-number">4.4</span>)</span></span>;<span class="hljs-comment">// Uses double-arg ctor</span><br><span class="hljs-keyword">auto</span> aFifthCellp = <span class="hljs-built_in">make_unique</span>&lt;SpreadsheetCell&gt;(<span class="hljs-string">&quot;5.5&quot;</span>);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;aThirdCell : &quot;</span> &lt;&lt; aThirdCell.<span class="hljs-built_in">getValue</span>() &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;aFourthCell : &quot;</span> &lt;&lt; aFourthCell.<span class="hljs-built_in">getValue</span>() &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;aFifthCellp : &quot;</span> &lt;&lt; aFifthCellp-&gt;<span class="hljs-built_in">getValue</span>() &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure><p>有一种很诱人的想法就是在构造函数中调用执行另一个构造函数，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">SpreadsheetCell::<span class="hljs-built_in">SpreadsheetCell</span>(std::string_view iinitialValue)<br>&#123;<br>    <span class="hljs-built_in">SpreadsheetCell</span>(<span class="hljs-built_in">stringToDouble</span>(initialValue));<br>&#125;<br></code></pre></td></tr></table></figure><p>这样看上去很合理，但是实际上，结果并不会像预期的那样显示的调用 SpreadsheetCell 构造函数实际上是新创建了一个 SpreadsheetCell 类型的临时未命名对象，而并不是像预期那样调用构造函数来初始化对象。</p><p>然而，由此出发 C++ 支持委托构造函数 (delegating constructors)，允许构造函数初始化器调用同一个类的其他构造函数进行初始化，这将在之后说明。</p></li><li><p><strong>默认构造函数</strong></p><p>默认构造函数没有参数，也称无参构造，是一种防御性编程，防止对未定义的数据元素进行调用的一种防范措施。</p><p><strong>什么时候需要默认构造函数？</strong></p><p>考虑一下对象数组。<strong>创建对象数组需要完成两个任务：为所有对象分配内存连续的空间，为每个对象调用默认构造函数。C++ 没有提供任何语法，来让创建的数组的代码直接调用不同的构造函数。</strong>例如，如果没有定义 SpreadsheetCell 类的默认构造函数，下面代码将无法编译：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">SpreadsheetCell cell[<span class="hljs-number">3</span>];<br>SpreadsheetCell* myCell = <span class="hljs-keyword">new</span> SpreadsheetCell[<span class="hljs-number">10</span>];<span class="hljs-comment">// All Falls</span><br></code></pre></td></tr></table></figure><p>对于基于堆栈的数组，可使用下面的初始化器，绕过这个限制：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">SpreadsheetCell cell[<span class="hljs-number">3</span>] = &#123;<span class="hljs-built_in">SpreadsheetCell</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">SpreadsheetCell</span>(<span class="hljs-number">23</span>), <span class="hljs-built_in">SpreadsheetCell</span>(<span class="hljs-number">41</span>)&#125;;<br></code></pre></td></tr></table></figure><p>但是，很明显，这并不是一种很优雅的解决方法，因为每个数组都需要手动输入。显然，采用构建默认构造函数的方法，来自动创建数组的方式更加高效。</p><p><strong>PS：如果想在标准库容器内(例如 std::vector)中存储类，那么同样需要默认构造函数。</strong></p><p>在其他类中创建对象时，也可以使用默认构造函数，本节中 “5. 构造函数初始化器” 中将讲解。</p><p><strong>如何编写默认构造函数？</strong></p><p>下面时具有默认构造函数的 SpreadsheetCell 类的部分定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpreadsheetCell</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SpreadsheetCell</span>();<br>    <span class="hljs-comment">// Remainder of the class definition omitted for brevity.</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>下面代码实现了默认构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">SpreadsheetCell::<span class="hljs-built_in">SpreadsheetCell</span>()<br>&#123;<br>mValue = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果 mValue 使用类内的初始化方式，则可以省略这个默认构造函数的一条语句：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">SpreadsheetCell::<span class="hljs-built_in">SpreadsheetCell</span>()<br>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>可在堆栈中使用默认构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">SpreadsheetCell myCell;<br>myCell.<span class="hljs-built_in">setValue</span>(<span class="hljs-number">6</span>);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;cell 1 : &quot;</span> &lt;&lt; myCell.<span class="hljs-built_in">getCell</span>() &lt;&lt; std::endl;<br><br><span class="hljs-comment">// 可能希望有人在堆栈中能够这样创建 默认构造函数：</span><br><span class="hljs-function">SpreadsheetCell <span class="hljs-title">myCell</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">// 但是，这种方式虽然能够编译，但是它后面的行将无法编译。</span><br></code></pre></td></tr></table></figure><p><strong>警告：</strong></p><p>​<strong>切勿在创建对象时，直接使用默认构造函数；而是使用类名，让类自动调用其构造函数，这两种逻辑很不同。</strong></p><p>对于堆中的对象，可以这样使用默认构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">auto</span> smartCellp = <span class="hljs-built_in">make_unique</span>&lt;SpreadsheetCell&gt;(<span class="hljs-number">4</span>);<br><span class="hljs-comment">// Or with a raw pointer (not recommended)</span><br>SpreadsheetCell* myCellp = <span class="hljs-keyword">new</span> SpreadsheetCell;<br><span class="hljs-comment">// Or </span><br><span class="hljs-comment">// SpreadsheetCell* myCellp = new SpreadsheetCell;</span><br><span class="hljs-comment">// ... use myCellp</span><br><span class="hljs-keyword">delete</span> myCellp;<br>myCellp = <span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></table></figure><p><strong>编译器生成的默认构造函数：</strong></p><p>本章的第一个 SpreadsheetCell 类定义如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpreadsheetCell</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(<span class="hljs-type">double</span> inValue)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">getValue</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> mValue;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这个类定义中没有声明任何默认构造函数，但以下代码仍可以正常运行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++">SpreadsheetCell myCell;<br>myCell.<span class="hljs-built_in">setValue</span>(<span class="hljs-number">8</span>);<br><span class="hljs-comment">// 当然，这是一种无参构造</span><br></code></pre></td></tr></table></figure><p>对比：</p><p><strong>如果这样类内仅有显式的含参构造，但是没有显式声明默认构造：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpreadsheetCell</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SpreadsheetCell</span>(<span class="hljs-type">double</span> inValue);<span class="hljs-comment">// No default constructor</span><br>    <span class="hljs-comment">// Remainder of the class definition omitted for brevity.</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>而使用这种定义，下面代码将无法编译：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">SpreadsheetCell myCell;<br>myCell.<span class="hljs-built_in">setValue</span>(<span class="hljs-number">6</span>);<br></code></pre></td></tr></table></figure><p>为什么会这样呢？原因在于：<strong>如果没有指定任何构造函数，编译器即会生成无参构造函数。</strong></p><p>类所有对象成员都可以调用编译器生成的默认构造函数，但不会初始化语言的原始类型，例如 int 和 double。</p><p><strong>如果显式地声明了默认构造函数或其他构造函数，编译器就不会再自动生成默认构造函数。</strong></p><p><strong>注意：</strong></p><p>​<strong>默认构造函数与无参构造函数是一回事。术语 “默认构造函数” 不仅仅是说如果没有声明任何构造函数就会自动生成一个构造函数；而且如果没有参数，构造函数就采用默认值。</strong></p><p><strong>显式的默认构造函数：</strong></p><p>​为了避免手动地编写默认构造函数，C++ 现在支持显式的默认构造函数 (explicitly defaulted constructor)。可按如下方法编写类的定义，而不需要在实现文件中实现默认构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpreadsheetCell</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SpreadsheetCell</span>() = <span class="hljs-keyword">default</span>;<span class="hljs-comment">// 显式声明自动生成的默认构造函数</span><br>    <span class="hljs-built_in">SpreadsheetCell</span>(<span class="hljs-type">double</span> initialValue);<br>    <span class="hljs-built_in">SpreadsheetCell</span>(std::string_view initialValue);<br>    <span class="hljs-comment">// Remainder of the calss definition omitted for brevity.</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>显式删除构造函数：</strong></p><p><strong>C++ 还支持显式删除构造函数 (explicitly delete constructors)。例如，可定义一个只有静态方法的类(具体参见第 9 章) ，这个类没有任何构造函数，也不想让编译器生成默认构造函数。</strong>在此情况下，可以显式地删除默认构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>() = <span class="hljs-keyword">delete</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>目的：不希望存在默认构造函数；如果构建，即报错；</strong></p></li><li><p><strong>构造函数初始化</strong></p><p>本章到目前为止都是在讨论：<strong>构造函数内初始化数据成员</strong>；</p><p>但 C++ 提供了另一种在构造函数中初始化数据成员的方法，叫做 构造函数初始化器 或 ctor-initializer。下面的代码提供了 ctor-initializer 语法重写了没有参数的 SpreadsheetCell 构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 早古方法：</span><br>SpreadsheetCell::<span class="hljs-built_in">SpreadsheetCell</span>(<span class="hljs-type">double</span> initialValue)<br>&#123;<br>    <span class="hljs-built_in">setValue</span>(initialValue);<br>&#125;<br><br><span class="hljs-comment">// 构造函数初始化器</span><br>SpreadsheetCell::<span class="hljs-built_in">SpreadsheetCell</span>(<span class="hljs-type">double</span> initialValue) : <span class="hljs-built_in">mValue</span>(iinitialValue)<br>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>构造函数初始化器的结构：</strong></p><p>​<strong>以冒号开始，以逗号分割；</strong></p><p><strong>使用 ctor-initializer 初始化数据成员与在构造函数体内初始化数据成员不同</strong>：</p><p>​<strong>当 C++创建某个对象时，必须在调用构造函数前创建对象的所有数据成员。</strong>如果数据成员本身就是对象，那么在创建这些数据成员时，必须其调用构造函数。<strong>在构造函数体内给某个对象赋值时，并没有真正创建这个对象，而只是改变对象的值。ctor-initializer 允许在创建数据成员时赋初值，这样做比在后面赋值效率高。</strong></p><p>如果类的数据成员是具有默认构造的类的对象，则不必再 ctor-initializer 中显式地初始化对象。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br><br>    <span class="hljs-built_in">MyClass</span>() <br>    &#123;<br>        <span class="hljs-comment">// 其他初始化逻辑</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    std::string myString;  <span class="hljs-comment">// std::string 默认构造函数将初始化为空字符串</span><br>&#125;;<br><span class="hljs-comment">/*对于类的数据成员，如果你没有在构造函数的初始化列表中为其提供初始值，而该类具有默认构造函数，那么默认构造函数会在对象创建时对成员进行初始化。*/</span><br></code></pre></td></tr></table></figure><p><strong>如果类的数据成员是没有默认构造函数的类的对象，则必须再 ctor-initializer；</strong></p><p>下面我们关注一下：</p><p>​如果类的数据成员是没有默认构造函数的类的对象，则必须在 ctor-initailizer 中显式初始化对象。例如，考虑下面的 SpreadsheetCell 类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpreadsheetCell</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SpreadsheetCell</span>(<span class="hljs-type">double</span> d);<br>&#125;;<br></code></pre></td></tr></table></figure><p>SomeClass 构造函数的构造和实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SomeClass</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SomeClass</span>();<br><br><span class="hljs-keyword">private</span>:<br>    SpreadsheetCell mCell;<br>&#125;;<br><br>SomeClass::<span class="hljs-built_in">SomeClass</span>() &#123;&#125;<br></code></pre></td></tr></table></figure><p>然而，这个实现无法成功完成编译代码。编译器不知道如何初始化 SomeClass 类的 mCell 数据成员，因为这个函数没有默认构造函数。</p><p>解决方案是在 ctor-initializer 中初始化 mCell 数据成员，示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">SomeClass::<span class="hljs-built_in">SomeClass</span>() : <span class="hljs-built_in">mCell</span>(<span class="hljs-number">1.0</span>) &#123;&#125;<br></code></pre></td></tr></table></figure><p>注意：</p><p>​ctor-initializer 允许在创建数据成员时，执行初始化。</p><p>某些程序员喜欢在构造函数中提供初始值(即使这样做效率不高)。然而，某些数据类型必须在 ctor-initializer 中或使用类内初始器进行初始化。如下图所示：</p><p><img src="D:/tem/X2YDxTJpBOiyEwf.png" alt="image-20240226103931273"></p><p>关于 ctor-initializer 要特别要注意，数据成员的初始化顺序为：按照它们在类定义中出现的顺序，而不是 ctor-initializer 中顺序。考虑下面的两个不同顺序造成的编译正确和错误的差异：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 正确顺序：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Foo</span>(<span class="hljs-type">double</span> value);<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> mValue;<br>&#125;;<br><br>Foo::<span class="hljs-built_in">Foo</span>(<span class="hljs-type">double</span> value) : <span class="hljs-built_in">mValue</span>(value)<br>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Foo::mValue = &quot;</span> &lt;&lt; mValue &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCalss</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">double</span> value);<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> mValue;<br>    Foo mFoo;<br>&#125;;<br><br>MyClass::<span class="hljs-built_in">MyClass</span>(<span class="hljs-type">double</span> value) : <span class="hljs-built_in">mValue</span>(value), <span class="hljs-built_in">mFoo</span>(mValue)<br>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass::mValue = &quot;</span> &lt;&lt; mValue &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-comment">// 首先，看 private 中的数据成员，这决定了初始化赋值的顺序：先 mValue, 再 mFoo;</span><br><span class="hljs-comment">// 其次，看 MyClass 的初始化器，将 mValue 初始化为 value， 然后将 mValue 传递给 mFoo 类型，进而调用其含参构造函数</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 错误顺序：</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Foo</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Foo</span>(<span class="hljs-type">double</span> value);<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">double</span> mValue;<br>&#125;;<br><br>Foo::<span class="hljs-built_in">Foo</span>(<span class="hljs-type">double</span> value) : <span class="hljs-built_in">mValue</span>(value)<br>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Foo::mValue = &quot;</span> &lt;&lt; mValue &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCalss</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">double</span> value);<br><br><span class="hljs-keyword">private</span>:<br>    Foo mFoo;<br>    <span class="hljs-type">double</span> mValue;<br>&#125;;<br><br>MyClass::<span class="hljs-built_in">MyClass</span>(<span class="hljs-type">double</span> value) : <span class="hljs-built_in">mValue</span>(value), <span class="hljs-built_in">mFoo</span>(mValue)<br>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass::mValue = &quot;</span> &lt;&lt; mValue &lt;&lt; std::endl;<br>&#125;<br><span class="hljs-comment">// 首先，看 private 中的数据成员，这决定了初始化赋值的顺序：先 mFoo, 再 mValue;</span><br><span class="hljs-comment">// 其次，看 MyClass 的初始化器，希望初始化 mFoo, 但是传入参数为未赋值量，因此出现编译错误</span><br></code></pre></td></tr></table></figure><p><strong>警告：</strong></p><p>​<strong>使用 ctor-initializer 初始化数据成员的顺序如下：按类定义中声明的顺序而不是 ctor-initializer 列表中的顺序。</strong></p></li><li><p><strong>复制构造函数</strong></p><p>通过传入 const 引用的形式，来对特定对象进行复制构造，其基本格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++">classname::<span class="hljs-built_in">classname</span>(<span class="hljs-type">const</span> classname&amp; src) : <span class="hljs-built_in">m1</span>(src.m1), <span class="hljs-built_in">m2</span>(src.m2), ..., <span class="hljs-built_in">mn</span>(src.mn) &#123;&#125;<br><span class="hljs-comment">// src 是 source 的意思，即源对象</span><br></code></pre></td></tr></table></figure><p>因此，多数情况下，不需要亲自编写构造函数。</p><p><strong>什么时候调用复制构造函数</strong>？</p><p><strong>隐式的复制构造函数：</strong></p><p>C++ 的默认传参方式是 值传递。这意味着函数或方法接受某个值或对象的副本。因此无论什么时候给函数或方法传递一个对象，编译器都会调用新对象的复制构造函数进行初始化。例如，假设以下 printString() 函数接收一个按值传入 string 参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">// 就是匿名对象或者匿名类型都是它的默认复制构造函数进行构造的</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printString</span><span class="hljs-params">(string inString)</span></span><br><span class="hljs-function"></span>&#123;<br>    std::cout &lt;&lt; inStirng &lt;&lt; std::endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>回顾一下，string 实际上是一个类，而不是内置类型。</p><p><strong>显式的复制构造函数：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">SpreadsheetCell <span class="hljs-title">myCell1</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;<br><span class="hljs-function">SpreadsheetCell <span class="hljs-title">myCell2</span><span class="hljs-params">(myCell1)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>不使用复制构造的按引用传递引用：</strong></p><p>提高效率而已。</p><p><strong>将复制构造函数定义为显式默认或显式删除</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">SpreadsheetCell</span>(<span class="hljs-type">const</span> SpreadsheetCell&amp; src) = <span class="hljs-keyword">default</span>;<br><span class="hljs-comment">// 将复制构造函数设置为默认复制构造</span><br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">SpreadsheetCell</span>(<span class="hljs-type">const</span> SpreadsheetCell&amp; src) = <span class="hljs-keyword">delete</span>;<br><span class="hljs-comment">// 将复制构造函数删除，达到禁止按 值传递 的作用，只能进行按引用传入</span><br><span class="hljs-comment">// 同样地，无法复制，使得对象作为函数 返回值</span><br></code></pre></td></tr></table></figure><p>这样的设计可能有以下几个目的：</p><ol><li><strong>防止意外的对象拷贝：</strong> 有时候，对象的拷贝可能是不希望的，特别是当对象包含资源管理的成员（例如动态分配的内存、文件句柄等）时。禁止拷贝构造函数可以确保在编译时防止这种不希望的拷贝。</li><li><strong>强调对象的唯一性：</strong> 有些类可能被设计成具有独特性，例如单例模式，禁止拷贝构造函数可以强调这种独特性，确保只有一个实例存在。</li><li><strong>提高性能：</strong> 某些情况下，通过禁止按值传递可以鼓励使用引用传递，避免了不必要的拷贝操作，提高了性能。</li></ol><p><strong>注意：</strong></p><p>​<strong>删除拷贝构造函数可能会限制类的使用方式，因此在实际应用中需要谨慎使用。在某些情况下，可以考虑使用移动语义（Move Semantics）和移动构造函数，以实现高效的对象传递和返回，而不是完全禁止值传递。</strong></p></li><li><p><strong>初始化列表构造函数 <initializer_list></strong></p><p><strong>初始化列表构造函数(initializer-list constructors) 将 std::initializer_list<T> 作为第一个参数，并没有任何其他参数(或者其他参数具有默认值)。在使用 std::iinitializer_list<T> 模板之前，必须要包含 <initializer_list> 头文件。下面的类演示了这种用法。该类只接受 initializer_list<T> ，元素个数应该为偶数，否则抛出。</strong>**</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdexcept&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;initializer_list&gt;</span> </span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EvenSequence</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 构造函数，接受一个双精度浮点数的初始化列表</span><br>    <span class="hljs-built_in">EvenSequence</span>(initializer_list&lt;<span class="hljs-type">double</span>&gt; args)<br>    &#123;<br>        <span class="hljs-comment">// 如果初始化列表的大小不是偶数，抛出异常</span><br>        <span class="hljs-keyword">if</span> (args.<span class="hljs-built_in">size</span>() % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-built_in">invalid_argument</span>(<span class="hljs-string">&quot;初始化列表应包含偶数个元素。&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 为序列预分配足够的空间</span><br>        mSequence.<span class="hljs-built_in">reserve</span>(args.<span class="hljs-built_in">size</span>());<br><br>        <span class="hljs-comment">// 遍历初始化列表，将元素添加到序列中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;value : args)<br>        &#123;<br>            mSequence.<span class="hljs-built_in">push_back</span>(value);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印序列的内容，dump 倾倒 的意思</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dump</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;value : mSequence)<br>        &#123;<br>            cout &lt;&lt; value &lt;&lt; <span class="hljs-string">&quot;, &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-comment">// 存储双精度浮点数的序列</span><br>    vector&lt;<span class="hljs-type">double</span>&gt; mSequence;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 创建一个包含偶数个元素的序列对象</span><br>    EvenSequence sequence1 = &#123;<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>&#125;;<br><br>    <span class="hljs-comment">// 打印序列内容</span><br>    sequence1.<span class="hljs-built_in">dump</span>();<br><br>    <span class="hljs-keyword">try</span><br>    &#123;<br>        <span class="hljs-comment">// 尝试创建一个包含奇数个元素的序列对象，将抛出异常</span><br>        EvenSequence sequence2 = &#123;<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>&#125;;<br>    &#125;<br>    <span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> exception &amp;e)<br>    &#123;<br>        <span class="hljs-comment">// 捕获异常并打印错误消息</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;异常捕获: &quot;</span> &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 输出：</span><br><span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>,<br>异常捕获: 初始化列表应包含偶数个元素。<br></code></pre></td></tr></table></figure><p><strong>标准库完全支持初始化列表构造函数</strong>，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++">std::vector&lt;std::string&gt; myVec = &#123;<span class="hljs-string">&quot;String 1&quot;</span>, <span class="hljs-string">&quot;String 2&quot;</span>, <span class="hljs-string">&quot;String 3&quot;</span>&#125;;<br><br><span class="hljs-comment">// 如果不使用初始化构造免责可以通过库内方法进行初始化：</span><br>std::vector&lt;std::string&gt; myVec;<br>myVec.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;String 1&quot;</span>);<br>myVec.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;String 2&quot;</span>);<br>myVec.<span class="hljs-built_in">push_back</span>(<span class="hljs-string">&quot;String 3&quot;</span>);<br></code></pre></td></tr></table></figure><p><strong>初始化列表不限于构造函数，还可用于普通函数，如第1章 所述。</strong></p></li><li><p><strong>委托构造函数</strong></p><p>委托构造函数 (delegating constructors) 允许构造函数调用同一个类的其他构造函数。然而，这个调用不能放在构造函数体，而必须放在构造函数初始化器中，而且必须是列表中唯一的初始化器。下面给出了一个示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">SpreadsheetCell::<span class="hljs-built_in">SpreadsheetCell</span>(std::string_view initialValue)<br> : <span class="hljs-built_in">SpreadsheetCell</span>(<span class="hljs-built_in">stringToDouble</span>(intialValue))<br>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>当调用这个 std::string_view 构造函数(委托构造函数)时，首先将调用委托给目标构造函数，也就是 double 构造函数。当目标构造函数返回是，再执行委托构造函数。</p><p>当使用委托构造函数时，要注意避免出现构造函数的递归。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span><br>&#123;<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">char</span> c) : <span class="hljs-built_in">MyClass</span>(<span class="hljs-number">1.2</span>) &#123; &#125;<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">double</span> d) : <span class="hljs-built_in">MyClass</span>(<span class="hljs-string">&#x27;m&#x27;</span>) &#123; &#125;<br>&#125;;<br><span class="hljs-comment">// 第一个构造函数委托第二个构造函数，第二个构造函数又委托第一个构造函数。</span><br><span class="hljs-comment">// C++ 没有定义这种代码的行为，这完全取决于编译器。</span><br></code></pre></td></tr></table></figure></li><li><p><strong>总结编译器生成的构造函数</strong></p><p><strong>编译器为每个类自动生成没有参数的构造函数和复制构造函数。然而，编译器自动生成的构造函数取决于你自己定义的构造函数，对应规则如下：</strong></p><p><img src="D:/tem/rVSMPiFjDExesdO.png" alt="image-20240226134735142"></p><p><strong>注意：默认构造函数和复制构造函数之间缺少对称性。</strong></p><ul><li><p><strong>只要没有显式定义复制构造函数，编译器就会自动生成一个。</strong></p></li><li><p><strong>只要定义了任何构造函数，编译器就不会生成默认构造函数。</strong></p><ul><li><strong>复制构造函数也是构造函数。</strong></li><li><strong>可以通过构造函数定义为显示默认或显式删除来影响自动生成的默认构造函数和默认复制构造函数。</strong></li></ul></li></ul><p><strong>注意：</strong></p><ul><li><strong>构造函数的最后一种是移动构造函数，用于实现移动语义，移动语义，可用于某些情况下提高性能，详见第 9 章。</strong></li></ul></li></ol></blockquote><hr><h4 id="3-2销毁对象"><a href="#3-2销毁对象" class="headerlink" title="3.2销毁对象"></a>3.2销毁对象</h4><blockquote><p>当销毁对象时，会发生两件事：</p><ul><li><strong>调用对象的析构函数；</strong></li><li><strong>释放对象占用的内存；</strong></li></ul><p><strong>在析构函数中可以执行对象的清理，例如，释放动态分配的内存或关闭文件句柄。如果没有声明析构函数，编译器将自动生成一个，析构函数会逐一销毁成员，然后删除对象。第9章的 9.2 节将介绍如何编写析构函数。</strong></p><p>当堆栈中的对象超出作用域时，意味着当前的函数、方法或其他执行代码块结束，对象会被销毁。换句话说，当代码遇到结束大括号时，这个大括号中所有创建在堆栈中的对象都会被销毁。下面的程序显示了这个行为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">SpreadsheetCell <span class="hljs-title">myCell</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>    <span class="hljs-keyword">if</span> (myCell.<span class="hljs-built_in">getValue</span>() == <span class="hljs-number">5</span>)<br>    &#123;<br>        <span class="hljs-function">SpreadsheetCell <span class="hljs-title">anotherCell</span><span class="hljs-params">(<span class="hljs-number">6</span>)</span></span>;<br>    &#125;<br>    <span class="hljs-comment">// anotherCell is destroyed as this block ends.</span><br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;myCell : &quot;</span> &lt;&lt; myCell.<span class="hljs-built_in">getValue</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// myCell is destroyed as this block ends.</span><br></code></pre></td></tr></table></figure><p>堆栈中对象的销毁顺序与声明顺序(和构建顺序)相反。例如，在下面的代码片段中，myCell2 在 anotherCell2 之前分配，因此 anotherCell2 在 myCell2 之前销毁(注意在程序中，可以使用大括号在任意点开始新的代码块)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C++">&#123;<br>    <span class="hljs-function">SpreadsheetCell <span class="hljs-title">myCell2</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;<br>    <span class="hljs-function">SpreadsheetCell <span class="hljs-title">anotherCell2</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>    <span class="hljs-comment">// myCell2 constructed before anotherCell2</span><br>&#125;<br><span class="hljs-comment">// anotherCell2 destroyed before myCell2</span><br></code></pre></td></tr></table></figure><p><strong>如果某个对象是其他对象的数据成员，这一顺序也使用。数据成员的初始化顺序是它们在类中声明的顺序。因此，按对象的销毁顺序与创建顺序相反这一规则，数据成员对象的销毁顺序与其在类中声明的顺序相反。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C++">&#123;<br>SpreadsheetCell* cellPtr1 = <span class="hljs-keyword">new</span> SpreadsheetCell;<br>SpreadsheetCell* cellPtr2 = <span class="hljs-keyword">new</span> SpreadsheetCell;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;cellPtr1 : &quot;</span> &lt;&lt; cellPtr1-&gt;<span class="hljs-built_in">getValue</span>() &lt;&lt; std::endl;<br><span class="hljs-keyword">delete</span> cellPtr1;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// cellPtr2 is NOT destroyed because delete was not called on it.</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>​<strong>析构函数的生成和调用在C++中是由系统自动管理的，通常不需要显式地删除。</strong></p></blockquote><hr><h4 id="3-3对象赋值"><a href="#3-3对象赋值" class="headerlink" title="3.3对象赋值"></a>3.3对象赋值</h4><blockquote><p>就像 string 变量可以给 另一个 string 变量赋值一样，在 C++ 内也可将一个对象的值赋给另一个对象。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">SpreadsheetCell <span class="hljs-title">myCell</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span>, anotherCell</span>;<br>anotherCell = myCell;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>​<strong>赋值不是复制，复制只发生在构造函数中，赋值发生在上述情况。</strong></p><p><strong>C++ 为所有类提供了执行赋值的方法。这个方法叫作 赋值运算符(assignment operator)，名称是 operator&#x3D;，因此实际上为类重载了 &#x3D; 运算符。自动默认构造这种赋值运算符。上例中，调用了 anotherCell 的赋值运算符，参数为 myCell。</strong></p><p><strong>注意：</strong></p><p>​<strong>本章所讲的赋值运算符有时也称为复制赋值运算符(copy assignment operator)，因为在赋值后，左边和右边都继续存在。之所以要这样区分，是因为由移动赋值运算符(move assignment operator)。为提高性能，当赋值结束后右边的对象会被销毁。移动赋值运算符将在第9章。</strong></p><p>​<strong>如果没有编写自己的赋值运算符，C++ 将自动生成一个，从而允许将对象赋给另一个对象，默认的 C++ 赋值行为几乎与默认复制行为相同：以递归方式用源对象的每个数据成员并赋值给目标对象。</strong></p><ol><li><p><strong>声明赋值预算符</strong></p><p>下面是 SpreadsheetCell 类的赋值运算符：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SpreadsheetCell</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br>    SpreadsheetCell&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> SpreadsheetCell&amp; rhs);<br>    <span class="hljs-comment">// Remainder of the class definition omitted for brevity.</span><br>    <span class="hljs-comment">// 在此情况下，将源文件称为 rhs，代表等号的“右边”(可为其指定其他任何名称)</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>赋值运算符与复制构造函数类似，采用了源文件的 const 引用。调用赋值运算符的对象在等号的左边。</p><p>与复制构造函数不同的是，赋值运算符返回 SpreadsheetCell 对象的引用。原因是赋值可以链接在一起，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">myCell = anotherCell = aThirdCell;<br></code></pre></td></tr></table></figure><p>执行这一行时，首先给 anotherCell 调用赋值运算符，aThirdCell 是“右边”的参数。随后给 myCell 调用赋值运算符。然而，此时 anotherCell 并不是参数。右边的值是将 aThirdCell 赋值给 anotherCell 时赋值运算符的返回值。如果赋值运算符不返回结果，myCell 将无法赋值。</p><p>为什么 mCell 的赋值运算符不能将 anotherCell 当作参数？就是说，为什么上述代码是那样的执行顺序？原因是等号实际上是方法调用的缩写，而完整函数是如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">myCell.<span class="hljs-keyword">operator</span>=(anotherCell.<span class="hljs-keyword">operator</span>=(aThirdCell));<br></code></pre></td></tr></table></figure><p>现在可以看到， anotherCell 调用的 operator&#x3D; 必须返回一个值，这个值会传递给 myCell 调用的 operator&#x3D;。正确的返回值是 anotherCell 本身，这样它就可以赋值给 myCell 的源对象。然而，直接返回 anotherCell 的效率不高，因此返回对 anotherCell 的引用。</p><p><strong>警告：</strong></p><p>​<strong>实际上可以让赋值运算符返回任意类型，包括 void。然而，应该返回被调用对象的引用。</strong></p></li><li><p><strong>定义赋值运算符</strong></p><p>赋值运算符的实现与复制构造函数类似，但是存在重大区别。首先，复制构造函数只有才初始化时才调用，此时目标对象还没有有效的值。赋值运算符可以改写对象的当前值。在为对象动态分配内存之前，可以不考虑这个问题，第9章将讨论这些问题。其次，在C++ 中允许将对象的值赋给自己，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">SpreadsheetCell <span class="hljs-title">cell</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;<br>cell = cell;<span class="hljs-comment">// Self-assignment</span><br></code></pre></td></tr></table></figure><p>赋值运算符不应该阻止自赋值。在 SpreadsheetCell 类中，这并不重要，因为它的唯一数据成员是基本类型 double。但当类具有动态分配的内存或其他资源时，必须将自赋值考虑在内。详细见 第9章。为组织此类情况发生，赋值运算符通常在方法开始时检测自赋值，如果发现自赋值，则立即返回。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C++">SpreadsheetCell&amp; SpreadsheetCell::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> SpreadsheetCell&amp; rhs)<br>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == &amp;rhs)<br>    &#123;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-comment">// 自赋值检查</span><br>        mValue = rhs.mValue;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">// 注意：即使这里是返回引用也不会形成参数之间的共值。</span><br><span class="hljs-comment">// 原因在于，即使返回传引用但还是在这个 operator= 的框架之下进行的赋值方法操作内对自身类内数据成员进行赋值。</span><br>    <span class="hljs-comment">// 之所以这里会有疑问，是因为有以下情况：</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    SpreadsheetCell* aCellp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">SpreadsheetCell</span>(<span class="hljs-number">5</span>);<br>    SpreadsheetCell* bCellp = <span class="hljs-keyword">new</span> SpreadsheetCell;<br><br>    bCellp-&gt;<span class="hljs-built_in">setValue</span>(<span class="hljs-number">3</span>);<br>    std::cout &lt;&lt; aCellp-&gt;<span class="hljs-built_in">getValue</span>() &lt;&lt; std::endl;<br>        std::cout &lt;&lt; bCellp-&gt;<span class="hljs-built_in">getValue</span>() &lt;&lt; std::endl;<br>    <span class="hljs-keyword">delete</span> bCellp;<br>    bCellp = aCellp;<br>    std::cout &lt;&lt; aCellp-&gt;<span class="hljs-built_in">getValue</span>() &lt;&lt; std::endl;<br>    std::cout &lt;&lt; bCellp-&gt;<span class="hljs-built_in">getValue</span>() &lt;&lt; std::endl;<br>    bCellp-&gt;<span class="hljs-built_in">setValue</span>(<span class="hljs-number">12</span>);<br>    std::cout &lt;&lt; aCellp-&gt;<span class="hljs-built_in">getValue</span>() &lt;&lt; std::endl;<br>    std::cout &lt;&lt; bCellp-&gt;<span class="hljs-built_in">getValue</span>() &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">delete</span> aCellp;<br>    aCellp = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">// 将指针设置为 nullptr，避免后续误用</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 输出：</span><br><span class="hljs-number">5</span><br>    <span class="hljs-number">3</span><br><span class="hljs-number">5</span><br><span class="hljs-number">5</span><br><span class="hljs-number">12</span><br><span class="hljs-number">12</span><br><br><span class="hljs-comment">// 很明显，你是混淆了 Python 中的 a = b; a copy b; a deepcopy b;的三种情况。</span><br>    <span class="hljs-comment">// a = b 在 Python 中，是一种指针拷贝；</span><br>        <span class="hljs-comment">// a copy b 在 Python 中，是一种浅拷贝；</span><br>    <span class="hljs-comment">// a deepcopy 在 Python 中，是一种深拷贝；</span><br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>​<strong>此处显示 SpreadsheetCell 赋值运算符只是为了演示目的。实际上，这种情况下，由于默认的由编译器生成的运算符已经足以满足要求，本可以省去这里的赋值运算符；它只是对所有数据成员进行 member-wise 赋值。然而在某些情况下，默认赋值运算符的功能不足。第 9 章将讲述这些情况。</strong></p></li><li><p><strong>显式地默认或删除赋值运算符</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">SpreadsheetCell&amp; SpreadsheetCell::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> SpreadsheetCell&amp; rhs) = <span class="hljs-keyword">default</span>;<br></code></pre></td></tr></table></figure> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">SpreadsheetCell&amp; SpreadsheetCell::<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> SpreadsheetCell&amp; rhs) = <span class="hljs-keyword">delete</span>;<br></code></pre></td></tr></table></figure></li></ol></blockquote><hr><h4 id="3-4编译器生成的赋值构造函数和复制赋值运算符"><a href="#3-4编译器生成的赋值构造函数和复制赋值运算符" class="headerlink" title="3.4编译器生成的赋值构造函数和复制赋值运算符"></a>3.4编译器生成的赋值构造函数和复制赋值运算符</h4><blockquote><p>在 C++11 中，如果类具有用户声明的复制赋值构造函数或析构函数，那么已经不赞成生成复制构造函数。如果在此类情况下仍然需要编译器生成的复制构造函数，可以显式指定 default：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">&gt;<span class="hljs-built_in">MyClass</span>(<span class="hljs-type">const</span> MyClass&amp; src) = <span class="hljs-keyword">default</span>;<br></code></pre></td></tr></table></figure><p>同样，在 C++11 中，如果类具有用户声明的复制赋值构造函数或析构函数，也不赞成生成复制赋值运算符。如果在此类情况下仍然需要编译器生成的复制赋值运算符，可以显式指定 default：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C++">&gt;MyClass&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyClass&amp; rhs) = <span class="hljs-keyword">default</span>;<br></code></pre></td></tr></table></figure></blockquote><hr><h4 id="3-5复制和赋值"><a href="#3-5复制和赋值" class="headerlink" title="3.5复制和赋值"></a>3.5复制和赋值</h4><blockquote><p>在堆栈中，其实赋值和复制都差不多。基本上，声明时会使用复制构造函数，赋值语句会使用赋值运算。考虑下面代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">SpreadsheetCell <span class="hljs-title">myCell</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br><span class="hljs-function">SpreadsheetCell <span class="hljs-title">anotherCell</span><span class="hljs-params">(myCell)</span></span>;<br><span class="hljs-comment">// anotherCell 由复制构造函数创建</span><br><br>SpreadsheetCell aThirdCell = myCell;<br><span class="hljs-comment">// aThirdCell 也是由复制构造函数创建的，因为这条语法是一个声明，不会调用到 operator=.</span><br><span class="hljs-comment">// 相当于下面代码的另一个版本：</span><br><span class="hljs-function">SpreadsheetCell <span class="hljs-title">aThirdCell</span><span class="hljs-params">(myCell)</span></span>;<br><br><span class="hljs-comment">// 但是，考虑以下代码：</span><br>anotherCell = myCell;<br><span class="hljs-comment">// 此时，anotherCell 已经构建，此时会调用 operator=</span><br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li><p><strong>声明时，只可能是 调用复制构造函数；</strong></p></li><li><p><strong>当对象已创建则 调用复制赋值运算符；</strong></p></li></ul><ol><li><p><strong>按值返回对象</strong></p><p>当函数或方法返回对象时，有时很难看出究竟执行了怎样的复制和赋值。例如，SpreadsheetCell::getString() 的实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">std::string <span class="hljs-title">SpreadsheetCell::getString</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">doubleToString</span>(mValue);<br>&#125;<br></code></pre></td></tr></table></figure><p>现在考虑以下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">SpreadsheetCell <span class="hljs-title">myCell</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>string s1;<br>s1 = myCell.<span class="hljs-built_in">getString</span>();<br></code></pre></td></tr></table></figure><p>当 getString() 返回 mString 时，编译器实际上调用了 <strong>string 复制构造函数</strong>，创建了一个未命名的临时字符串对象将结果，赋给 s1 时，会调用 <strong>s1 的赋值运算符</strong>，将这个临时字符串作为参数。然后，这个临时的字符串对象那个被销毁。因此，这行简单的代码会首先执行复制构造函数和复制构造对象(分别对 myCell.getString() 和 s1)。然而，编辑器可实现(有时需要实现)返回值优化(Return Value Optimization, RVO)，在返回值时优化掉成本高的复制构造函数，RVO 也被称为 复制省略(copy elision).</p><p>了解上述内容后，考虑之后的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function">SpreadsheeetCell <span class="hljs-title">myCell3</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>string s2 = myCell3.<span class="hljs-built_in">getString</span>();<br></code></pre></td></tr></table></figure><p>在此情况下，getString() 返回时，创建了一个临时的未命名字符串对象。但是现在调用的时复制构造函数而不是赋值赋值运算符。</p><p>通过移动语义(move semantics)，编译器可使用移动构造函数而不是复制构造函数，从 getStirng() 返回该字符串，这样做更高效。第 9 章将讨论移动语义。</p><p>如果忘记这些事情发生的顺序，或忘记调用哪个构造函数或运算符，只要在代码中临时包含帮助输出或调用调试器逐步调用代码，就能很容易找到答案。</p></li><li><p><strong>复制构造函数和对象成员</strong></p><p>还应注意构造函数中赋值和调用赋值构造函数的不同之处。如果某个对象包含其他对象，编译器生成的复制构造函数会递归调用每个被包含对象的复制构造函数。当编写自己的复制构造函数时，可使用前面所示的 ctor-initializer 提供相同的语义。如果在 ctor-initializer 中省略某个数据成员，在执行构造函数体内的diamagnetic之前，编译器将对该对象执行默认的初始化(为对象调用默认构造函数)。这样，在执行构造函数体时，所有数据成员都已初始化。</p><p>例如，可这样编写复制构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C++">SpreadsheetCell::<span class="hljs-built_in">SpreadsheetCell</span>(<span class="hljs-type">const</span> SpreadsheetCell&amp; src)<br>&#123;<br>    mVale = src.mValue;<br>&#125;<br></code></pre></td></tr></table></figure><p>复制构造函数的函数体内对数据成员赋值时，使用的是赋值运算符而不是复制构造符，因为他们已经初始化了，就像前面讲述的那样。</p><p>如果编写如下代码复制构造函数，则使用复制构造函数初始化 mValue：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++">SpreadsheetCell::<span class="hljs-built_in">SpreadsheetCell</span>(<span class="hljs-type">const</span> SpreadsheetCell&amp; src)<br> : <span class="hljs-built_in">mValue</span>(src.mValue)<br>&#123;<br>      <br>&#125;<br></code></pre></td></tr></table></figure></li></ol></blockquote><hr><h3 id="8-4本章小结"><a href="#8-4本章小结" class="headerlink" title="8.4本章小结"></a>8.4本章小结</h3><blockquote><p>本章讲述了 C++ 为面向对象的基本工具：类和对象。首先回顾编写类和使用对象的基本语法，包含访问控制。然后讲述了对象的生命周期；什么时候构建、销毁、和赋值，这些操作会调用哪些方法。本章包含构造函数的语法细节，包括 ctor-initializer 和初始化列表构造函数，此外还介绍了复制赋值运算符的概念。本章还明确指出在什么情况下，编译器会自动生成什么样的构造函数，并解释了没有参数的默认构造函数。</p><p>对于某些人来说，本章基本只是回顾，对另一些人来说，通过本章可更好地了解 C++ 中面向对象编程世界。无论如何，我们都已经认识到了 类和对象，可以通过下一章获取更多技巧。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 复习教程第三章（设计专业的 C++ 程序）</title>
    <link href="/2024/03/14/C++%20%E5%A4%8D%E4%B9%A0%E6%95%99%E7%A8%8B%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%88%E8%AE%BE%E8%AE%A1%E4%B8%93%E4%B8%9A%E7%9A%84%20C++%20%E7%A8%8B%E5%BA%8F%EF%BC%89/"/>
    <url>/2024/03/14/C++%20%E5%A4%8D%E4%B9%A0%E6%95%99%E7%A8%8B%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%88%E8%AE%BE%E8%AE%A1%E4%B8%93%E4%B8%9A%E7%9A%84%20C++%20%E7%A8%8B%E5%BA%8F%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="第4章-——-设计专业的-C-程序"><a href="#第4章-——-设计专业的-C-程序" class="headerlink" title="第4章 —— 设计专业的 C++ 程序"></a>第4章 —— 设计专业的 C++ 程序</h2><hr><h3 id="4-1程序设计概述"><a href="#4-1程序设计概述" class="headerlink" title="4.1程序设计概述"></a>4.1程序设计概述</h3><blockquote><p>设计文档的常见布局基本类似，包括两个主要部分：</p><p>(1) 将总的程序分为子系统，包括子系统之间的界面和依赖关系、子系统之间的数据流、每个子系统的输入输出和通用线程模型。</p><p>(2) 每个子系统的详情，包括类的细分、类的层次结构、数据结构、算法、具体的线程模型和错误处理的细节。</p><p>就是 UML 图，这里就不仔细说了。</p></blockquote><hr><h3 id="4-2程序设计的重要性"><a href="#4-2程序设计的重要性" class="headerlink" title="4.2程序设计的重要性"></a>4.2程序设计的重要性</h3><blockquote><p>总结，UML。</p></blockquote><hr><h3 id="4-3C-设计的特点"><a href="#4-3C-设计的特点" class="headerlink" title="4.3C++ 设计的特点"></a>4.3C++ 设计的特点</h3><blockquote><p>在使用 C++进行设计时，需要考虑 C++语言的一些性质：</p><ul><li><p>C++具有庞大的功能集。它几乎是 C 语言的完整超集，此外还有类、对象、运算符重载、异常、模板和其他功能。由于该语言非常庞大，使设计成为一项令人生畏的任务。</p></li><li><p>C++是一门面向对象语言。这意味着设计应该包含类层次结构、类接口和对象交互。这种设计类型与传统的 C 和其他过程式语言的设计竞全不同。第 5 章重点介绍 C++面向对象设计。</p></li><li><p>C++有许多设计通用的、可重用代码的工具。除了基本的类和继承之外，还可以使用其他语言工具进行高效的设计，如模板和运算符重载。第 6 章将详细讨论可重用代码的设计技术。</p></li><li><p>C++提供了一个有用的标准库，包含字符串类、I&#x2F;O 工具、许多常见的数据结构和算法。所有这些都便于 C++代码的编写。</p></li><li><p>C++语言提供了许多设计模式或解决问题的通用方法。</p></li></ul><p><strong>因此，优秀的设计难能可贵，获取这样的设计需要实践。不要期望一夜之间成长为专家，掌握 C++设计比C++编码更难。</strong>  </p></blockquote><hr><h3 id="4-4C-设计的两个原则"><a href="#4-4C-设计的两个原则" class="headerlink" title="4.4C++ 设计的两个原则"></a>4.4C++ 设计的两个原则</h3><blockquote><ul><li><strong>抽象，接口化</strong></li><li><strong>重用，方法化</strong></li></ul></blockquote><hr><h4 id="4-1抽象"><a href="#4-1抽象" class="headerlink" title="4.1抽象"></a>4.1抽象</h4><blockquote><p>忽略本质，只在意接口、输入、输出，只看结果；</p><p>接口并不决定底层实现，改变实现并不需要改变接口；</p><p>象棋棋盘示例:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++">&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">ChessBoard</span><br>&gt;&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// This example omits constructors, destructor, and assignment operator.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setPieceAt</span><span class="hljs-params">(<span class="hljs-type">size_t</span> x, <span class="hljs-type">size_t</span> y, ChessPiece* piece)</span></span>;<br><span class="hljs-function">ChessPiece* <span class="hljs-title">getPieceAt</span><span class="hljs-params">(<span class="hljs-type">size_t</span> x, <span class="hljs-type">size_t</span> y)</span></span>;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(<span class="hljs-type">size_t</span> x, <span class="hljs-type">size_t</span> y)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// This example omits data members.</span><br>&gt;&#125;;<br></code></pre></td></tr></table></figure></blockquote><hr><h4 id="4-2重用"><a href="#4-2重用" class="headerlink" title="4.2重用"></a>4.2重用</h4><blockquote><p>对已存在代码的使用；</p><p>去除特殊化，泛化代码；</p><p>任何棋类棋盘示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++">&gt;<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> PieceType&gt;<br>&gt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">GameBoard</span><br>&gt;&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// This example omits constructors, destructor, and assignment operator.</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setPieceAt</span><span class="hljs-params">(<span class="hljs-type">size_t</span> x, <span class="hljs-type">size_t</span> y, PieceType* piece)</span></span>;<br><span class="hljs-function">PieceType* <span class="hljs-title">getPieceAt</span><span class="hljs-params">(<span class="hljs-type">size_t</span> x, <span class="hljs-type">size_t</span> y)</span></span>;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">(<span class="hljs-type">size_t</span> x, <span class="hljs-type">size_t</span> y)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// This example omits data members.</span><br>&gt;&#125;;<br></code></pre></td></tr></table></figure><p>例如，假定要设计一个国际象棋程序：使用一个 EirorLogger 对象将不同组件发生的所有错误都按顺序写入一个日志文件。当试着设计 EirorLogger 类时，你意识到只想在一个程序中有一个ErrorLogger 实例。还要使程序的多个组件都能使用这个 ErrorLogger 实例，即所有组件都想要使用同一个 ErrorLogger 服务。<strong>实现此类服务机制的一个标准策略是使用注入依赖(dendency injection)<strong>。</strong>使用注入依赖时，为每个服务创建一个接口，并将组件需要的接口注入组件。因此，此时良好的设计应当使用“依赖注入”模式</strong>。<strong>你必须熟悉这些模式和技术，根据特定设计问题选择正确的解决方案。在 C++ 中，还可以使用更多技术和模式。详细讲述设计模式和技术超出了本书的范围，如果读者对此感兴趣，可以参阅附录 B 给出的建议。</strong></p></blockquote><hr><h3 id="4-5重用代码"><a href="#4-5重用代码" class="headerlink" title="4.5重用代码"></a>4.5重用代码</h3><blockquote><p>注意：重用代码并不意味着复制和粘贴已有的代码，但实际含义刚好相反：重用代码，但不重复代码；</p></blockquote><hr><h4 id="5-1关于术语的说明"><a href="#5-1关于术语的说明" class="headerlink" title="5.1关于术语的说明"></a>5.1关于术语的说明</h4><blockquote><p>在分析代码重用优缺点前，有必要指出所涉及的术语，并将重用代码分类。有三种可以重用的代码：</p><ul><li><strong>过去编写的代码；</strong></li><li><strong>同事编写的代码；</strong></li><li><strong>当前组织或公司以外的第三方编写的代码；</strong></li></ul><p>所使用的代码可通过以下几种方法来构建：</p><ul><li><strong>独立的函数或类</strong>，当重用自己或同事的代码时，通常会遇到这种类型；</li><li><strong>库，库是用于完成特定任务(例如解析 XML)或者针对特定领域(如密码系统)的代码集合</strong>。在库中经常可以找到其他许多功能，如线程和同步支持、网络和图像。</li><li><strong>框架(Framework)，框架是代码的集合，围绕框架设计程序</strong>。例如，微软基础类(Microsoft Foundation Classes, MFC)提供了在 Microsoft Windows 中创建用户界面应用程序的框架。框架通常指定了程序的结构。</li></ul><p><strong>注意：</strong></p><p>​<strong>程序使用库，但会适应框架。库提供了特定功能，而框架是程序设计和结构的基础。</strong></p><p><strong>应用程序编码接口(API)是另一个经常出现的术语。API 是库或为特定目的而提供的接口。例如，程序员会经常提到套接字 API，这是指套接字联网库的公开接口，而不是库本身</strong>。</p><p><strong>注意：</strong></p><p>​<strong>尽管人们将库以及 API 互换使用，但是两者不是等价的。库指的是“实现”，而 API 指的是 “库的公开接口”。</strong></p><p>为简洁起见，本章剩余部分用术语“库”表示任何可重用的代码，它事实上可能是库、框架或是同时编写的随机函数集合。</p></blockquote><hr><h4 id="5-2决定是否重用代码"><a href="#5-2决定是否重用代码" class="headerlink" title="5.2决定是否重用代码"></a>5.2决定是否重用代码</h4><blockquote><p><strong>重用代码的优点：</strong></p><ul><li><strong>节省时间和成本；</strong></li><li><strong>不需要额外的设计；</strong></li><li><strong>不需要调试；</strong></li><li><strong>代码安全性更高；</strong></li><li><strong>库会持续改进；</strong></li></ul><p><strong>重用代码的缺点：</strong></p><ul><li><strong>需要花费时间了解接口和正确使用方法；</strong></li><li><strong>代码功能未必完全吻合；</strong></li><li><strong>代码支持问题可能遇到问题；</strong></li><li><strong>代码使用许可问题；</strong></li><li><strong>跨平台可移植性问题；</strong></li><li><strong>对代码质量与安全性的信任问题；</strong></li><li><strong>版本更新可能会出现致命问题；</strong></li><li><strong>使用纯粹二进制库时，将编辑器升级为新版本会导致问题；</strong></li></ul><p><strong>熟悉了重用代码的术语和优缺点后，就可以决定是否重用代码。</strong>通常，这个决定是显而易见的。例如，如果想要用 C++ 在 Microsoft Windows 上编写图形用户界面(GUI), 应该使用 MFC(Microsoft Foundation Class)或Qt 等框架。你可能不知道如何在 Windows 上编写创建 GUI 的底层代码，更重要的是不想浪费时间去学习。在此情况下使用框架可以节省数年的时间。</p><p>然而，有时情况并不明显。例如，如果不熟悉某个库或框架，并且只需要其中某个简单的数据结构，那就不值得花时间去学习整个框架来重用某个只需要花费数天就能编写出来的组件。</p><p>总之，这个决定是根据特定的需求做出的选择。通常是在自己编写代码所花时间和查找库并了解如何使用库来解决问题所使用时间之间的权衡。应该针对具体情况，仔细考虑前面列出的优缺点，并判断哪些因素是最重要的。最后，可随时改变想法，如果正确处理了抽象，这并不需要太多的工作量。</p></blockquote><hr><h4 id="5-3重用代码的策略"><a href="#5-3重用代码的策略" class="headerlink" title="5.3重用代码的策略"></a>5.3重用代码的策略</h4><blockquote><p>当使用库、框架以及同事或自己的代码时，应该记住一些指导方针：</p><ol><li><strong>理解功能和限制限制因素</strong><ul><li>花点时间熟悉代码，对于理解其功能和限制因素而言都很重要。可从文档、公开的接口或 API 开始，理想情况下，这样做足以理解代码的使用方式。然而，如果库未将接口和实现明确分离，可能还要研究源代码。此外，还可与其他使用过这些代码或能解释这些代码的程序员交流。</li></ul></li><li><strong>理解性能</strong><ul><li>了解库或其他代码提供的性能保障很重要。即使某个程序对性能不敏感，也应该确保使用的代码在具体的使用中性能不会太糟。</li></ul></li><li><strong>大 O 表示法</strong><ul><li>程序员经常使用大0 表示法（Big-0 Notation）讨论并记录算法和库的性能。  <strong>注意：大 O 表示法仅适用于速度依赖于输入的算法，不适用于没有输入或者运行时间随机的算法。实际上,大多数算法的运行时间都取决于输入，因此这个限制并不重要。</strong></li></ul></li></ol><p><img src="https://bu.dusays.com/2024/03/15/65f4460e5e872.png" alt="image-20240209135140519"></p><ol start="4"><li><p><strong>理解性能的几点提示</strong></p><ul><li>略，见书。</li><li>总结一句就是，你不测试就永远不知道这个库到底性能高不高。</li></ul></li><li><p><strong>理解平台限制</strong></p><ul><li>在开始使用库代码之前，一定要理解运行库的平台。这看上去是显而易见的，但即使是那些号称跨平台的库，在不同的平台上也会有微妙差别；此外，平台不仅包括不同的操作系统，还包括同一操作系统的不同版本。  不要以为库一定会向前或先后兼容；</li></ul></li><li><p><strong>理解许可证和支持</strong>  </p><ul><li>使用第三方的库常会带来复杂的许可证问题。为使用第三方供应商提供的库，有时必须支付许可证费用。还可能有其他的许可限制，包括出口限制。此外，开放源代码库有时会要求与其有关的任何代码都公开源代码；</li></ul></li><li><p><strong>了解在哪里寻求帮助</strong>  </p><ul><li><p>首先参考库自带的文档。如果库被广泛使用，如标准库或 MFC, 就应该能找到与此主题相关的优秀书籍。实际上，本书的第 1A21 章都讲述标准库。如果某个特定问题在手册或产品文档中没有提及，可搜索 Web。在选择的搜索引擎中输入问题来寻找讨论这个库的 Web 页面。例如，当查找短语 “introduction to C++ Standard Library” 时，会找到与 C++和标准</p><p>库有关的数百个站点。此外，许多站点包含关于特定主题的新闻组或论坛，可注册并寻找答案。</p></li></ul></li><li><p><strong>原型</strong></p><ul><li>当首次使用某个新库或框架时，最好编写一个快速原型。测试代码是熟悉库功能的最好方法。应该考虑在程序设计之前测试库，这样就可以熟悉库的功能和限制。这种实际检验还可判断库的性能特征。即使原型应用程序与最终应用程序没有任何相似之处，花费在原型上的时间也不会浪费。不要觉得编写实际应用程序的原型很难，可编写一个虚拟程序来测试想使用的库功能，这样做是为了让自己熟悉库。</li></ul></li></ol></blockquote><hr><h4 id="5-4绑定第三方应用程序"><a href="#5-4绑定第三方应用程序" class="headerlink" title="5.4绑定第三方应用程序"></a>5.4绑定第三方应用程序</h4><blockquote><p>项目可能包含多个应用程序。或许需要 Web 服务器前端来支持新的电子商务基础设施。可将第三方应用程序(例如 Web 服务器)与软件绑定。<strong>这种方法将代码重用发挥到了极致，因为重用了整个应用程序</strong>。当然，使用库的那些忠告和指导方针也适用于绑定第三方应用程序，应该特别注意自己的决定所涉及的法律和许可证问题。</p><p><strong>注意：</strong></p><p>​<strong>将第三方应用程序与分发的软件绑定之前，应当请教专门处理知识产权问题的法律专家。</strong></p></blockquote><hr><h4 id="5-5开放源代码库"><a href="#5-5开放源代码库" class="headerlink" title="5.5开放源代码库"></a>5.5开放源代码库</h4><blockquote><p>开放源代码库是一种日益流行的可重用代码类型。<strong>开放源代码(open-source)通常意味着任何人都可以查看源代码。</strong>关于分发软件时包含源代码，有正式的定义和法规，但最重要的是，任何人(包括你)都能查看开放源代码软件的源代码。注意开放源代码不仅适用于库，实际上最著名的开放源代码产品可能是 Android 操作系统。Linux 操作系统是另一个著名的开放源代码操作系统。Google Chrome 和 Mozilla Firefbx 是两个开放源代码的著名 Web 浏览器。  </p></blockquote><hr><h4 id="5-6C-标准库"><a href="#5-6C-标准库" class="headerlink" title="5.6C++ 标准库"></a>5.6C++ 标准库</h4><blockquote><p><strong>C++程序员使用的最重要的库就是 C++标准库。</strong>  </p><p><strong>C++ 提供了比 C 更好的字符串以及 I&#x2F;O 支持。尽管 C 风格的字符串和 I&#x2F;O 例程在 C++中仍然有效，但应该避免使用它们，而是使用 C++字符串(详见第 2章)和 I&#x2F;O 流(详见第 13 章)。</strong>  </p><p><strong>设计标准库时优先考虑的是功能、性能和正交性(orthogonality)。使用标准库可获得巨大好处。可回顾在链表或平衡二叉树实现中跟踪指针错误，或者调试不能正确排序的排序算法，如果能够正确使用标准库，几乎不需要再编写这类代码。第 16 21 章将提供有关标准库功能的信息；</strong></p></blockquote><hr><h3 id="4-6设计一个国际象棋程序"><a href="#4-6设计一个国际象棋程序" class="headerlink" title="4.6设计一个国际象棋程序"></a>4.6设计一个国际象棋程序</h3><blockquote><p>本节通过一个简单的国际象棋程序系统介绍 C++程序的设计方法。为提供完整示例，某些步骤用到了后面几章讲述的概念。为了解设计过程的概况，可现在就阅读这个示例，也可以在学完后面章节后返回头来学习；</p></blockquote><hr><h4 id="6-1需求"><a href="#6-1需求" class="headerlink" title="6.1需求"></a>6.1需求</h4><blockquote><p><strong>在开始设计前，应该弄清楚对于程序功能和性能的需求。理想情况下，这些需求应该是以需求规范(requirements specification)形式给出的文档。</strong>国际象棋程序的需求应该包含下列类型的规范，当然实际的需求规范应该比下面的内容更详细，条目更多：  </p><ul><li>程序支持标准的国际象棋规则。  </li><li>程序提供基于文本的界面。  <ul><li>程序以纯文本形式提供棋盘和棋子。  </li><li>玩家通过输入代表位置的数字在棋盘上移动棋子。</li></ul></li></ul></blockquote><hr><h4 id="6-2设计步骤"><a href="#6-2设计步骤" class="headerlink" title="6.2设计步骤"></a>6.2设计步骤</h4><blockquote><ol><li>将程序分割为子系统；</li></ol><p><img src="https://bu.dusays.com/2024/03/15/65f446111ef04.png" alt="image-20240209140908334"></p><p><img src="https://bu.dusays.com/2024/03/15/65f446144d117.png" alt="image-20240209141005292"></p><ol start="2"><li><p>选择线程模型；</p></li><li><p>指定每个子系统的类层次结构；</p></li></ol><p><img src="https://bu.dusays.com/2024/03/15/65f44615b2f07.png" alt="image-20240209141103026"></p><p><img src="https://bu.dusays.com/2024/03/15/65f4461784b86.png" alt="image-20240209141119716"></p><ol start="4"><li>指定每个子系统的类、数据结构、算法和模式；</li></ol><p><img src="https://bu.dusays.com/2024/03/15/65f4461aeb7fb.png" alt="image-20240209141142275"></p><p><img src="https://bu.dusays.com/2024/03/15/65f4461cd62a8.png" alt="image-20240209141207029"></p><ol start="5"><li>为每个子系统指定错误处理；</li></ol><p><img src="https://bu.dusays.com/2024/03/15/65f44621a8418.png" alt="image-20240209141229352"></p></blockquote><hr><h3 id="4-7本章小结"><a href="#4-7本章小结" class="headerlink" title="4.7本章小结"></a>4.7本章小结</h3><blockquote><p>本章介绍了专业的 C++设计方法。软件设计是任何编程项目中重要的第一步。你还学习了使得设计变得困难的一些 C++特性，包括 C++关注的面向对象、庞大的功能集和标准库、编写通用代码的工具。这些信息可让程序员更好地处理 C++设计；</p><p>本章介绍了两个设计主题：抽象和重用。抽象（或将接口与实现分离）的概念贯穿全书，所有的设计工作都应该以此为指导方针。重用的概念（无论是代码还是设计）在实际项目和本书中经常会出现。C++设计应该包含代码的重用（以库或框架的形式）以及思想和设计的重用（以技术和模式的形式）。 应该尽可能编写可重用的代码。此外还要记住权衡重用的优缺点和重用代码的特定方针，包括理解功能和限制、性能、许可证、支持模式、平台限制、原型和帮助资源。你还学习了性能分析和大 O 表示法。现在你已经理解了设计的重要性和基本的设计主题，并做好了学习本书第 Ⅱ 部分其余章节的准备。第 5 章将讲述在设计中使用 C++面向对象特性的策略；</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>你为什么不谈恋爱？</title>
    <link href="/2024/03/10/%E4%BD%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%B0%88%E6%81%8B%E7%88%B1%EF%BC%9F/"/>
    <url>/2024/03/10/%E4%BD%A0%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%B0%88%E6%81%8B%E7%88%B1%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="你为什么不谈恋爱？"><a href="#你为什么不谈恋爱？" class="headerlink" title="你为什么不谈恋爱？"></a>你为什么不谈恋爱？</h1><blockquote><p>版权声明：本文为知乎作者<a href="https://www.zhihu.com/people/94-17-82-86">苏格拉底没有底</a>原创文章，版权归属原作者，如果侵权，请联系我们删除！</p><p>作者：苏格拉没有底<br>链接：<a href="https://www.zhihu.com/question/281437650/answer/3361833502">https://www.zhihu.com/question/281437650/answer/3361833502</a><br>来源：知乎</p></blockquote><p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>两袖清风，一身清贫。外无潘安卫阶之貌，内无石崇不韦之富。英雄起于草莽，而未有尺寸之功。自惭形秽，特立独行。无名显著于世，无才显露于人。不曾交涉广泛，亦无口齿之利。虽自负于胸藏韬略，亦慕淮阴子建之能。然多遭坎坷，饱尝世事艰辛。昔见笑于众女，讥我容貌之丑陋。如效颦之东施，胜齐国之无盐。后被耻于言行，讽我情商之低下。若歌辇之楚狂人，似投江之屈原。忍尤攘诟，闻过则改。休学业以养身心，腹诗书而气自华。敛藏锋华，涵养本心。</p><p>虽慕相如、梁鸿之情满，实无求凰纳雁之意。且丈夫志在乘风破浪，岂求赌书泼茶之趣。况情浅不真，情深不寿。耽于此道，磨损身心。此间虽乐，令人难思蜀，然情过境迁，思之令人心烦。从前恩爱种种，今朝鸿雁分飞。若如初见，沧海巫云。依昔亲密无间，此后陌路难逢。明皇贵妃之誓，终成马嵬坡下之魂。成帝班妃之爱，难抵深宫团扇之悲。金屋藏娇，不过儿时戏言；《长门赋》成，难挽帝王之心。故剑情深，独留悲伤之人；金谷事悲，花犹坠楼之人。十年生死，阴阳相隔；月挂疏桐，沙洲寂冷。易安情满，共赏金印之乐。渡江失夫，身如黄花憔悴；放翁悦婚，与妻青梅竹马。难违母命，常思惊鸿之影。相思无益，徒惹人瘦衣宽；未妨惆怅，空余身疲心凉。</p><p>况大学求爱，少情多欲，去真求伪。未知良人之难求，而贪一时之欢乐。不求情真如蒲苇，但念片刻之欢娱。喜赴巫山云雨之会，乐从耳目口腹之欲。不思学业之进展，独爱伴侣之眷恋。且夫多重于金玉之外，未知其败絮之内。喜于口舌之誓，不求真心之言。温存令人流连，相处乐于忘返。如桃源之渔夫，喜虚构之世界。似烂柯之王质，忘世事之变迁。且喜新厌旧，人之常情也。后来者居上，而旧爱者沦亡。移情别恋，怨从爱生，纠缠不休，苦不堪言。人无远虑，必有近忧。在校思学业，毕业思工作。种种忧虑，岂求相爱？</p><p>人之大事，在孝与志。上愿承父母膝下之乐，下欲建高祖太宗之业。年已二十，志比天高。自强不息，厚德载物。身有鸿鹄之志，心有鲲鹏之愿。潜龙卧渊，凤凰待枝。自比于国士无双，而时人未识也。一朝腾跃而起，翱翔四海之内。故饱览经书，学于四海。通天达地，学贯中西。著书立说，经世致用。如此，大丈夫何患无妻？不求于大学，而以才学求之邦国也。</p>]]></content>
    
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言算法赛——蓝桥杯（省赛试题）</title>
    <link href="/2024/02/27/C%E8%AF%AD%E8%A8%80%E7%AE%97%E6%B3%95%E8%B5%9B%E2%80%94%E2%80%94%E8%93%9D%E6%A1%A5%E6%9D%AF%EF%BC%88%E7%9C%81%E8%B5%9B%E8%AF%95%E9%A2%98%EF%BC%89/"/>
    <url>/2024/02/27/C%E8%AF%AD%E8%A8%80%E7%AE%97%E6%B3%95%E8%B5%9B%E2%80%94%E2%80%94%E8%93%9D%E6%A1%A5%E6%9D%AF%EF%BC%88%E7%9C%81%E8%B5%9B%E8%AF%95%E9%A2%98%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="C语言算法赛——蓝桥杯（省赛试题）"><a href="#C语言算法赛——蓝桥杯（省赛试题）" class="headerlink" title="C语言算法赛——蓝桥杯（省赛试题）"></a>C语言算法赛——蓝桥杯（省赛试题）</h1><blockquote><p>版权声明：本文为博主<a href="https://blog.csdn.net/weixin_56641478">作者：慢了半拍i</a>原创文章，版权归属原作者，如果侵权，请联系我们删除！</p><p>原文链接：<a href="https://blog.csdn.net/weixin_56641478/article/details/135726057">https://blog.csdn.net/weixin_56641478/article/details/135726057</a></p></blockquote><h2 id="一、十四届C-C-程序设计C组试题"><a href="#一、十四届C-C-程序设计C组试题" class="headerlink" title="一、十四届C&#x2F;C++程序设计C组试题"></a>一、十四届C&#x2F;C++程序设计C组试题</h2><p><img src="https://aitechtogether.com/wp-content/uploads_new/2024/02/28a2c887-dda4-475c-8fda-373bded07194.webp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp">十四届程序C组试题A<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">20230408</span>;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 累加从1到n的所有整数</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        sum += i;<br>    &#125;<br><br>    <span class="hljs-comment">// 输出结果</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, sum);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++</p><p><img src="https://aitechtogether.com/wp-content/uploads_new/2024/02/a90ae47f-58fa-44d6-b03c-d22c0cb686d9.webp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//十四届程序C组试题B</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-comment">// 时间字符串解析为结构体 tm</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">parseTime</span><span class="hljs-params">(<span class="hljs-type">char</span>* timeString, <span class="hljs-keyword">struct</span> tm* timeStruct)</span> </span>&#123;<br>    <span class="hljs-built_in">sscanf</span>(timeString, <span class="hljs-string">&quot;%d-%d-%d %d:%d:%d&quot;</span>,<br>        &amp;timeStruct-&gt;tm_year, &amp;timeStruct-&gt;tm_mon, &amp;timeStruct-&gt;tm_mday,<br>        &amp;timeStruct-&gt;tm_hour, &amp;timeStruct-&gt;tm_min, &amp;timeStruct-&gt;tm_sec);<br><br>    <span class="hljs-comment">// tm_year表示的是自1900年以来的年数，需要减去1900</span><br>    timeStruct-&gt;tm_year -= <span class="hljs-number">1900</span>;<br>    <span class="hljs-comment">// tm_mon表示的是0-11的月份，需要减去1</span><br>    timeStruct-&gt;tm_mon -= <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 每一对相邻的上下班打卡之间的时间差</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calculateTimeDifference</span><span class="hljs-params">(<span class="hljs-type">char</span>* time1, <span class="hljs-type">char</span>* time2)</span> </span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">tm</span> start, end;<br><br>    <span class="hljs-comment">// 解析时间字符串为结构体 tm</span><br>    <span class="hljs-built_in">parseTime</span>(time1, &amp;start);<br>    <span class="hljs-built_in">parseTime</span>(time2, &amp;end);<br><br>    <span class="hljs-comment">// 使用 mktime 将 tm 结构体转换为时间戳</span><br>    <span class="hljs-type">time_t</span> startTime = <span class="hljs-built_in">mktime</span>(&amp;start);<br>    <span class="hljs-type">time_t</span> endTime = <span class="hljs-built_in">mktime</span>(&amp;end);<br><br>    <span class="hljs-comment">// 计算时间差</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">difftime</span>(endTime, startTime);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 打卡记录数组</span><br>    <span class="hljs-type">char</span>* punchRecords[] = &#123;<br>        <span class="hljs-string">&quot;2022-01-01 07:58:02&quot;</span>,<br>        <span class="hljs-string">&quot;2022-01-01 12:00:05&quot;</span>,<br>        <span class="hljs-string">&quot;2022-01-01 16:01:35&quot;</span>,<br>        <span class="hljs-string">&quot;2022-01-02 00:20:05&quot;</span><br>    &#125;;<br><br>    <span class="hljs-type">int</span> numRecords = <span class="hljs-built_in">sizeof</span>(punchRecords) / <span class="hljs-built_in">sizeof</span>(punchRecords[<span class="hljs-number">0</span>]);<br><br>    <span class="hljs-comment">// 按照时间顺序对打卡记录进行排序</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numRecords - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; numRecords - i - <span class="hljs-number">1</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(punchRecords[j], punchRecords[j + <span class="hljs-number">1</span>]) &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 交换记录</span><br>                <span class="hljs-type">char</span>* temp = punchRecords[j];<br>                punchRecords[j] = punchRecords[j + <span class="hljs-number">1</span>];<br>                punchRecords[j + <span class="hljs-number">1</span>] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算总工作时长</span><br>    <span class="hljs-type">int</span> totalWorkDuration = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numRecords - <span class="hljs-number">1</span>; i += <span class="hljs-number">2</span>) &#123;<br>        totalWorkDuration += <span class="hljs-built_in">calculateTimeDifference</span>(punchRecords[i], punchRecords[i + <span class="hljs-number">1</span>]);<br>    &#125;<br><br>    <span class="hljs-comment">// 输出总工作时长</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;小蓝在2022年度的总工作时长是%d秒。\n&quot;</span>, totalWorkDuration);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++</p><p><img src="https://aitechtogether.com/wp-content/uploads_new/2024/02/e4102ba9-936d-41e8-b74a-9087fd4246f7.webp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp">十四届程序C组试题C<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n; <span class="hljs-comment">// 事件数量</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><br>    <span class="hljs-type">int</span> A[n], B[n], C[n]; <span class="hljs-comment">// 存储每个事件中的A、B、C值</span><br>    <span class="hljs-type">int</span> maxEvents = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 最多发生的事件数量</span><br>    <span class="hljs-type">int</span> X = <span class="hljs-number">0</span>, Y = <span class="hljs-number">0</span>, Z = <span class="hljs-number">0</span>; <span class="hljs-comment">// 初始士兵数量</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;A[i], &amp;B[i], &amp;C[i]);<br><br>        <span class="hljs-comment">// 计算每个国家的士兵数量</span><br>        X += A[i];<br>        Y += B[i];<br>        Z += C[i];<br><br>        <span class="hljs-comment">// 判断是否有国家获胜</span><br>        <span class="hljs-keyword">if</span> ((X &gt; Y + Z) || (Y &gt; X + Z) || (Z &gt; X + Y)) &#123;<br>            <span class="hljs-comment">// 更新最多发生的事件数量</span><br>            maxEvents = i + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, maxEvents);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++</p><p><img src="https://aitechtogether.com/wp-content/uploads_new/2024/02/2ac5ee93-c7eb-463e-a90f-9da9223c0d92.webp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maximize_substrings</span><span class="hljs-params">(<span class="hljs-type">char</span>* s)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> i, n;<br><br>    <span class="hljs-comment">// 遍历字符串，从第二个字符开始</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; s[i] != <span class="hljs-string">&#x27;\0&#x27;</span>; ++i)<br>    &#123;<br>        <span class="hljs-comment">// 如果当前位置是&#x27;?&#x27;，则尽量使其与前一个字符不同</span><br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;?&#x27;</span>) &#123;<br>            s[i] = (s[i - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) ? <span class="hljs-string">&#x27;0&#x27;</span> : <span class="hljs-string">&#x27;1&#x27;</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 计算互不重叠的00和11子串的个数</span><br>        <span class="hljs-keyword">if</span> (s[i] == s[i - <span class="hljs-number">1</span>])<br>        &#123;<br>            count += <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> input_str[] = <span class="hljs-string">&quot;1?0?1&quot;</span>;<br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">maximize_substrings</span>(input_str);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;互不重叠的00和11子串个数：%d\n&quot;</span>, result);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++</p><p><img src="https://aitechtogether.com/wp-content/uploads_new/2024/02/8fc92f7b-2bcc-4167-a97a-1a3e48e816e1.webp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-comment">// 函数：计算最小翻转次数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">min_flips_to_match</span><span class="hljs-params">(<span class="hljs-type">char</span> S[], <span class="hljs-type">char</span> T[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-built_in">strlen</span>(S);<br>    <span class="hljs-type">int</span> flips = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 从第二个位置到倒数第二个位置进行遍历</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n - <span class="hljs-number">1</span>; ++i)<br>    &#123;<br>        <span class="hljs-comment">// 如果当前位置的字符与目标串不同</span><br>        <span class="hljs-keyword">if</span> (S[i] != T[i])<br>        &#123;<br>            <span class="hljs-comment">// 进行翻转操作</span><br>            flips++;<br>            S[i] = T[i];<br>            S[i + <span class="hljs-number">1</span>] = (S[i + <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;0&#x27;</span>) ? <span class="hljs-string">&#x27;1&#x27;</span> : <span class="hljs-string">&#x27;0&#x27;</span>;<br>            S[i + <span class="hljs-number">2</span>] = (S[i + <span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;0&#x27;</span>) ? <span class="hljs-string">&#x27;1&#x27;</span> : <span class="hljs-string">&#x27;0&#x27;</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> flips;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 示例输入</span><br>    <span class="hljs-type">char</span> S[] = <span class="hljs-string">&quot;01010&quot;</span>;<br>    <span class="hljs-type">char</span> T[] = <span class="hljs-string">&quot;00000&quot;</span>;<br><br>    <span class="hljs-comment">// 计算最小翻转次数</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">min_flips_to_match</span>(S, T);<br><br>    <span class="hljs-comment">// 输出结果</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Minimum flips required: %d\n&quot;</span>, result);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++</p><p><img src="https://aitechtogether.com/wp-content/uploads_new/2024/02/bf2ebf29-399d-4102-b26e-1e9be3c12834.webp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MOD 998244353</span><br><br><span class="hljs-comment">// 函数：计算矩阵子矩阵价值的和</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">matrixSubmatrixSum</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> matrix[n][m])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 预处理，计算每个位置的最大值和最小值</span><br>    <span class="hljs-type">int</span> maxVal[n][m];<br>    <span class="hljs-type">int</span> minVal[n][m];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>)<br>            &#123;<br>                maxVal[i][j] = (maxVal[i][j] &gt; maxVal[i - <span class="hljs-number">1</span>][j]) ? maxVal[i][j] : maxVal[i - <span class="hljs-number">1</span>][j];<br>                minVal[i][j] = (minVal[i][j] &lt; minVal[i - <span class="hljs-number">1</span>][j]) ? minVal[i][j] : minVal[i - <span class="hljs-number">1</span>][j];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (j &gt; <span class="hljs-number">0</span>)<br>            &#123;<br>                maxVal[i][j] = (maxVal[i][j] &gt; maxVal[i][j - <span class="hljs-number">1</span>]) ? maxVal[i][j] : maxVal[i][j - <span class="hljs-number">1</span>];<br>                minVal[i][j] = (minVal[i][j] &lt; minVal[i][j - <span class="hljs-number">1</span>]) ? minVal[i][j] : minVal[i][j - <span class="hljs-number">1</span>];<br>            &#125;<br>            maxVal[i][j] = (maxVal[i][j] &gt; matrix[i][j]) ? maxVal[i][j] : matrix[i][j];<br>            minVal[i][j] = (minVal[i][j] &lt; matrix[i][j]) ? minVal[i][j] : matrix[i][j];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算答案</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> a = <span class="hljs-number">1</span>; a &lt;= n; ++a)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> b = <span class="hljs-number">1</span>; b &lt;= m; ++b)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + a - <span class="hljs-number">1</span> &lt; n; ++i)<br>            &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j + b - <span class="hljs-number">1</span> &lt; m; ++j)<br>                &#123;<br>                    <span class="hljs-type">int</span> maxInSubmatrix = maxVal[i + a - <span class="hljs-number">1</span>][j + b - <span class="hljs-number">1</span>];<br>                    <span class="hljs-type">int</span> minInSubmatrix = minVal[i + a - <span class="hljs-number">1</span>][j + b - <span class="hljs-number">1</span>];<br>                    result = (result + ((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)maxInSubmatrix * minInSubmatrix) % MOD) % MOD;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 示例输入</span><br>    <span class="hljs-type">int</span> n = <span class="hljs-number">3</span>, m = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> matrix[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>] =&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;,&#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>&#125;,&#123;<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;&#125;;<br><br>    <span class="hljs-comment">// 计算答案</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">matrixSubmatrixSum</span>(n, m, matrix);<br><br>    <span class="hljs-comment">// 输出结果</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Sum of submatrix values: %d\n&quot;</span>, result);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++</p><p> <img src="https://aitechtogether.com/wp-content/uploads_new/2024/02/bf5cc606-0f49-4dc9-8572-9fc5dcab6a0f.webp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MOD 998244353</span><br><br><span class="hljs-comment">// 计算欧拉函数</span><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">phi</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> n)</span> </span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> p = <span class="hljs-number">2</span>; p * p &lt;= n; ++p) &#123;<br>        <span class="hljs-keyword">if</span> (n % p == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">while</span> (n % p == <span class="hljs-number">0</span>)<br>                n /= p;<br>            result -= result / p;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">1</span>)<br>        result -= result / n;<br>    <span class="hljs-keyword">return</span> result % MOD;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> a, b;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld %lld&quot;</span>, &amp;a, &amp;b);<br><br>    <span class="hljs-comment">// 计算欧拉函数</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> euler_a = <span class="hljs-built_in">phi</span>(a);<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> euler_ab = <span class="hljs-built_in">phi</span>((<span class="hljs-type">long</span> <span class="hljs-type">long</span>)<span class="hljs-built_in">pow</span>(a, b));<br><br>    <span class="hljs-comment">// 输出结果对MOD取模的值</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, (euler_ab - euler_a + MOD) % MOD);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++</p><p><img src="https://aitechtogether.com/wp-content/uploads_new/2024/02/e736a667-2239-41c0-905a-4b72f4ef2ea7.webp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> max(a, b) ((a) &gt; (b) ? (a) : (b))</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">max_xor_difference</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-type">int</span> prefix_xor_left[<span class="hljs-number">100000</span>];<br>    <span class="hljs-type">int</span> prefix_xor_right[<span class="hljs-number">100000</span>];<br><br>    <span class="hljs-comment">// 计算从左往右的前缀异或和</span><br>    prefix_xor_left[<span class="hljs-number">0</span>] = arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>        prefix_xor_left[i] = prefix_xor_left[i - <span class="hljs-number">1</span>] ^ arr[i];<br>    &#125;<br><br>    <span class="hljs-comment">// 计算从右往左的前缀异或和</span><br>    prefix_xor_right[n - <span class="hljs-number">1</span>] = arr[n - <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        prefix_xor_right[i] = prefix_xor_right[i + <span class="hljs-number">1</span>] ^ arr[i];<br>    &#125;<br><br>    <span class="hljs-comment">// 计算两个不相交子段内数的异或和的差值的最大值</span><br>    <span class="hljs-type">int</span> max_difference = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;<br>        max_difference = <span class="hljs-built_in">max</span>(max_difference, <span class="hljs-built_in">max</span>(prefix_xor_left[i], prefix_xor_right[i + <span class="hljs-number">1</span>]));<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> max_difference;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter the number of elements in the array: &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><br>    <span class="hljs-type">int</span> arr[<span class="hljs-number">100000</span>];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter the array elements: &quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;arr[i]);<br>    &#125;<br><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">max_xor_difference</span>(arr, n);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Maximum XOR difference of two non-overlapping subarrays: %d\n&quot;</span>, result);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++</p><p><img src="https://aitechtogether.com/wp-content/uploads_new/2024/02/817a6553-26fb-400b-af96-5d4b92adfb34.webp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (b != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> temp = b;<br>        b = a % b;<br>        a = temp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">find_numbers</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i_min = <span class="hljs-number">-1</span>, j_min = <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">gcd</span>(arr[i], arr[j]) &gt; <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">if</span> (i_min == <span class="hljs-number">-1</span> || i &lt; i_min || (i == i_min &amp;&amp; j &lt; j_min)) &#123;<br>                    i_min = i;<br>                    j_min = j;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (i_min == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No such pair found.\n&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Pair with minimum i and j: (%d, %d)\n&quot;</span>, i_min + <span class="hljs-number">1</span>, j_min + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter the number of elements in the array: &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><br>    <span class="hljs-type">int</span> arr[<span class="hljs-number">1000</span>];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter the array elements: &quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;arr[i]);<br>    &#125;<br><br>    <span class="hljs-built_in">find_numbers</span>(arr, n);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++</p><p><img src="https://aitechtogether.com/wp-content/uploads_new/2024/02/57a3b4e2-4361-4f43-a085-07f70017df56.webp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">calculate_subtree_size</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">long</span> <span class="hljs-type">long</span> k)</span> </span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> subtree_size = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 计算当前结点的深度</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> depth = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span>) &#123;<br>        k = (k - <span class="hljs-number">1</span>) / m;<br>        depth++;<br>    &#125;<br><br>    <span class="hljs-comment">// 计算子树的结点数量</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> i = depth - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; --i) &#123;<br>        subtree_size = subtree_size * m + i;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> subtree_size;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter the degree of the tree (m): &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;m);<br><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> k;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter the node number (k): &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;k);<br><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = <span class="hljs-built_in">calculate_subtree_size</span>(m, k);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Number of nodes in the subtree corresponding to node %lld: %lld\n&quot;</span>, k, result);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++</p><h2 id="二、十四届C-C-程序设计B组试题"><a href="#二、十四届C-C-程序设计B组试题" class="headerlink" title="二、十四届C&#x2F;C++程序设计B组试题"></a>二、十四届C&#x2F;C++程序设计B组试题</h2><p><img src="https://aitechtogether.com/wp-content/uploads_new/2024/02/8f798c1f-5df4-4bc9-af81-7f9a475ce73f.webp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span> array[] = <span class="hljs-string">&quot;5686916124919823647759503875815861830379270588570991944686338516346707827689565614010094809128502533&quot;</span>;<br>    <span class="hljs-type">int</span> arraySize = <span class="hljs-built_in">strlen</span>(array);<br>    <span class="hljs-type">char</span> date[<span class="hljs-number">9</span>];  <span class="hljs-comment">// 存储提取的8位子序列</span><br>    <span class="hljs-type">int</span> uniqueDates = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 记录不同日期数量</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= arraySize - <span class="hljs-number">8</span>; ++i) &#123;<br>        <span class="hljs-comment">// 提取8位子序列</span><br>        <span class="hljs-built_in">strncpy</span>(date, array + i, <span class="hljs-number">8</span>);<br>        date[<span class="hljs-number">8</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;  <span class="hljs-comment">// 添加字符串结束符</span><br><br>        <span class="hljs-comment">// 解析日期</span><br>        <span class="hljs-type">int</span> year, month, day;<br>        <span class="hljs-built_in">sscanf</span>(date, <span class="hljs-string">&quot;%4d%2d%2d&quot;</span>, &amp;year, &amp;month, &amp;day);<br><br>        <span class="hljs-comment">// 检查是否为2023年的合法日期</span><br>        <span class="hljs-keyword">if</span> (year == <span class="hljs-number">2023</span> &amp;&amp; month &gt;= <span class="hljs-number">1</span> &amp;&amp; month &lt;= <span class="hljs-number">12</span> &amp;&amp; day &gt;= <span class="hljs-number">1</span> &amp;&amp; day &lt;= <span class="hljs-number">31</span>) &#123;<br>            <span class="hljs-comment">// 记录合法日期，并避免重复计数</span><br>            uniqueDates++;<br>            i += <span class="hljs-number">7</span>;  <span class="hljs-comment">// 移动到下一个可能的子序列的起始位置</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 输出结果</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;满足条件的不同日期数量为：%d\n&quot;</span>, uniqueDates);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++</p><p><img src="https://aitechtogether.com/wp-content/uploads_new/2024/02/c00470dc-4784-48a9-989c-3d2673dc7fb4.webp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><br><span class="hljs-comment">// 定义信息熵函数</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">entropy_equation</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<br>    <span class="hljs-type">double</span> p0 = x / <span class="hljs-number">23333333</span>;<br>    <span class="hljs-type">double</span> p1 = (<span class="hljs-number">23333333</span> - x) / <span class="hljs-number">23333333</span>;<br>    <span class="hljs-type">double</span> entropy = -(p0 * <span class="hljs-built_in">log2</span>(p0) + p1 * <span class="hljs-built_in">log2</span>(p1));<br>    <span class="hljs-keyword">return</span> entropy - <span class="hljs-number">11625907.5798</span>;<br>&#125;<br><br><span class="hljs-comment">// 二分法求解方程</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">binary_search</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">double</span> low = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-type">double</span> high = <span class="hljs-number">23333333</span>;<br>    <span class="hljs-type">double</span> epsilon = <span class="hljs-number">0.000001</span>;  <span class="hljs-comment">// 精度要求</span><br><br>    <span class="hljs-keyword">while</span> (high - low &gt; epsilon) &#123;<br>        <span class="hljs-type">double</span> mid = (low + high) / <span class="hljs-number">2.0</span>;<br>        <span class="hljs-type">double</span> result = <span class="hljs-built_in">entropy_equation</span>(mid);<br><br>        <span class="hljs-keyword">if</span> (result &gt; <span class="hljs-number">0</span>) &#123;<br>            high = mid;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            low = mid;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> low;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">double</span> zero_count = <span class="hljs-built_in">binary_search</span>();<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0 出现的次数为: %lf\n&quot;</span>, zero_count);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++</p><p><img src="https://aitechtogether.com/wp-content/uploads_new/2024/02/14f7f219-82d5-4eca-a330-49a8c8e49a90.webp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// 计算最大公约数的欧几里得算法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">gcd</span>(b, a % b);<br>&#125;<br><br><span class="hljs-comment">// 计算数组中所有元素的最大公约数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findGCD</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-type">int</span> result = arr[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        result = <span class="hljs-built_in">gcd</span>(result, arr[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入冶炼记录的数量 N: &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><br>    <span class="hljs-type">int</span> A[n], B[n];<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入每条记录中的 A 和 B：\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;A[i], &amp;B[i]);<br>    &#125;<br><br>    <span class="hljs-comment">// 计算最小值</span><br>    <span class="hljs-type">int</span> minV = <span class="hljs-built_in">findGCD</span>(A, n);<br><br>    <span class="hljs-comment">// 计算最大值</span><br>    <span class="hljs-type">int</span> maxV = <span class="hljs-built_in">findGCD</span>(B, n);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;转换率V的最小值：%d\n&quot;</span>, minV);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;转换率V的最大值：%d\n&quot;</span>, maxV);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++</p><p><img src="https://aitechtogether.com/wp-content/uploads_new/2024/02/a7311e35-dde8-489a-9092-ce2190f44d06.webp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-comment">// 飞机结构体</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Aircraft</span><br>&#123;<br>    <span class="hljs-type">int</span> arrivalTime;<br>    <span class="hljs-type">int</span> hoverTime;<br>    <span class="hljs-type">int</span> landingTime;<br>&#125;;<br><br><span class="hljs-comment">// 比较函数，用于排序</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* a, <span class="hljs-type">const</span> <span class="hljs-type">void</span>* b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (((<span class="hljs-keyword">struct</span> Aircraft*)a)-&gt;arrivalTime + ((<span class="hljs-keyword">struct</span> Aircraft*)a)-&gt;hoverTime) -<br>        (((<span class="hljs-keyword">struct</span> Aircraft*)b)-&gt;arrivalTime + ((<span class="hljs-keyword">struct</span> Aircraft*)b)-&gt;hoverTime);<br>&#125;<br><br><span class="hljs-comment">// 判断是否可以全部安全降落的函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">canLand</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Aircraft aircraft[], <span class="hljs-type">int</span> N)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">qsort</span>(aircraft, N, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> Aircraft), compare);<br><br>    <span class="hljs-type">int</span> currentTime = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>    &#123;<br>        <span class="hljs-comment">// 判断是否在时间窗口内降落</span><br>        <span class="hljs-keyword">if</span> (currentTime + aircraft[i].landingTime &gt; aircraft[i].arrivalTime + aircraft[i].hoverTime) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 不能安全降落</span><br>        &#125;<br><br>        <span class="hljs-comment">// 更新当前时间</span><br>        currentTime = (currentTime + aircraft[i].landingTime &gt; aircraft[i].arrivalTime)<br>            ? currentTime + aircraft[i].landingTime<br>            : aircraft[i].arrivalTime;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 可以安全降落</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> N;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入飞机数量 N：&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;N);<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Aircraft</span>* aircraft = (<span class="hljs-keyword">struct</span> Aircraft*)<span class="hljs-built_in">malloc</span>(N * <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> Aircraft));<br><br>    <span class="hljs-comment">// 输入飞机信息</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入第 %d 架飞机的到达时刻、盘旋时间和降落时间：&quot;</span>, i + <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;aircraft[i].arrivalTime, &amp;aircraft[i].hoverTime, &amp;aircraft[i].landingTime);<br>    &#125;<br><br>    <span class="hljs-comment">// 判断是否可以全部安全降落</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">canLand</span>(aircraft, N))<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;所有飞机可以全部安全降落。\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;有飞机无法安全降落。\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">free</span>(aircraft);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++</p><p><img src="https://aitechtogether.com/wp-content/uploads_new/2024/02/4deda4c7-6b33-4d30-8328-383b53d02b03.webp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">max</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (a &gt; b) ? a : b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minDeletionsForChain</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> N)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> dp[N];<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        dp[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j] % <span class="hljs-number">10</span> == arr[i] / <span class="hljs-number">10</span>) &#123;<br>                dp[i] = <span class="hljs-built_in">max</span>(dp[i], dp[j] + <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        result = <span class="hljs-built_in">max</span>(result, dp[i]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> N - result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> N;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入数列的长度 N：&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;N);<br><br>    <span class="hljs-type">int</span> arr[N];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入数列 A1, A2, ..., AN：&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;arr[i]);<br>    &#125;<br><br>    <span class="hljs-type">int</span> deletions = <span class="hljs-built_in">minDeletionsForChain</span>(arr, N);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;最少需要删除 %d 个数，使剩下的序列是接龙序列。\n&quot;</span>, deletions);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++</p><p><img src="https://aitechtogether.com/wp-content/uploads_new/2024/02/ca09cdeb-e817-4a6a-a586-3f4a9e36629a.webp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ROW 4</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> COL 5</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">char</span> grid[ROW][COL], <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= ROW || j &lt; <span class="hljs-number">0</span> || j &gt;= COL || grid[i][j] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    grid[i][j] = <span class="hljs-string">&#x27;0&#x27;</span>;  <span class="hljs-comment">// 标记当前格子为已访问</span><br><br>    <span class="hljs-comment">// 上下左右四个方向进行深度优先搜索</span><br>    <span class="hljs-built_in">dfs</span>(grid, i - <span class="hljs-number">1</span>, j);<br>    <span class="hljs-built_in">dfs</span>(grid, i + <span class="hljs-number">1</span>, j);<br>    <span class="hljs-built_in">dfs</span>(grid, i, j - <span class="hljs-number">1</span>);<br>    <span class="hljs-built_in">dfs</span>(grid, i, j + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numIslands</span><span class="hljs-params">(<span class="hljs-type">char</span> grid[ROW][COL])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; ROW; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; COL; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                ++count;<br>                <span class="hljs-built_in">dfs</span>(grid, i, j);  <span class="hljs-comment">// 深度优先搜索标记当前岛屿</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> grid[ROW][COL] = &#123;<br>        &#123;<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>&#125;,<br>        &#123;<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>&#125;,<br>        &#123;<span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>&#125;,<br>        &#123;<span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;1&#x27;</span>&#125;<br>    &#125;;<br><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">numIslands</span>(grid);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;岛屿数量: %d\n&quot;</span>, result);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++</p><p><img src="https://aitechtogether.com/wp-content/uploads_new/2024/02/14af3cfc-ca89-4b75-941b-7cc6481b887b.webp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-comment">// 计算以c1开头、以c2结尾的子串个数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countShortenedSubstrings</span><span class="hljs-params">(<span class="hljs-type">char</span> S[], <span class="hljs-type">char</span> c1, <span class="hljs-type">char</span> c2, <span class="hljs-type">int</span> K)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-built_in">strlen</span>(S);<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (S[i] == c1) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (S[j] == c2) &#123;<br>                    <span class="hljs-comment">// 计算子串长度</span><br>                    <span class="hljs-type">int</span> length = j - i + <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">if</span> (length &gt;= K) &#123;<br>                        <span class="hljs-comment">// 符合条件，计数器加一</span><br>                        count++;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span> S[<span class="hljs-number">100</span>];<br>    <span class="hljs-type">char</span> c1, c2;<br>    <span class="hljs-type">int</span> K;<br><br>    <span class="hljs-comment">// 读取输入</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter the string S: &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, S);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter the characters c1 and c2: &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot; %c %c&quot;</span>, &amp;c1, &amp;c2);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter the value of K: &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;K);<br><br>    <span class="hljs-comment">// 计算结果并输出</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">countShortenedSubstrings</span>(S, c1, c2, K);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Number of shortened substrings: %d\n&quot;</span>, result);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++</p><p><img src="https://aitechtogether.com/wp-content/uploads_new/2024/02/96485d5e-573f-4e60-b06f-55aecd76cf55.webp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-comment">// 计算以c1开头、以c2结尾的子串个数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countShortenedSubstrings</span><span class="hljs-params">(<span class="hljs-type">char</span> S[], <span class="hljs-type">char</span> c1, <span class="hljs-type">char</span> c2, <span class="hljs-type">int</span> K)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-built_in">strlen</span>(S);<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (S[i] == c1) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (S[j] == c2) &#123;<br>                    <span class="hljs-comment">// 计算子串长度</span><br>                    <span class="hljs-type">int</span> length = j - i + <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">if</span> (length &gt;= K) &#123;<br>                        <span class="hljs-comment">// 符合条件，计数器加一</span><br>                        count++;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span> S[<span class="hljs-number">100</span>];<br>    <span class="hljs-type">char</span> c1, c2;<br>    <span class="hljs-type">int</span> K;<br><br>    <span class="hljs-comment">// 读取输入</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter the string S: &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, S);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter the characters c1 and c2: &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot; %c %c&quot;</span>, &amp;c1, &amp;c2);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter the value of K: &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;K);<br><br>    <span class="hljs-comment">// 计算结果并输出</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">countShortenedSubstrings</span>(S, c1, c2, K);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Number of shortened substrings: %d\n&quot;</span>, result);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++</p><p><img src="https://aitechtogether.com/wp-content/uploads_new/2024/02/2afe4c9e-38fc-4d3e-a152-d7e2f3093fe5.webp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_NODES 100</span><br><br><span class="hljs-type">int</span> adjacency_list[MAX_NODES][MAX_NODES];<br><span class="hljs-type">int</span> travel_times[MAX_NODES][MAX_NODES];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> node, <span class="hljs-type">int</span> parent, <span class="hljs-type">int</span> skip_node, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-type">int</span> total_time = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (i != parent &amp;&amp; adjacency_list[node][i]) &#123;<br>            total_time += <span class="hljs-built_in">dfs</span>(i, node, skip_node, n);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果当前节点不是要跳过的节点，累加其摆渡车时间</span><br>    <span class="hljs-keyword">if</span> (node != skip_node) &#123;<br>        total_time += travel_times[node][parent] + travel_times[parent][node];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> total_time;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calculate_travel_time</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> skip_node)</span> </span>&#123;<br>    <span class="hljs-type">int</span> total_time = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; k; ++i) &#123;<br>        total_time += <span class="hljs-built_in">dfs</span>(i, <span class="hljs-number">-1</span>, skip_node, n);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> total_time;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">6</span>;<br>    <span class="hljs-type">int</span> k = <span class="hljs-number">4</span>;<br>    <span class="hljs-type">int</span> skip_node = <span class="hljs-number">2</span>;<br><br>    <span class="hljs-comment">// 示例邻接列表和摆渡车时间</span><br>    <span class="hljs-type">int</span> adjacency_list[<span class="hljs-number">6</span>][<span class="hljs-number">6</span>] = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;,<br>                                &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<br>                                &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,<br>                                &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;,<br>                                &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;,<br>                                &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;&#125;;<br><br>    <span class="hljs-type">int</span> travel_times[<span class="hljs-number">6</span>][<span class="hljs-number">6</span>] = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;,<br>                              &#123;<span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>&#125;,<br>                              &#123;<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>&#125;,<br>                              &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;,<br>                              &#123;<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;,<br>                              &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;&#125;;<br><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">calculate_travel_time</span>(n, k, skip_node);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;If skip node %d, total travel time: %d\n&quot;</span>, skip_node, result);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++</p><p><img src="https://aitechtogether.com/wp-content/uploads_new/2024/02/84407906-60cf-4c55-bf00-78fcb7fe3cf1.webp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_NODES 1000</span><br><br><span class="hljs-comment">// 表示树的邻接列表</span><br><span class="hljs-type">int</span> adjacency_list[MAX_NODES][MAX_NODES];<br><span class="hljs-comment">// 标记边是否被访问过</span><br><span class="hljs-type">bool</span> visited[MAX_NODES][MAX_NODES];<br><span class="hljs-comment">// 结果数组，记录断开的边的编号</span><br><span class="hljs-type">int</span> result[MAX_NODES];<br><span class="hljs-comment">// 当前断开的边的编号</span><br><span class="hljs-type">int</span> result_index;<br><br><span class="hljs-comment">// 深度优先搜索函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> node, <span class="hljs-type">int</span> parent, <span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (adjacency_list[node][i] &amp;&amp; !visited[node][i]) &#123;<br>            visited[node][i] = visited[i][node] = <span class="hljs-literal">true</span>;<br><br>            <span class="hljs-comment">// 如果当前边的两个端点分别为a和b，说明这条边需要断开</span><br>            <span class="hljs-keyword">if</span> ((node == a &amp;&amp; i == b) || (node == b &amp;&amp; i == a)) &#123;<br>                result[result_index++] = i + <span class="hljs-number">1</span>; <span class="hljs-comment">// 存储边的编号（从1开始）</span><br>            &#125;<br><br>            <span class="hljs-built_in">dfs</span>(i, node, a, b, n);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);<br><br>    <span class="hljs-comment">// 初始化邻接列表和visited数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;<br>        <span class="hljs-type">int</span> u, v;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);<br>        adjacency_list[u - <span class="hljs-number">1</span>][v - <span class="hljs-number">1</span>] = adjacency_list[v - <span class="hljs-number">1</span>][u - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        visited[u - <span class="hljs-number">1</span>][v - <span class="hljs-number">1</span>] = visited[v - <span class="hljs-number">1</span>][u - <span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 遍历每个数对，进行DFS判断是否可以断开</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>        <span class="hljs-type">int</span> a, b;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);<br><br>        <span class="hljs-comment">// 重置结果数组和结果索引</span><br>        result_index = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-comment">// 进行DFS遍历</span><br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, a - <span class="hljs-number">1</span>, b - <span class="hljs-number">1</span>, n);<br><br>        <span class="hljs-comment">// 如果结果索引为0，说明没有找到需要断开的边</span><br>        <span class="hljs-keyword">if</span> (result_index == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-1\n&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 输出断开的边的编号</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; result_index; ++j) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, result[j]);<br>            &#125;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++</p><h2 id="三、十四届C-C-程序设计A组试题"><a href="#三、十四届C-C-程序设计A组试题" class="headerlink" title="三、十四届C&#x2F;C++程序设计A组试题"></a>三、十四届C&#x2F;C++程序设计A组试题</h2><p><img src="https://aitechtogether.com/wp-content/uploads_new/2024/02/b1beb923-93ca-45f6-af4a-204fdc84c480.webp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// 检查一个数字是否是幸运数字的函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">is_lucky_number</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>    <span class="hljs-type">char</span> num_str[<span class="hljs-number">20</span>]; <span class="hljs-comment">// 用于将数字转换为字符串以便处理</span><br>    <span class="hljs-built_in">sprintf</span>(num_str, <span class="hljs-string">&quot;%d&quot;</span>, num);<br>    <span class="hljs-type">int</span> length = <span class="hljs-built_in">strlen</span>(num_str);<br><br>    <span class="hljs-comment">// 如果数字的位数为奇数，则不是幸运数字</span><br>    <span class="hljs-keyword">if</span> (length % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 返回假</span><br>    &#125;<br><br>    <span class="hljs-type">int</span> half_length = length / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> first_half_sum = <span class="hljs-number">0</span>, second_half_sum = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 计算前半部分数字的和</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; half_length; i++) &#123;<br>        first_half_sum += num_str[i] - <span class="hljs-string">&#x27;0&#x27;</span>; <span class="hljs-comment">// 将字符转换为数字</span><br>    &#125;<br><br>    <span class="hljs-comment">// 计算后半部分数字的和</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = half_length; i &lt; length; i++) &#123;<br>        second_half_sum += num_str[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断前半部分和后半部分是否相等</span><br>    <span class="hljs-keyword">return</span> first_half_sum == second_half_sum;<br>&#125;<br><br><span class="hljs-comment">// 计算在给定范围内的幸运数字的数量</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">count_lucky_numbers</span><span class="hljs-params">(<span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 遍历给定范围内的所有数字</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num = start; num &lt;= end; num++) &#123;<br>        <span class="hljs-comment">// 如果是幸运数字，增加计数</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_lucky_number</span>(num)) &#123;<br>            count++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> start_range = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> end_range = <span class="hljs-number">100000000</span>;<br><br>    <span class="hljs-comment">// 调用函数计算幸运数字的数量</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">count_lucky_numbers</span>(start_range, end_range);<br><br>    <span class="hljs-comment">// 打印结果</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;There are %d lucky numbers between %d and %d.\n&quot;</span>, result, start_range, end_range);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++</p><p><img src="https://aitechtogether.com/wp-content/uploads_new/2024/02/4f77d2d0-12b2-45bf-b520-35ba833f4370.webp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// 定义最大题目数和最大分数</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_QUESTIONS 30</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_SCORE 100</span><br><br><span class="hljs-comment">// 计算小蓝所有可能的答题情况数量的函数</span><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">count_possible_ways</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> target_score = <span class="hljs-number">70</span>;<br>    <span class="hljs-type">int</span> num_questions = <span class="hljs-number">30</span>;<br><br>    <span class="hljs-comment">// 初始化动态规划数组</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> dp[MAX_QUESTIONS + <span class="hljs-number">1</span>][MAX_SCORE + <span class="hljs-number">1</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 遍历每一道题目</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= num_questions; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= target_score; j++) &#123;<br>            <span class="hljs-comment">// 如果不答这道题</span><br>            dp[i][j] += dp[i - <span class="hljs-number">1</span>][j];<br><br>            <span class="hljs-comment">// 如果答对这道题，分数增加10</span><br>            <span class="hljs-keyword">if</span> (j &gt;= <span class="hljs-number">10</span>) &#123;<br>                dp[i][j] += dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">10</span>];<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[num_questions][target_score];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 调用函数计算小蓝所有可能的答题情况数量</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> possible_ways = <span class="hljs-built_in">count_possible_ways</span>();<br><br>    <span class="hljs-comment">// 打印结果</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;小蓝所有可能的答题情况有 %lld 种。\n&quot;</span>, possible_ways);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++</p><p><img src="https://aitechtogether.com/wp-content/uploads_new/2024/02/f9d69920-cb70-4e3f-88b1-e11cb553a1f9.webp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><br><span class="hljs-comment">// 判断是否存在整数y和z，使得x = y^2 - z^2</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">has_yz</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> limit = (<span class="hljs-type">int</span>)<span class="hljs-built_in">sqrt</span>(x);<br><br>    <span class="hljs-comment">// 遍历y的可能取值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = <span class="hljs-number">1</span>; y &lt;= limit; y++) &#123;<br>        <span class="hljs-type">int</span> z_square = y * y - x;<br><br>        <span class="hljs-comment">// 如果z的平方为非负数且是完全平方数</span><br>        <span class="hljs-keyword">if</span> (z_square &gt;= <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">sqrt</span>(z_square) == (<span class="hljs-type">int</span>)<span class="hljs-built_in">sqrt</span>(z_square)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 存在满足条件的y和z</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 不存在满足条件的y和z</span><br>&#125;<br><br><span class="hljs-comment">// 计算满足条件的x的数量</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">count_x</span><span class="hljs-params">(<span class="hljs-type">int</span> L, <span class="hljs-type">int</span> R)</span> </span>&#123;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 遍历给定范围内的所有x</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = L; x &lt;= R; x++) &#123;<br>        <span class="hljs-comment">// 如果存在整数y和z，使得x = y^2 - z^2</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">has_yz</span>(x)) &#123;<br>            count++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> L, R;<br><br>    <span class="hljs-comment">// 输入L和R的值</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter the values of L and R: &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;L, &amp;R);<br><br>    <span class="hljs-comment">// 调用函数计算满足条件的x的数量</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">count_x</span>(L, R);<br><br>    <span class="hljs-comment">// 输出结果</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;There are %d numbers x in the range [%d, %d] satisfying the condition.\n&quot;</span>, result, L, R);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++</p><p><img src="https://aitechtogether.com/wp-content/uploads_new/2024/02/bafbb827-7dae-4c98-9d1a-3536d240062d.webp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-comment">// 计算满足条件的不同子串选择方案的数量</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">count_substring_choices</span><span class="hljs-params">(<span class="hljs-type">char</span> num_str[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-built_in">strlen</span>(num_str);<br>    <span class="hljs-type">int</span> num = <span class="hljs-built_in">atoi</span>(num_str);<br>    <span class="hljs-type">int</span> choices = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 记录不同的选择方案数量</span><br>    <span class="hljs-type">char</span> substring[<span class="hljs-number">20</span>];  <span class="hljs-comment">// 假设数字最大长度为20</span><br><br>    <span class="hljs-comment">// 从左往右遍历，找到第一个递减的位置</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (num_str[i] &gt; num_str[i + <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-comment">// 在递减位置及其左侧选择子串</span><br>            <span class="hljs-built_in">strncpy</span>(substring, num_str, i + <span class="hljs-number">1</span>);<br>            substring[i + <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;  <span class="hljs-comment">// 添加字符串结束符</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;选择子串: %s\n&quot;</span>, substring);<br>            choices++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> choices;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span> num_str[<span class="hljs-number">20</span>];  <span class="hljs-comment">// 假设数字最大长度为20</span><br><br>    <span class="hljs-comment">// 输入数字字符串</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入数字字符串: &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, num_str);<br><br>    <span class="hljs-comment">// 调用函数计算满足条件的不同子串选择方案数量</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">count_substring_choices</span>(num_str);<br><br>    <span class="hljs-comment">// 输出结果</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;不同的子串选择方案数: %d\n&quot;</span>, result);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++</p><p><img src="https://aitechtogether.com/wp-content/uploads_new/2024/02/de2d665d-ab0e-401d-8b31-2a6fc6e93fef.webp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_COLORS 1001</span><br><br><span class="hljs-comment">// 结点的定义</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    <span class="hljs-type">int</span> color;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span>* children[<span class="hljs-number">1001</span>];<br>    <span class="hljs-type">int</span> num_children;<br>&#125;;<br><br><span class="hljs-comment">// 创建一个新的结点</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span>* <span class="hljs-built_in">createNode</span>(<span class="hljs-type">int</span> color) &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span>* node = (<span class="hljs-keyword">struct</span> TreeNode*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> TreeNode));<br>    node-&gt;color = color;<br>    node-&gt;num_children = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br><br><span class="hljs-comment">// DFS遍历并统计子树颜色个数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> TreeNode* root, <span class="hljs-type">int</span> color_count[MAX_COLORS], <span class="hljs-type">int</span>* balanced_trees)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    color_count[root-&gt;color]++;<br><br>    <span class="hljs-comment">// 递归地处理子结点</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; root-&gt;num_children; i++) &#123;<br>        <span class="hljs-built_in">dfs</span>(root-&gt;children[i], color_count, balanced_trees);<br>    &#125;<br><br>    <span class="hljs-comment">// 检查当前子树是否是颜色平衡树</span><br>    <span class="hljs-type">int</span> min_count = color_count[root-&gt;color];<br>    <span class="hljs-type">int</span> max_count = color_count[root-&gt;color];<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; MAX_COLORS; i++) &#123;<br>        <span class="hljs-keyword">if</span> (color_count[i] &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (color_count[i] &lt; min_count) min_count = color_count[i];<br>            <span class="hljs-keyword">if</span> (color_count[i] &gt; max_count) max_count = color_count[i];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (max_count == min_count) (*balanced_trees)++;<br>    color_count[root-&gt;color]--;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, i;<br>    <span class="hljs-type">int</span> color_count[MAX_COLORS] = &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 记录每种颜色的个数</span><br>    <span class="hljs-type">int</span> balanced_trees = <span class="hljs-number">0</span>; <span class="hljs-comment">// 颜色平衡子树的数量</span><br><br>    <span class="hljs-comment">// 读取结点个数</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span>* nodes[n + <span class="hljs-number">1</span>]; <span class="hljs-comment">// 结点数组</span><br>    <span class="hljs-comment">// 初始化结点数组</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">int</span> color;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;color);<br>        nodes[i] = <span class="hljs-built_in">createNode</span>(color);<br>    &#125;<br><br>    <span class="hljs-comment">// 构建树</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-type">int</span> parent;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;parent);<br>        nodes[parent]-&gt;children[nodes[parent]-&gt;num_children++] = nodes[i];<br>    &#125;<br><br>    <span class="hljs-comment">// DFS遍历树并统计颜色平衡子树的数量</span><br>    <span class="hljs-built_in">dfs</span>(nodes[<span class="hljs-number">1</span>], color_count, &amp;balanced_trees);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, balanced_trees);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++</p><p><img src="https://aitechtogether.com/wp-content/uploads_new/2024/02/f2c49888-3c12-4e1c-833a-ee0fe17e0379.webp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// 定义最大瓜的数量和最大重量</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_N 100</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_WEIGHT 1000</span><br><br><span class="hljs-comment">// 动态规划函数，返回最少需要劈的瓜的数量</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minimumCutting</span><span class="hljs-params">(<span class="hljs-type">int</span> weights[], <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> targetWeight)</span> </span>&#123;<br>    <span class="hljs-comment">// 定义动态规划数组</span><br>    <span class="hljs-type">int</span> dp[MAX_N + <span class="hljs-number">1</span>][MAX_WEIGHT + <span class="hljs-number">1</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><br>    <span class="hljs-comment">// 初始化动态规划数组</span><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-comment">// 填充动态规划数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= targetWeight; j++) &#123;<br>            dp[i][j] = dp[i - <span class="hljs-number">1</span>][j];<br>            <span class="hljs-keyword">if</span> (j &gt;= weights[i - <span class="hljs-number">1</span>]) &#123;<br>                dp[i][j] |= dp[i - <span class="hljs-number">1</span>][j - weights[i - <span class="hljs-number">1</span>]];<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果无法得到总重为targetWeight的瓜，返回-1</span><br>    <span class="hljs-keyword">if</span> (dp[n][targetWeight] == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 回溯找到最少需要劈的瓜的数量</span><br>    <span class="hljs-type">int</span> cuts = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> currentWeight = targetWeight;<br>    <span class="hljs-type">int</span> currentMelon = n;<br><br>    <span class="hljs-keyword">while</span> (currentWeight &gt; <span class="hljs-number">0</span> &amp;&amp; currentMelon &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (dp[currentMelon - <span class="hljs-number">1</span>][currentWeight]) &#123;<br>            currentMelon--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            currentWeight -= weights[currentMelon - <span class="hljs-number">1</span>];<br>            cuts++;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> cuts;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 示例用法</span><br>    <span class="hljs-type">int</span> weights[] = &#123;<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>&#125;;<br>    <span class="hljs-type">int</span> n = <span class="hljs-built_in">sizeof</span>(weights) / <span class="hljs-built_in">sizeof</span>(weights[<span class="hljs-number">0</span>]);<br>    <span class="hljs-type">int</span> target = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">minimumCutting</span>(weights, n, target);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, result);  <span class="hljs-comment">// 输出 2</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++</p><p><img src="https://aitechtogether.com/wp-content/uploads_new/2024/02/49081d41-1734-4754-b6ec-f50a250be892.webp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;limits.h&gt;</span></span><br><br><span class="hljs-comment">// 定义无穷大值</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF INT_MAX</span><br><br><span class="hljs-comment">// 定义设备和连接的结构体</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br>    <span class="hljs-type">int</span> to;<br>    <span class="hljs-type">int</span> weight;<br>&#125;;<br><br><span class="hljs-comment">// 定义图的结构体</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Graph</span> &#123;<br>    <span class="hljs-type">int</span> vertices;           <span class="hljs-comment">// 设备的数量</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span>** adjMatrix; <span class="hljs-comment">// 邻接矩阵表示的图</span><br>&#125;;<br><br><span class="hljs-comment">// 初始化图</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Graph</span>* <span class="hljs-built_in">initializeGraph</span>(<span class="hljs-type">int</span> vertices) &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Graph</span>* graph = (<span class="hljs-keyword">struct</span> Graph*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> Graph));<br>    graph-&gt;vertices = vertices;<br><br>    <span class="hljs-comment">// 为邻接矩阵分配内存</span><br>    graph-&gt;adjMatrix = (<span class="hljs-keyword">struct</span> Edge**)<span class="hljs-built_in">malloc</span>(vertices * <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> Edge*));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; vertices; ++i) &#123;<br>        graph-&gt;adjMatrix[i] = (<span class="hljs-keyword">struct</span> Edge*)<span class="hljs-built_in">malloc</span>(vertices * <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> Edge));<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化邻接矩阵</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; vertices; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; vertices; ++j) &#123;<br>            graph-&gt;adjMatrix[i][j].to = <span class="hljs-number">-1</span>; <span class="hljs-comment">// 表示没有连接</span><br>            graph-&gt;adjMatrix[i][j].weight = INF; <span class="hljs-comment">// 初始化为无穷大</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> graph;<br>&#125;<br><br><span class="hljs-comment">// 添加无向边到图</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> Graph* graph, <span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to, <span class="hljs-type">int</span> weight)</span> </span>&#123;<br>    graph-&gt;adjMatrix[from][to].to = to;<br>    graph-&gt;adjMatrix[from][to].weight = weight;<br><br>    <span class="hljs-comment">// 由于是无向图，需要添加反向边</span><br>    graph-&gt;adjMatrix[to][from].to = from;<br>    graph-&gt;adjMatrix[to][from].weight = weight;<br>&#125;<br><br><span class="hljs-comment">// Dijkstra算法计算从源节点到所有其他节点的最短路径</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dijkstra</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> Graph* graph, <span class="hljs-type">int</span> source, <span class="hljs-type">int</span>* dist)</span> </span>&#123;<br>    <span class="hljs-type">int</span> visited[graph-&gt;vertices];<br><br>    <span class="hljs-comment">// 初始化距离数组和访问数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; graph-&gt;vertices; ++i) &#123;<br>        dist[i] = INF;<br>        visited[i] = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    dist[source] = <span class="hljs-number">0</span>; <span class="hljs-comment">// 源节点到自身的距离为0</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> count = <span class="hljs-number">0</span>; count &lt; graph-&gt;vertices - <span class="hljs-number">1</span>; ++count) &#123;<br>        <span class="hljs-type">int</span> u = <span class="hljs-number">-1</span>;<br><br>        <span class="hljs-comment">// 选择未访问的节点中距离最小的节点</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; graph-&gt;vertices; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[i] &amp;&amp; (u == <span class="hljs-number">-1</span> || dist[i] &lt; dist[u]))<br>                u = i;<br>        &#125;<br><br>        visited[u] = <span class="hljs-number">1</span>; <span class="hljs-comment">// 标记节点为已访问</span><br><br>        <span class="hljs-comment">// 更新未访问节点的距离</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = <span class="hljs-number">0</span>; v &lt; graph-&gt;vertices; ++v) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[v] &amp;&amp; graph-&gt;adjMatrix[u][v].to != <span class="hljs-number">-1</span> &amp;&amp;<br>                dist[u] + graph-&gt;adjMatrix[u][v].weight &lt; dist[v]) &#123;<br>                dist[v] = dist[u] + graph-&gt;adjMatrix[u][v].weight;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 计算两个设备之间的通信稳定性</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">calculateStability</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>* dist, <span class="hljs-type">int</span> destination)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (dist[destination] == INF) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>; <span class="hljs-comment">// 如果没有路径，则返回-1</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dist[destination];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;m); <span class="hljs-comment">// 输入设备数量和连接数量</span><br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Graph</span>* graph = <span class="hljs-built_in">initializeGraph</span>(n);<br><br>    <span class="hljs-comment">// 输入物理连接的信息</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>        <span class="hljs-type">int</span> u, v, w;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;u, &amp;v, &amp;w);<br>        <span class="hljs-built_in">addEdge</span>(graph, u - <span class="hljs-number">1</span>, v - <span class="hljs-number">1</span>, w); <span class="hljs-comment">// 设备编号从1开始，转换为0开始的索引</span><br>    &#125;<br><br>    <span class="hljs-type">int</span> q;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;q); <span class="hljs-comment">// 查询数量</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; ++i) &#123;<br>        <span class="hljs-type">int</span> x, y;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);<br><br>        <span class="hljs-type">int</span>* distFromX = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(n * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>        <span class="hljs-built_in">dijkstra</span>(graph, x - <span class="hljs-number">1</span>, distFromX);<br>        <span class="hljs-type">int</span> stability = <span class="hljs-built_in">calculateStability</span>(distFromX, y - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, stability);<br><br>        <span class="hljs-built_in">free</span>(distFromX);<br>    &#125;<br><br>    <span class="hljs-comment">// 释放内存</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-built_in">free</span>(graph-&gt;adjMatrix[i]);<br>    &#125;<br>    <span class="hljs-built_in">free</span>(graph-&gt;adjMatrix);<br>    <span class="hljs-built_in">free</span>(graph);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++</p><p><img src="https://aitechtogether.com/wp-content/uploads_new/2024/02/81c398ed-ccf5-4c29-b554-22f27f14fdf7.webp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// 计算数组中每个子段的异或和并求和</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n); <span class="hljs-comment">// 输入数组长度</span><br><br>    <span class="hljs-type">int</span> A[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;A[i]); <span class="hljs-comment">// 输入数组元素</span><br>    &#125;<br><br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 计算每个子段的异或和并求和</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-type">int</span> XOR_sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; n; ++j) &#123;<br>            XOR_sum ^= A[j]; <span class="hljs-comment">// 计算子段的异或和</span><br>            result += XOR_sum; <span class="hljs-comment">// 将每个子段的异或和累加到结果中</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, result);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++</p><p><img src="https://aitechtogether.com/wp-content/uploads_new/2024/02/260d169f-a5f3-458c-81ed-de9802f89bc9.webp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 4</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> M 4</span><br><br><span class="hljs-comment">// 检查当前位置是否合法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">is_valid</span><span class="hljs-params">(<span class="hljs-type">int</span> board[N][M], <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> target_color)</span> </span>&#123;<br>    <span class="hljs-comment">// 检查是否越界</span><br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= N || j &lt; <span class="hljs-number">0</span> || j &gt;= M) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 检查当前位置是否已填充</span><br>    <span class="hljs-keyword">if</span> (board[i][j] != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 统计周围黑色方格的数量</span><br>    <span class="hljs-type">int</span> count_black = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = i - <span class="hljs-number">1</span>; x &lt;= i + <span class="hljs-number">1</span>; x++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y = j - <span class="hljs-number">1</span>; y &lt;= j + <span class="hljs-number">1</span>; y++) &#123;<br>            <span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; N &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; M &amp;&amp; board[x][y] == <span class="hljs-number">1</span>) &#123;<br>                count_black++;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 检查是否符合数字约束</span><br>    <span class="hljs-keyword">return</span> count_black == target_color;<br>&#125;<br><br><span class="hljs-comment">// 填充周围的方格</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fill_pixels</span><span class="hljs-params">(<span class="hljs-type">int</span> board[N][M], <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> color)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= N || j &lt; <span class="hljs-number">0</span> || j &gt;= M || board[i][j] != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    board[i][j] = color;<br><br>    <span class="hljs-comment">// 递归填充周围的方格</span><br>    <span class="hljs-built_in">fill_pixels</span>(board, i - <span class="hljs-number">1</span>, j, color);<br>    <span class="hljs-built_in">fill_pixels</span>(board, i + <span class="hljs-number">1</span>, j, color);<br>    <span class="hljs-built_in">fill_pixels</span>(board, i, j - <span class="hljs-number">1</span>, color);<br>    <span class="hljs-built_in">fill_pixels</span>(board, i, j + <span class="hljs-number">1</span>, color);<br>&#125;<br><br><span class="hljs-comment">// 解决像素放置问题</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve_puzzle</span><span class="hljs-params">(<span class="hljs-type">int</span> board[N][M])</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; M; j++) &#123;<br>            <span class="hljs-keyword">if</span> (board[i][j] != <span class="hljs-number">-1</span>) &#123;<br>                <span class="hljs-comment">// 如果当前方格有数字约束，则进行DFS填充</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_valid</span>(board, i, j, board[i][j])) &#123;<br>                    <span class="hljs-built_in">fill_pixels</span>(board, i, j, <span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-built_in">fill_pixels</span>(board, i, j, <span class="hljs-number">0</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> initial_board[N][M] = &#123;<br>        &#123;<span class="hljs-number">-1</span>,  <span class="hljs-number">2</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;,<br>        &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>,  <span class="hljs-number">3</span>, <span class="hljs-number">-1</span>&#125;,<br>        &#123; <span class="hljs-number">4</span>, <span class="hljs-number">-1</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;,<br>        &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>&#125;<br>    &#125;;<br><br>    <span class="hljs-comment">// 解决问题</span><br>    <span class="hljs-built_in">solve_puzzle</span>(initial_board);<br><br>    <span class="hljs-comment">// 打印填充后的棋盘</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; M; j++) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, initial_board[i][j]);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++</p><p><img src="https://aitechtogether.com/wp-content/uploads_new/2024/02/94c6e14c-dc12-42d6-b595-b4fc43574358.webp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">// 函数声明</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">min_operations</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 例如，假设有10个硬币</span><br>    <span class="hljs-type">int</span> n = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-comment">// 调用函数计算最少需要多少次操作</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">min_operations</span>(n);<br><br>    <span class="hljs-comment">// 打印结果</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;最少需要 %d 次操作\n&quot;</span>, result);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 求最少需要多少次操作使所有硬币朝上</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">min_operations</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 记录操作次数</span><br><br>    <span class="hljs-comment">// 从第2个硬币开始，依次判断每个位置的硬币朝上还是朝下</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-comment">// 如果当前位置的硬币朝下，则需要翻转</span><br>        <span class="hljs-keyword">if</span> (n % i == <span class="hljs-number">0</span>) &#123;<br>            count++;  <span class="hljs-comment">// 记录操作次数增加</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++</p><h2 id="四、十三届C-C-程序设计C组试题"><a href="#四、十三届C-C-程序设计C组试题" class="headerlink" title="四、十三届C&#x2F;C++程序设计C组试题"></a>四、十三届C&#x2F;C++程序设计C组试题</h2><p><img src="https://aitechtogether.com/wp-content/uploads_new/2024/02/1031e081-097f-4d78-898a-8f90dbed172f.webp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-comment">// 比较函数用于qsort</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compareChars</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *a, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (*(<span class="hljs-type">char</span> *)a - *(<span class="hljs-type">char</span> *)b);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 原始字符串</span><br>    <span class="hljs-type">char</span> originalString[] = <span class="hljs-string">&quot;WHERETHEREISAWILLTHEREISAWAY&quot;</span>;<br><br>    <span class="hljs-comment">// 获取字符串长度</span><br>    <span class="hljs-type">int</span> length = <span class="hljs-built_in">strlen</span>(originalString);<br><br>    <span class="hljs-comment">// 使用qsort按字母表顺序排序字符串</span><br>    <span class="hljs-built_in">qsort</span>(originalString, length, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">char</span>), compareChars);<br><br>    <span class="hljs-comment">// 输出排序后的字符串</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;排列之后的字符串：%s\n&quot;</span>, originalString);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++</p><p><img src="https://aitechtogether.com/wp-content/uploads_new/2024/02/4f91a6ff-8ca9-4624-9db0-f810683b6a3e.webp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">isInterestingTime</span><span class="hljs-params">(<span class="hljs-type">int</span> year, <span class="hljs-type">int</span> month, <span class="hljs-type">int</span> day, <span class="hljs-type">int</span> hour, <span class="hljs-type">int</span> minute)</span> </span>&#123;<br>    <span class="hljs-comment">// 将年份、月日、时分拼接成一个数字</span><br>    <span class="hljs-type">int</span> combinedNumber = year * <span class="hljs-number">1000000</span> + month * <span class="hljs-number">10000</span> + day * <span class="hljs-number">100</span> + hour * <span class="hljs-number">1</span> + minute * <span class="hljs-number">0.01</span>;<br><br>    <span class="hljs-comment">// 统计数字2和数字0的个数</span><br>    <span class="hljs-type">int</span> count2 = <span class="hljs-number">0</span>, count0 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (combinedNumber &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">int</span> digit = combinedNumber % <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">if</span> (digit == <span class="hljs-number">2</span>) &#123;<br>            count2++;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (digit == <span class="hljs-number">0</span>) &#123;<br>            count0++;<br>        &#125;<br>        combinedNumber /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 检查是否符合条件</span><br>    <span class="hljs-keyword">return</span> count2 == <span class="hljs-number">3</span> &amp;&amp; count0 == <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 遍历年份</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> year = <span class="hljs-number">1000</span>; year &lt;= <span class="hljs-number">9999</span>; year++) &#123;<br>        <span class="hljs-comment">// 遍历月份</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> month = <span class="hljs-number">1</span>; month &lt;= <span class="hljs-number">12</span>; month++) &#123;<br>            <span class="hljs-comment">// 遍历日期</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> day = <span class="hljs-number">1</span>; day &lt;= <span class="hljs-number">31</span>; day++) &#123;<br>                <span class="hljs-comment">// 遍历小时</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> hour = <span class="hljs-number">0</span>; hour &lt;= <span class="hljs-number">23</span>; hour++) &#123;<br>                    <span class="hljs-comment">// 遍历分钟</span><br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> minute = <span class="hljs-number">0</span>; minute &lt;= <span class="hljs-number">59</span>; minute++) &#123;<br>                        <span class="hljs-comment">// 检查是否符合条件</span><br>                        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isInterestingTime</span>(year, month, day, hour, minute)) &#123;<br>                            count++;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;符合条件的时间总数：%d\n&quot;</span>, count);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++</p><p><img src="https://aitechtogether.com/wp-content/uploads_new/2024/02/f3dc20ce-81d7-4e61-b288-04fe549709ba.webp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getPaperSize</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *paperName, <span class="hljs-type">int</span> *width, <span class="hljs-type">int</span> *height)</span> </span>&#123;<br>    <span class="hljs-comment">// 解析纸张名称</span><br>    <span class="hljs-type">char</span> sizeChar;<br>    <span class="hljs-type">int</span> foldCount;<br>    <span class="hljs-built_in">sscanf</span>(paperName, <span class="hljs-string">&quot;A%c%d&quot;</span>, &amp;sizeChar, &amp;foldCount);<br><br>    <span class="hljs-comment">// 根据A纸张的尺寸计算大小</span><br>    *width = <span class="hljs-number">1189</span>;<br>    *height = <span class="hljs-number">841</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; foldCount; i++) &#123;<br>        <span class="hljs-keyword">if</span> (*width &gt; *height) &#123;<br>            *width /= <span class="hljs-number">2</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            *height /= <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span> paperName[<span class="hljs-number">10</span>];<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;输入纸张名称（例如：A0, A1, A2）: &quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, paperName);<br><br>    <span class="hljs-type">int</span> width, height;<br>    <span class="hljs-built_in">getPaperSize</span>(paperName, &amp;width, &amp;height);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s纸张的大小为：%dmm x %dmm\n&quot;</span>, paperName, width, height);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++</p><p><img src="https://aitechtogether.com/wp-content/uploads_new/2024/02/f3e280db-a984-4904-85ec-0b7d8ace0d82.webp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">calculate_sum</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> S = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            S += (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)arr[i] * arr[j];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> S;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 替换这里的实际整数值和数组大小</span><br>    <span class="hljs-type">int</span> numbers[] = &#123;a1, a2, <span class="hljs-comment">/*...*/</span>, an&#125;;<br>    <span class="hljs-type">int</span> size = <span class="hljs-built_in">sizeof</span>(numbers) / <span class="hljs-built_in">sizeof</span>(numbers[<span class="hljs-number">0</span>]);<br><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = <span class="hljs-built_in">calculate_sum</span>(numbers, size);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The sum is: %lld\n&quot;</span>, result);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++</p><p><img src="https://aitechtogether.com/wp-content/uploads_new/2024/02/c0a2d995-5cf0-411c-859b-879e1b47f9bd.webp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-comment">// 计算数字的数位之和</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">digitSum</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span> </span>&#123;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (num &gt; <span class="hljs-number">0</span>) &#123;<br>        sum += num % <span class="hljs-number">10</span>;<br>        num /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-comment">// 比较两个数字，按照问题描述中的规则进行比较</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *a, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *b)</span> </span>&#123;<br>    <span class="hljs-type">int</span> digitSumA = <span class="hljs-built_in">digitSum</span>(*(<span class="hljs-type">int</span> *)a);<br>    <span class="hljs-type">int</span> digitSumB = <span class="hljs-built_in">digitSum</span>(*(<span class="hljs-type">int</span> *)b);<br><br>    <span class="hljs-keyword">if</span> (digitSumA != digitSumB) &#123;<br>        <span class="hljs-keyword">return</span> digitSumA - digitSumB;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> *(<span class="hljs-type">int</span> *)a - *(<span class="hljs-type">int</span> *)b;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 找到排序后的第m个元素</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findMthElement</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m)</span> </span>&#123;<br>    <span class="hljs-type">int</span> *numbers = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(n * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br><br>    <span class="hljs-comment">// 初始化数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        numbers[i] = i + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 使用qsort进行排序，使用自定义的比较函数</span><br>    <span class="hljs-built_in">qsort</span>(numbers, n, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>), compare);<br><br>    <span class="hljs-comment">// 排序后的第m个元素</span><br>    <span class="hljs-type">int</span> result = numbers[m - <span class="hljs-number">1</span>];<br><br>    <span class="hljs-built_in">free</span>(numbers);  <span class="hljs-comment">// 释放动态分配的内存</span><br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 替换这里的实际整数值</span><br>    <span class="hljs-type">int</span> n = <span class="hljs-number">100</span>; <span class="hljs-comment">// 假设排序范围是1到100</span><br>    <span class="hljs-type">int</span> m = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 找排序后的第10个元素</span><br><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">findMthElement</span>(n, m);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The %dth element after sorting is: %d\n&quot;</span>, m, result);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++</p><p><img src="https://aitechtogether.com/wp-content/uploads_new/2024/02/dc819394-216f-4fed-b89c-fe4337e38cea.webp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdbool.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_N 100000</span><br><br><span class="hljs-type">int</span> prefixXor[MAX_N + <span class="hljs-number">1</span>];<br><br><span class="hljs-comment">// 计算前缀异或数组</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">computePrefixXor</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    prefixXor[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        prefixXor[i] = prefixXor[i - <span class="hljs-number">1</span>] ^ arr[i - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 判断是否存在异或等于 x 的两个数</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">hasXorPair</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (prefixXor[r] ^ prefixXor[l - <span class="hljs-number">1</span>]) == x;<br>&#125;<br><br><span class="hljs-comment">// 查询阶段</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r = <span class="hljs-number">1</span>; r &lt;= n; r++) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">hasXorPair</span>(l, r, x)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);<br><br>    <span class="hljs-type">int</span> arr[MAX_N];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;arr[i]);<br>    &#125;<br><br>    <span class="hljs-comment">// 预处理阶段</span><br>    <span class="hljs-built_in">computePrefixXor</span>(arr, n);<br><br>    <span class="hljs-comment">// 查询阶段</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-type">int</span> l, x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;l, &amp;x);<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">query</span>(arr, n, l, x)) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;YES\n&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;NO\n&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++</p><p><img src="https://aitechtogether.com/wp-content/uploads_new/2024/02/ecd33a69-a7bd-44b6-95d1-5bba3cdf84df.webp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_LEN 100</span><br><br><span class="hljs-comment">// 删除边缘字符的函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">removeEdgeChars</span><span class="hljs-params">(<span class="hljs-type">char</span> s[])</span> </span>&#123;<br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">strlen</span>(s);<br>    <span class="hljs-type">int</span> i, j;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-comment">// 检查当前字符是否为边缘字符</span><br>        <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; i + <span class="hljs-number">1</span> &lt; len &amp;&amp; s[i] != s[i - <span class="hljs-number">1</span>] &amp;&amp; s[i] != s[i + <span class="hljs-number">1</span>]) &#123;<br>            <span class="hljs-comment">// 删除当前边缘字符</span><br>            <span class="hljs-keyword">for</span> (j = i; j &lt; len - <span class="hljs-number">1</span>; j++) &#123;<br>                s[j] = s[j + <span class="hljs-number">1</span>];<br>            &#125;<br>            s[len - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>            len--;<br>            i--; <span class="hljs-comment">// 回退一步，重新检查当前位置</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">char</span> s[MAX_LEN];<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, s);<br><br>    <span class="hljs-comment">// 进行24次操作</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">24</span>; i++) &#123;<br>        <span class="hljs-built_in">removeEdgeChars</span>(s);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strlen</span>(s) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;EMPTY\n&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, s);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++</p><p><img src="https://aitechtogether.com/wp-content/uploads_new/2024/02/cb407f96-26a2-4f75-80bf-8ddc5b82f440.webp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-comment">// 比较函数用于排序</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *a, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (*(<span class="hljs-type">int</span> *)b - *(<span class="hljs-type">int</span> *)a);<br>&#125;<br><br><span class="hljs-comment">// 计算查询结果的总和</span><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">calculateSum</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[], <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> queries[][<span class="hljs-number">2</span>], <span class="hljs-type">int</span> numQueries)</span> </span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 计算原始数组的和</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        sum += arr[i];<br>    &#125;<br><br>    <span class="hljs-comment">// 遍历每个查询范围</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numQueries; i++) &#123;<br>        <span class="hljs-type">int</span> L = queries[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> R = queries[i][<span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">// 将查询范围内的元素设置为当前数组中的最大值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = L - <span class="hljs-number">1</span>; j &lt; R; j++) &#123;<br>            sum += (arr[j] - arr[<span class="hljs-number">0</span>]);  <span class="hljs-comment">// 增加差值</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, numQueries;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;numQueries);<br><br>    <span class="hljs-type">int</span> arr[n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;arr[i]);<br>    &#125;<br><br>    <span class="hljs-comment">// 对数组进行排序</span><br>    <span class="hljs-built_in">qsort</span>(arr, n, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>), compare);<br><br>    <span class="hljs-type">int</span> queries[numQueries][<span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numQueries; i++) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;queries[i][<span class="hljs-number">0</span>], &amp;queries[i][<span class="hljs-number">1</span>]);<br>    &#125;<br><br>    <span class="hljs-comment">// 计算查询结果的总和</span><br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> result = <span class="hljs-built_in">calculateSum</span>(arr, n, queries, numQueries);<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, result);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++</p><p><img src="https://aitechtogether.com/wp-content/uploads_new/2024/02/d55cfb6c-87e8-490d-b976-7dbb8c5b622a.webp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span></span><br><br><span class="hljs-comment">// 技能结构体</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">int</span> A;<br>    <span class="hljs-type">int</span> B;<br>&#125; Skill;<br><br><span class="hljs-comment">// 比较函数用于排序技能</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compare_skills</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *a, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> ((Skill*)b)-&gt;A - ((Skill*)a)-&gt;A;<br>&#125;<br><br><span class="hljs-comment">// 计算最大攻击力提升</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">max_attack_increase</span><span class="hljs-params">(<span class="hljs-type">int</span> N, <span class="hljs-type">int</span> M, Skill skills[])</span> </span>&#123;<br>    <span class="hljs-comment">// 按攻击力提升排序</span><br>    <span class="hljs-built_in">qsort</span>(skills, N, <span class="hljs-built_in">sizeof</span>(Skill), compare_skills);<br><br>    <span class="hljs-type">int</span> total_attack_increase = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; ++i) &#123;<br>        <span class="hljs-type">int</span> max_upgrades = <span class="hljs-built_in">ceil</span>((<span class="hljs-type">double</span>)skills[i].A / skills[i].B);<br>        <span class="hljs-type">int</span> upgrades = <span class="hljs-built_in">fmin</span>(max_upgrades, M);<br>        total_attack_increase += upgrades * skills[i].A;<br>        M -= upgrades;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> total_attack_increase;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 示例输入</span><br>    <span class="hljs-type">int</span> N = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> M = <span class="hljs-number">5</span>;<br>    Skill skills[] = &#123;&#123;<span class="hljs-number">10</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">7</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">5</span>, <span class="hljs-number">1</span>&#125;&#125;;<br><br>    <span class="hljs-comment">// 计算最大攻击力提升</span><br>    <span class="hljs-type">int</span> result = <span class="hljs-built_in">max_attack_increase</span>(N, M, skills);<br><br>    <span class="hljs-comment">// 输出结果</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;最多可以提高的攻击力: %d\n&quot;</span>, result);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++</p><p><img src="https://aitechtogether.com/wp-content/uploads_new/2024/02/6e4c75b0-82eb-4271-b678-43234c6bf895.webp" alt="img"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-comment">// 哈希表节点</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> value;<br>    <span class="hljs-type">int</span> count;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>* next;<br>&#125; Node;<br><br><span class="hljs-comment">// 哈希表</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    Node** table;<br>    <span class="hljs-type">int</span> size;<br>&#125; HashMap;<br><br><span class="hljs-comment">// 初始化哈希表</span><br><span class="hljs-function">HashMap* <span class="hljs-title">createHashMap</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span> </span>&#123;<br>    HashMap* map = (HashMap*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(HashMap));<br>    map-&gt;size = size;<br>    map-&gt;table = (Node**)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Node*) * size);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; size; ++i) &#123;<br>        map-&gt;table[i] = <span class="hljs-literal">NULL</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> map;<br>&#125;<br><br><span class="hljs-comment">// 插入哈希表节点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertHashMap</span><span class="hljs-params">(HashMap* map, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>    <span class="hljs-type">int</span> index = <span class="hljs-built_in">abs</span>(value) % map-&gt;size;<br><br>    Node* newNode = (Node*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Node));<br>    newNode-&gt;value = value;<br>    newNode-&gt;count = <span class="hljs-number">1</span>;<br>    newNode-&gt;next = map-&gt;table[index];<br>    map-&gt;table[index] = newNode;<br>&#125;<br><br><span class="hljs-comment">// 查询哈希表节点</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">queryHashMap</span><span class="hljs-params">(HashMap* map, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>    <span class="hljs-type">int</span> index = <span class="hljs-built_in">abs</span>(value) % map-&gt;size;<br>    Node* current = map-&gt;table[index];<br><br>    <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">if</span> (current-&gt;value == value) &#123;<br>            <span class="hljs-keyword">return</span> current-&gt;count;<br>        &#125;<br>        current = current-&gt;next;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 计算区间内出现ki次的数的数量</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countOccurrences</span><span class="hljs-params">(<span class="hljs-type">int</span>* prefixSum, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, HashMap* map, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (left &gt; right) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (left == <span class="hljs-number">0</span>) &#123;<br>        count = <span class="hljs-built_in">queryHashMap</span>(map, prefixSum[right]);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        count = <span class="hljs-built_in">queryHashMap</span>(map, prefixSum[right] - prefixSum[left - <span class="hljs-number">1</span>]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> count == k ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">6</span>;<br>    <span class="hljs-type">int</span> A[] = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>&#125;;<br><br>    <span class="hljs-comment">// 计算前缀和</span><br>    <span class="hljs-type">int</span>* prefixSum = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>) * n);<br>    prefixSum[<span class="hljs-number">0</span>] = A[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>        prefixSum[i] = prefixSum[i - <span class="hljs-number">1</span>] + A[i];<br>    &#125;<br><br>    <span class="hljs-comment">// 构建哈希表</span><br>    HashMap* map = <span class="hljs-built_in">createHashMap</span>(n);<br><br>    <span class="hljs-comment">// 插入前缀和到哈希表</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-built_in">insertHashMap</span>(map, prefixSum[i]);<br>    &#125;<br><br>    <span class="hljs-comment">// 示例查询</span><br>    <span class="hljs-type">int</span> queries[][<span class="hljs-number">3</span>] = &#123;&#123;<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>&#125;&#125;;<br><br>    <span class="hljs-comment">// 处理查询</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) &#123;<br>        <span class="hljs-type">int</span> left = queries[i][<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> right = queries[i][<span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> k = queries[i][<span class="hljs-number">2</span>];<br><br>        <span class="hljs-type">int</span> result = <span class="hljs-built_in">countOccurrences</span>(prefixSum, left, right, map, k);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;在区间[%d, %d]内出现%d次的数有%d个\n&quot;</span>, left, right, k, result);<br>    &#125;<br><br>    <span class="hljs-comment">// 释放内存</span><br>    <span class="hljs-built_in">free</span>(prefixSum);<br>    <span class="hljs-built_in">free</span>(map-&gt;table);<br>    <span class="hljs-built_in">free</span>(map);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>C++</p><h2 id="五、十三届C-C-程序设计B组试题"><a href="#五、十三届C-C-程序设计B组试题" class="headerlink" title="五、十三届C&#x2F;C++程序设计B组试题"></a>五、十三届C&#x2F;C++程序设计B组试题</h2><h2 id="六、十三届C-C-程序设计A组试题"><a href="#六、十三届C-C-程序设计A组试题" class="headerlink" title="六、十三届C&#x2F;C++程序设计A组试题"></a>六、十三届C&#x2F;C++程序设计A组试题</h2><h2 id="七、十二届C-C-程序设计C组试题"><a href="#七、十二届C-C-程序设计C组试题" class="headerlink" title="七、十二届C&#x2F;C++程序设计C组试题"></a>七、十二届C&#x2F;C++程序设计C组试题</h2><h2 id="八、十二届C-C-程序设计B组试题"><a href="#八、十二届C-C-程序设计B组试题" class="headerlink" title="八、十二届C&#x2F;C++程序设计B组试题"></a>八、十二届C&#x2F;C++程序设计B组试题</h2><h2 id="九、十二届C-C-程序设计A组试题"><a href="#九、十二届C-C-程序设计A组试题" class="headerlink" title="九、十二届C&#x2F;C++程序设计A组试题"></a>九、十二届C&#x2F;C++程序设计A组试题</h2><h2 id="十、十一届C-C-程序设计C组试题"><a href="#十、十一届C-C-程序设计C组试题" class="headerlink" title="十、十一届C&#x2F;C++程序设计C组试题"></a>十、十一届C&#x2F;C++程序设计C组试题</h2><blockquote><p>版权声明：本文为博主<a href="https://blog.csdn.net/weixin_56641478">作者：慢了半拍i</a>原创文章，版权归属原作者，如果侵权，请联系我们删除！</p><p>原文链接：<a href="https://blog.csdn.net/weixin_56641478/article/details/135726057">https://blog.csdn.net/weixin_56641478/article/details/135726057</a></p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>转载</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-实验三</title>
    <link href="/2024/02/05/%E5%AE%9E%E9%AA%8C%E4%B8%89/"/>
    <url>/2024/02/05/%E5%AE%9E%E9%AA%8C%E4%B8%89/</url>
    
    <content type="html"><![CDATA[<blockquote><h1 id="实验三"><a href="#实验三" class="headerlink" title="实验三"></a>实验三</h1><p>[TOC]</p></blockquote><h3 id="3-1栈的顺序存储结构"><a href="#3-1栈的顺序存储结构" class="headerlink" title="3.1栈的顺序存储结构"></a>3.1栈的顺序存储结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 定义顺序栈的最大大小</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 5</span><br><br><span class="hljs-comment">// 定义顺序栈</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">int</span> data[MAXSIZE];<br>    <span class="hljs-type">int</span> top;<br>&#125; SqStack;<br><br><span class="hljs-comment">// 初始化顺序栈</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitStack</span><span class="hljs-params">(SqStack&amp; S)</span> </span>&#123;<br>    S.top = <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">// 判断顺序栈是否为空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">(SqStack S)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> S.top == <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">// 判断顺序栈是否已满</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsFull</span><span class="hljs-params">(SqStack S)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> S.top == MAXSIZE - <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 入栈操作</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Push</span><span class="hljs-params">(SqStack&amp; S, <span class="hljs-type">int</span> elem)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsFull</span>(S)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;栈已满，无法入栈。&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    S.data[++S.top] = elem;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 出栈操作</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Pop</span><span class="hljs-params">(SqStack&amp; S, <span class="hljs-type">int</span>&amp; elem)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsEmpty</span>(S)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;栈为空，无法出栈。&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    elem = S.data[S.top--];<br>    cout &lt;&lt; <span class="hljs-string">&quot;出栈元素：&quot;</span> &lt;&lt; elem &lt;&lt; <span class="hljs-string">&quot;，当前栈顶指针：&quot;</span> &lt;&lt; S.top &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 获取顺序栈栈顶元素</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetTop</span><span class="hljs-params">(SqStack S, <span class="hljs-type">int</span>&amp; elem)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsEmpty</span>(S)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;栈为空，无法获取栈顶元素。&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    elem = S.data[S.top];<br>    cout &lt;&lt; <span class="hljs-string">&quot;栈顶元素为：&quot;</span> &lt;&lt; elem &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 显示菜单</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DisplayMenu</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;===============菜单===============&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;1. 建栈&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;2. 取栈顶元素&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;3. 入栈&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;4. 出栈&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;5. 退出&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;===================================&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;请选择操作：&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 顺序栈</span><br>    SqStack sqStack;<br>    <span class="hljs-built_in">InitStack</span>(sqStack);<br><br>    <span class="hljs-type">int</span> choice;<br>    <span class="hljs-type">int</span> elem;<br><br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-built_in">DisplayMenu</span>();<br>        cin &gt;&gt; choice;<br><br>        <span class="hljs-keyword">switch</span> (choice) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            <span class="hljs-built_in">InitStack</span>(sqStack);<br>            cout &lt;&lt; <span class="hljs-string">&quot;建栈成功。&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-built_in">GetTop</span>(sqStack, elem);<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>            cout &lt;&lt; <span class="hljs-string">&quot;请输入要入栈的元素（以-1结束）：&quot;</span>;<br>            cout &lt;&lt; <span class="hljs-string">&quot;入栈元素：&quot;</span>;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                cin &gt;&gt; elem;<br><br>                <span class="hljs-keyword">if</span> (elem == <span class="hljs-number">-1</span>) &#123;<br>                    cout &lt;&lt; <span class="hljs-string">&quot;入栈结束。&quot;</span> &lt;&lt; endl;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Push</span>(sqStack, elem)) &#123;<br>                    cout&lt;&lt; elem &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>                cout &lt;&lt; <span class="hljs-string">&quot;当前栈顶指针：&quot;</span> &lt;&lt; sqStack.top &lt;&lt; endl;<br>         <br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:  <span class="hljs-built_in">Pop</span>(sqStack, elem);<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>            cout &lt;&lt; <span class="hljs-string">&quot;程序退出。&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">default</span>:<br>            cout &lt;&lt; <span class="hljs-string">&quot;无效的选择，请重新输入。&quot;</span> &lt;&lt; endl;<br>        &#125;<br><br>    &#125; <span class="hljs-keyword">while</span> (choice != <span class="hljs-number">5</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-2栈的链式存储"><a href="#3-2栈的链式存储" class="headerlink" title="3.2栈的链式存储"></a>3.2栈的链式存储</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 定义链表节点</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> data;<br>    Node* next;<br>&#125;;<br><br><span class="hljs-comment">// 定义链式栈</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    Node* top;<br>&#125; LinkedStack;<br><br><span class="hljs-comment">// 初始化链式栈</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitStack</span><span class="hljs-params">(LinkedStack&amp; S)</span> </span>&#123;<br>    S.top = <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-comment">// 判断链式栈是否为空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">(LinkedStack S)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> S.top == <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-comment">// 入栈操作</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Push</span><span class="hljs-params">(LinkedStack&amp; S, <span class="hljs-type">int</span> elem)</span> </span>&#123;<br>    Node* newNode = <span class="hljs-keyword">new</span> Node;<br>    newNode-&gt;data = elem;<br>    newNode-&gt;next = S.top;<br>    S.top = newNode;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 出栈操作</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Pop</span><span class="hljs-params">(LinkedStack&amp; S, <span class="hljs-type">int</span>&amp; elem)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsEmpty</span>(S)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;栈为空，无法出栈。&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    Node* temp = S.top;<br>    elem = temp-&gt;data;<br>    S.top = temp-&gt;next;<br>    <span class="hljs-keyword">delete</span> temp;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;出栈元素：&quot;</span> &lt;&lt; elem &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 获取链式栈栈顶元素</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetTop</span><span class="hljs-params">(LinkedStack S, <span class="hljs-type">int</span>&amp; elem)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsEmpty</span>(S)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;栈为空，无法获取栈顶元素。&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    elem = S.top-&gt;data;<br>    cout &lt;&lt; <span class="hljs-string">&quot;栈顶元素为：&quot;</span> &lt;&lt; elem &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 显示菜单</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DisplayMenu</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;===============菜单===============&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;1. 建栈&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;2. 取栈顶元素&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;3. 入栈&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;4. 出栈&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;5. 退出&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;===================================&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;请选择操作：&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 链式栈</span><br>    LinkedStack linkedStack;<br>    <span class="hljs-built_in">InitStack</span>(linkedStack);<br><br>    <span class="hljs-type">int</span> choice;<br>    <span class="hljs-type">int</span> elem;<br><br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-built_in">DisplayMenu</span>();<br>        cin &gt;&gt; choice;<br><br>        <span class="hljs-keyword">switch</span> (choice) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            <span class="hljs-built_in">InitStack</span>(linkedStack);<br>            cout &lt;&lt; <span class="hljs-string">&quot;建栈成功。&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            <span class="hljs-built_in">GetTop</span>(linkedStack, elem);<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>            cout &lt;&lt; <span class="hljs-string">&quot;请输入要入栈的元素（以-1结束）：&quot;</span>;<br>            cout &lt;&lt; <span class="hljs-string">&quot;入栈元素：&quot;</span>;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                cin &gt;&gt; elem;<br><br>                <span class="hljs-keyword">if</span> (elem == <span class="hljs-number">-1</span>) &#123;<br>                    cout &lt;&lt; <span class="hljs-string">&quot;入栈结束。&quot;</span> &lt;&lt; endl;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Push</span>(linkedStack, elem)) &#123;<br>                    cout &lt;&lt; elem &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            cout &lt;&lt; endl;<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>            <span class="hljs-built_in">Pop</span>(linkedStack, elem);<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>            cout &lt;&lt; <span class="hljs-string">&quot;程序退出。&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">default</span>:<br>            cout &lt;&lt; <span class="hljs-string">&quot;无效的选择，请重新输入。&quot;</span> &lt;&lt; endl;<br>        &#125;<br><br>    &#125; <span class="hljs-keyword">while</span> (choice != <span class="hljs-number">5</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-3队列的链式存储"><a href="#3-3队列的链式存储" class="headerlink" title="3.3队列的链式存储"></a>3.3队列的链式存储</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 定义循环队列的最大大小</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 6</span><br><br><span class="hljs-comment">// 定义循环队列</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">int</span> data[MAXSIZE];<br>    <span class="hljs-type">int</span> front;<br>    <span class="hljs-type">int</span> rear;<br>&#125; CircularQueue;<br><br><span class="hljs-comment">// 初始化循环队列</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitQueue</span><span class="hljs-params">(CircularQueue&amp; Q)</span> </span>&#123;<br>    Q.front = Q.rear = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 判断循环队列是否为空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">(CircularQueue Q)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Q.front == Q.rear;<br>&#125;<br><br><span class="hljs-comment">// 判断循环队列是否已满</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsFull</span><span class="hljs-params">(CircularQueue Q)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (Q.rear + <span class="hljs-number">1</span>) % MAXSIZE == Q.front;<br>&#125;<br><br><span class="hljs-comment">// 入队操作</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Enqueue</span><span class="hljs-params">(CircularQueue&amp; Q, <span class="hljs-type">int</span> elem)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsFull</span>(Q)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;队列已满，无法入队。&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>   Q.data[Q.rear] = elem;<br>   Q.rear = (Q.rear + <span class="hljs-number">1</span>) % MAXSIZE; <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 出队操作</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Dequeue</span><span class="hljs-params">(CircularQueue&amp; Q, <span class="hljs-type">int</span>&amp; elem)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsEmpty</span>(Q)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;队列为空，无法出队。&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    elem = Q.data[Q.front];<br>    Q.front = (Q.front + <span class="hljs-number">1</span>) % MAXSIZE;<br>   <br><br>    cout &lt;&lt; <span class="hljs-string">&quot;出队元素：&quot;</span> &lt;&lt; elem &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 获取队头元素</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetFront</span><span class="hljs-params">(CircularQueue Q, <span class="hljs-type">int</span>&amp; elem)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsEmpty</span>(Q)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;队列为空，无法获取队头元素。&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    elem = Q.data[Q.front];<br>    cout &lt;&lt; <span class="hljs-string">&quot;队头元素为：&quot;</span> &lt;&lt; elem &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 显示菜单</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DisplayMenu</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;===============菜单===============&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;1. 建队列&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;2. 取队头元素&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;3. 入队&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;4. 出队&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;5. 退出&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;===================================&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;请选择操作：&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 循环队列</span><br>    CircularQueue circularQueue;<br>    <span class="hljs-built_in">InitQueue</span>(circularQueue);<br><br>    <span class="hljs-type">int</span> choice;<br>    <span class="hljs-type">int</span> elem;<br><br>    <span class="hljs-keyword">do</span> &#123;  <br>        <span class="hljs-built_in">DisplayMenu</span>();<br>        cin &gt;&gt; choice;<br><br>        <span class="hljs-keyword">switch</span> (choice) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            <span class="hljs-built_in">InitQueue</span>(circularQueue);<br>            cout &lt;&lt; <span class="hljs-string">&quot;建队列成功。&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            <span class="hljs-built_in">GetFront</span>(circularQueue, elem);<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>            cout &lt;&lt; <span class="hljs-string">&quot;请输入要入队的元素（以-1结束）：&quot;</span>;<br>            cout &lt;&lt; <span class="hljs-string">&quot;入队元素：&quot;</span>;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                cin &gt;&gt; elem;<br><br>                <span class="hljs-keyword">if</span> (elem == <span class="hljs-number">-1</span>) &#123;<br>                    cout &lt;&lt; <span class="hljs-string">&quot;入队结束。&quot;</span> &lt;&lt; endl;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Enqueue</span>(circularQueue, elem)) &#123;<br>                    cout &lt;&lt; elem &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            cout &lt;&lt; endl;<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>            <span class="hljs-built_in">Dequeue</span>(circularQueue, elem);<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>            cout &lt;&lt; <span class="hljs-string">&quot;程序退出。&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">default</span>:<br>            cout &lt;&lt; <span class="hljs-string">&quot;无效的选择，请重新输入。&quot;</span> &lt;&lt; endl;<br>        &#125;<br><br>    &#125; <span class="hljs-keyword">while</span> (choice != <span class="hljs-number">5</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-4队列的链式存储"><a href="#3-4队列的链式存储" class="headerlink" title="3.4队列的链式存储"></a>3.4队列的链式存储</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 定义链表节点</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> data;<br>    Node* next;<br>&#125;;<br><br><span class="hljs-comment">// 定义链式队列</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    Node* front;<br>    Node* rear;<br>&#125; LinkedQueue;<br><br><span class="hljs-comment">// 初始化链式队列</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InitQueue</span><span class="hljs-params">(LinkedQueue&amp; Q)</span> </span>&#123;<br>    Q.front = Q.rear = <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-comment">// 判断链式队列是否为空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">(LinkedQueue Q)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Q.front == <span class="hljs-literal">nullptr</span>;<br>&#125;<br><br><span class="hljs-comment">// 入队操作</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Enqueue</span><span class="hljs-params">(LinkedQueue&amp; Q, <span class="hljs-type">int</span> elem)</span> </span>&#123;<br>    Node* newNode = <span class="hljs-keyword">new</span> Node;<br>    newNode-&gt;data = elem;<br>    newNode-&gt;next = <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsEmpty</span>(Q)) &#123;<br>        Q.front = Q.rear = newNode;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        Q.rear-&gt;next = newNode;<br>        Q.rear = newNode;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 出队操作</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Dequeue</span><span class="hljs-params">(LinkedQueue&amp; Q, <span class="hljs-type">int</span>&amp; elem)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsEmpty</span>(Q)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;队列为空，无法出队。&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    Node* temp = Q.front;<br>    elem = temp-&gt;data;<br><br>    Q.front = temp-&gt;next;<br>    <span class="hljs-keyword">delete</span> temp;<br><br>    <span class="hljs-keyword">if</span> (Q.front == <span class="hljs-literal">nullptr</span>) &#123;<br>        Q.rear = <span class="hljs-literal">nullptr</span>; <br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;出队元素：&quot;</span> &lt;&lt; elem &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 获取队头元素</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">GetFront</span><span class="hljs-params">(LinkedQueue Q, <span class="hljs-type">int</span>&amp; elem)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsEmpty</span>(Q)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;队列为空，无法获取队头元素。&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    elem = Q.front-&gt;data;<br>    cout &lt;&lt; <span class="hljs-string">&quot;队头元素为：&quot;</span> &lt;&lt; elem &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 显示菜单</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DisplayMenu</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;===============菜单===============&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;1. 建队列&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;2. 取队头元素&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;3. 入队&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;4. 出队&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;5. 退出&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;===================================&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;请选择操作：&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 链式队列</span><br>    LinkedQueue linkedQueue;<br>    <span class="hljs-built_in">InitQueue</span>(linkedQueue);<br><br>    <span class="hljs-type">int</span> choice;<br>    <span class="hljs-type">int</span> elem;<br><br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-built_in">DisplayMenu</span>();<br>        cin &gt;&gt; choice;<br><br>        <span class="hljs-keyword">switch</span> (choice) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            <span class="hljs-built_in">InitQueue</span>(linkedQueue);<br>            cout &lt;&lt; <span class="hljs-string">&quot;建队列成功。&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            <span class="hljs-built_in">GetFront</span>(linkedQueue, elem);<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>            cout &lt;&lt; <span class="hljs-string">&quot;请输入要入队的元素（以-1结束）：&quot;</span>;<br>            cout &lt;&lt; <span class="hljs-string">&quot;入队元素：&quot;</span>;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                cin &gt;&gt; elem;<br><br>                <span class="hljs-keyword">if</span> (elem == <span class="hljs-number">-1</span>) &#123;<br>                    cout &lt;&lt; <span class="hljs-string">&quot;入队结束。&quot;</span> &lt;&lt; endl;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Enqueue</span>(linkedQueue, elem)) &#123;<br>                    cout &lt;&lt; elem &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            cout &lt;&lt; endl;<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>            <span class="hljs-built_in">Dequeue</span>(linkedQueue, elem);<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>            cout &lt;&lt; <span class="hljs-string">&quot;程序退出。&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">default</span>:<br>            cout &lt;&lt; <span class="hljs-string">&quot;无效的选择，请重新输入。&quot;</span> &lt;&lt; endl;<br>        &#125;<br><br>    &#125; <span class="hljs-keyword">while</span> (choice != <span class="hljs-number">5</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-实验四</title>
    <link href="/2024/02/05/%E5%AE%9E%E9%AA%8C%E5%9B%9B%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%888%E5%AD%A6%E6%97%B6%EF%BC%89/"/>
    <url>/2024/02/05/%E5%AE%9E%E9%AA%8C%E5%9B%9B%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%888%E5%AD%A6%E6%97%B6%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="实验四-二叉树的操作"><a href="#实验四-二叉树的操作" class="headerlink" title="实验四 二叉树的操作"></a>实验四 二叉树的操作</h1><h1 id="（8学时）"><a href="#（8学时）" class="headerlink" title="（8学时）"></a>（8学时）</h1><ol><li><strong>实验性质</strong>：</li></ol><p>综合性实验</p><p>2．要求：</p><p>（1）掌握二叉树的二叉链表存储方式及二叉树的特征；</p><p>（2）验证二叉树在二叉链表存储结构下遍历操作的实现；</p><p>（3）掌握哈夫曼树的构造方法和哈夫曼编码的方法。</p><p>3.实验目的</p><p>通过该实验，可以熟练掌握二叉树的存储方式、遍历操作实现及构造赫夫曼树和哈夫曼编码的方法。</p><p>4.实验内容</p><p>（1）采用二叉链表结构建立二叉树；</p><p>（2）编程实现二叉树的先序、中序、后序和层序遍历；</p><p>（3）编程实现：求二叉树的高度和叶子结点个数；</p><p>（4）应用实现：哈夫曼编码。</p><p>5.验收&#x2F;测试用例</p><ul><li>构造二叉链表表示下列表达式(算法5.3)，红色十字为根节点</li></ul><blockquote><p>中序遍历 ：a-b*c&#x2F;(d+e*f)+g*(h+i)</p></blockquote><ul><li>实现上述二叉链表的先序、中序、后序遍历，输入相应的先序序列、中序序列、后序序列。</li></ul><p>例如： 输入</p><blockquote><p> +-a##*b##&#x2F;c##+d##*e##f##*g##+h##i##</p></blockquote><p>输出</p><p>“先序序列： +-a*b&#x2F;c+d*ef*g+hi”</p><ul><li><p>编程实现，输出上述二叉树的高度和叶子结点个数；</p></li><li><p>设有正文AADBAACACCDACACAADBBCD，编程统计字符集A,B,C,D的出现,次数。设计一套Huffman编码，使得上述正文的编码最短，并且计算它的带权路径长度。</p><p>A(9次）B（3次）C（6次）D（4次）</p><h3 id="二叉树结构"><a href="#二叉树结构" class="headerlink" title="二叉树结构"></a>二叉树结构</h3></li></ul><pre><code class=" mermaid">graph TD    plus(&quot;+&quot;) --&gt; minus(&quot;-&quot;)    minus --&gt; a(&quot;a&quot;)    minus --&gt; multiply(&quot;*&quot;)    multiply --&gt; b(&quot;b&quot;)    multiply --&gt; divide(&quot;/&quot;)    divide --&gt; c(&quot;c&quot;)    plus --&gt; multiply2(&quot;*&quot;)    multiply2 --&gt; g(&quot;g&quot;)    multiply2 --&gt; plus2(&quot;+&quot;)    plus2 --&gt; h(&quot;h&quot;)    plus2 --&gt; i(&quot;i&quot;)    divide --&gt; plus3(&quot;+&quot;)    plus3 --&gt; d(&quot;d&quot;)    plus3 --&gt; multiply3(&quot;*&quot;)    multiply3 --&gt; e(&quot;e&quot;)    multiply3 --&gt; f(&quot;f&quot;)</code></pre><h3 id="哈夫曼树结构"><a href="#哈夫曼树结构" class="headerlink" title="哈夫曼树结构"></a>哈夫曼树结构</h3><pre><code class=" mermaid">graph TD  22((&quot;22&quot;)) --&gt;|0| A((&quot;A&quot;))  22((&quot;22&quot;)) ---&gt;|1| 13((&quot;13&quot;))  13 --&gt;|0| C((&quot;C&quot;))  13 ---&gt;|1| 7((&quot;7&quot;))  7 --&gt;|0| B((&quot;B&quot;))  7 ---&gt;|1| D((&quot;D&quot;))</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-实验一</title>
    <link href="/2024/02/05/%E5%AE%9E%E9%AA%8C%E4%B8%80/"/>
    <url>/2024/02/05/%E5%AE%9E%E9%AA%8C%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<blockquote><h1 id="实验一"><a href="#实验一" class="headerlink" title="实验一"></a>实验一</h1></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ok 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> <span class="hljs-keyword">error</span> 0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> maxsize 100</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> overflow -2</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> status;<br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Elemtype; <br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    Elemtype* elem;<br>    <span class="hljs-type">int</span> length;<br>&#125; sqlist;<br><span class="hljs-comment">//初始化线性表</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">initlist</span><span class="hljs-params">(sqlist&amp; l)</span> </span>&#123;<br>    l.elem = <span class="hljs-keyword">new</span> Elemtype[maxsize];<br>    <span class="hljs-keyword">if</span> (!l.elem) <span class="hljs-built_in">exit</span>(overflow);<br>    l.length = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> ok;<br>&#125;<br><span class="hljs-comment">//1.清空线性表</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">clearlist</span><span class="hljs-params">(sqlist&amp; l)</span></span><br><span class="hljs-function"></span>&#123;<br>    l.length = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">delete</span>[] l.elem;<br>    cout &lt;&lt; <span class="hljs-string">&quot;已清空线性表&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> ok;<br>&#125;<br><span class="hljs-comment">//2.判断线性表是否为空</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">isempty</span><span class="hljs-params">(sqlist&amp; l)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l.length == <span class="hljs-number">0</span>) cout &lt;&lt; <span class="hljs-string">&quot;线性表为空&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;线性表不为空&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> ok;<br>&#125;<br><span class="hljs-comment">//3. 求线性表的长度</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">qqlength</span><span class="hljs-params">(sqlist l)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;线性表长度为: &quot;</span> &lt;&lt; l.length &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> ok;<br>&#125;<br><span class="hljs-comment">//4. 获取线性表指定位置元素</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getelem</span><span class="hljs-params">(sqlist l, Elemtype&amp; e)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;请输入查询的位置：&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-type">int</span> i;<br>    cin &gt;&gt; i;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">1</span> || i &gt; l.length) <br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;输入位置错误&quot;</span> &lt;&lt; endl; <span class="hljs-keyword">return</span> error;<br>    &#125;<br>    e = l.elem[i - <span class="hljs-number">1</span>];<br>    cout &lt;&lt; <span class="hljs-string">&quot;第&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;个元素为: &quot;</span> &lt;&lt; e &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> ok;<br>&#125;<br><span class="hljs-comment">//5. 求前驱</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">qqqmqu</span><span class="hljs-params">(sqlist l)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    cout &lt;&lt; <span class="hljs-string">&quot;求第几个元素的前驱&quot;</span> &lt;&lt; endl;<br>    cin &gt;&gt; i;<br>    <span class="hljs-keyword">if</span> (i &lt;= <span class="hljs-number">1</span> || i &gt; l.length)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;输入数字错误&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; i - <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; l.elem[i - <span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl;<br><br>&#125;<br><span class="hljs-comment">//6. 求后继</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">qqhzji</span><span class="hljs-params">(sqlist l)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    cout &lt;&lt; <span class="hljs-string">&quot;求第几个元素的后继&quot;</span> &lt;&lt; endl;<br>    cin &gt;&gt; i;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">1</span> || i &gt;= l.length) &#123; cout &lt;&lt; <span class="hljs-string">&quot;输入错误&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; i+<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; l.elem[i] &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl;<br><br>&#125;<br><span class="hljs-comment">//7.在线性表内插入元素</span><br><span class="hljs-function">status <span class="hljs-title">listinsert</span><span class="hljs-params">(sqlist&amp; l, <span class="hljs-type">int</span> i, Elemtype e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> j;<br>    <span class="hljs-keyword">if</span> (l.length == maxsize) <br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;线性表已满&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> error; <br>    &#125;<br>    <span class="hljs-keyword">if</span> (i&lt;<span class="hljs-number">1</span> || i&gt;l.length + <span class="hljs-number">1</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;插入位置错误&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span> error;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">1</span> &amp;&amp; i &lt;= l.length + <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (j = l.length - <span class="hljs-number">1</span>; j &gt;= i - <span class="hljs-number">1</span>; j--)<br>        &#123;<br>            l.elem[j + <span class="hljs-number">1</span>] = l.elem[j];<br>        &#125;<br><br>        l.elem[i - <span class="hljs-number">1</span>] = e;<br>        l.length++;<br>        <span class="hljs-keyword">return</span> ok;<br>    &#125;<br>    <span class="hljs-keyword">return</span> error;<br>&#125;<br><span class="hljs-comment">//8.在线性表里删除元素</span><br><span class="hljs-function">status <span class="hljs-title">listdelete</span><span class="hljs-params">(sqlist&amp; l, <span class="hljs-type">int</span> i, Elemtype&amp; e)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> j;<br>    <span class="hljs-keyword">if</span> (l.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> error;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">1</span> || i &gt; l.length) <span class="hljs-keyword">return</span> error;<br>    <span class="hljs-keyword">else</span> &#123;<br>        e = l.elem[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>; j &lt; l.length - <span class="hljs-number">1</span>; j++)<br>            l.elem[j] = l.elem[j + <span class="hljs-number">1</span>];<br>    &#125;<br>    l.length--;<br>    <span class="hljs-keyword">return</span> ok;<br>&#125;<br><span class="hljs-comment">//9.显示线性表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">output</span><span class="hljs-params">(sqlist&amp; l)</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;线性表中的元素为: &quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; l.length; i++) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; i + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; l.elem[i] &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    sqlist l; <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">initlist</span>(l);<br>    Elemtype e = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> select = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;1. 清空顺序表&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;2. 判断线性表是否为空&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;3. 求线性表的长度&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;4. 获取线性表指定位置元素&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;5. 求前驱&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;6. 求后继&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;7. 在线性表指定位置插入元素&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;8.删除线性表指定位置元素 &quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;9.显示线性表&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;    退出，输入一个负数&quot;</span> &lt;&lt; endl;<br>        cin &gt;&gt; select;<br><br>        <span class="hljs-keyword">switch</span> (select) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        &#123; <span class="hljs-built_in">clearlist</span>(l);<br>        <span class="hljs-keyword">break</span>; &#125;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            <span class="hljs-built_in">isempty</span>(l);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>            <span class="hljs-built_in">qqlength</span>(l);<br>            <span class="hljs-keyword">break</span>;<br><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>            <span class="hljs-built_in">getelem</span>(l, e);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>            <span class="hljs-built_in">qqqmqu</span>(l);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>            <span class="hljs-built_in">qqhzji</span>(l);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<br>        &#123;<br>            <span class="hljs-type">int</span> n; <span class="hljs-comment">// 连续插入的元素数量</span><br>            cout &lt;&lt; <span class="hljs-string">&quot;请输入要连续插入的元素数量: &quot;</span>;<br>            cin &gt;&gt; n;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                <span class="hljs-type">int</span> e, i;<br>                cout &lt;&lt; <span class="hljs-string">&quot;请输入插入的位置和元素: &quot;</span>;<br>                cin &gt;&gt; i &gt;&gt; e;<br>                <span class="hljs-built_in">listinsert</span>(l, i, e); <br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">8</span>: &#123;<br>            <span class="hljs-type">int</span> i, e;<br>            cout &lt;&lt; <span class="hljs-string">&quot;请输入要删除的位置: &quot;</span>;<br>            cin &gt;&gt; i;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">listdelete</span>(l, i, e) == ok)<br>                cout &lt;&lt; <span class="hljs-string">&quot;删除成功, 删除的元素为: &quot;</span> &lt;&lt; e &lt;&lt; endl;<br>            <span class="hljs-keyword">else</span><br>                cout &lt;&lt; <span class="hljs-string">&quot;删除失败&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">9</span>:<br>            <span class="hljs-built_in">output</span>(l);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构-实验二</title>
    <link href="/2024/02/05/%E5%AE%9E%E9%AA%8C%E4%BA%8C/"/>
    <url>/2024/02/05/%E5%AE%9E%E9%AA%8C%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<blockquote><h1 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h1></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">// 单链表节点结构</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> data;<br>    Node* next;<br>&#125;;<br><br><span class="hljs-comment">// 创建一个新节点</span><br><span class="hljs-function">Node* <span class="hljs-title">createNode</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>    Node* newNode = <span class="hljs-keyword">new</span> Node;<br>    newNode-&gt;data = value;<br>    newNode-&gt;next = <span class="hljs-literal">nullptr</span>;<br>    <span class="hljs-keyword">return</span> newNode;<br>&#125;<br><br><span class="hljs-comment">// 插入节点到单链表尾部</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertNodeAtEnd</span><span class="hljs-params">(Node*&amp; head, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>    Node* newNode = <span class="hljs-built_in">createNode</span>(value);<br><br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) &#123;<br>        head = newNode;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        Node* current = head;<br>        <span class="hljs-keyword">while</span> (current-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br>            current = current-&gt;next;<br>        &#125;<br>        current-&gt;next = newNode;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 查找节点在单链表中的位置</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">findNodePosition</span><span class="hljs-params">(Node* head, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>    <span class="hljs-type">int</span> position = <span class="hljs-number">1</span>;<br>    Node* current = head;<br>    <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">if</span> (current-&gt;data == value) &#123;<br>            <span class="hljs-keyword">return</span> position;<br>        &#125;<br>        current = current-&gt;next;<br>        position++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;  <span class="hljs-comment">// 未找到</span><br>&#125;<br><br><span class="hljs-comment">// 删除节点在单链表中的位置</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">deleteNodeAtPosition</span><span class="hljs-params">(Node*&amp; head, <span class="hljs-type">int</span> position)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (position &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 无效的位置</span><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (position == <span class="hljs-number">1</span>) &#123;<br>        Node* temp = head;<br>        head = head-&gt;next;<br>        <span class="hljs-keyword">delete</span> temp;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    Node* current = head;<br>    <span class="hljs-type">int</span> currentPosition = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (currentPosition &lt; position - <span class="hljs-number">1</span> &amp;&amp; current != <span class="hljs-literal">nullptr</span>) &#123;<br>        current = current-&gt;next;<br>        currentPosition++;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (current == <span class="hljs-literal">nullptr</span> || current-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 位置超出链表长度</span><br>    &#125;<br><br>    Node* temp = current-&gt;next;<br>    current-&gt;next = current-&gt;next-&gt;next;<br>    <span class="hljs-keyword">delete</span> temp;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 合并两个有序单链表</span><br><span class="hljs-function">Node* <span class="hljs-title">mergeSortedLists</span><span class="hljs-params">(Node* list1, Node* list2)</span> </span>&#123;<br>    Node* mergedList = <span class="hljs-literal">nullptr</span>;<br>    Node* current = mergedList;<br><br>    <span class="hljs-keyword">while</span> (list1 != <span class="hljs-literal">nullptr</span> &amp;&amp; list2 != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">if</span> (list1-&gt;data &lt; list2-&gt;data) &#123;<br>            <span class="hljs-built_in">insertNodeAtEnd</span>(current, list1-&gt;data);<br>            list1 = list1-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">insertNodeAtEnd</span>(current, list2-&gt;data);<br>            list2 = list2-&gt;next;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (mergedList == <span class="hljs-literal">nullptr</span>) &#123;<br>            mergedList = current;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理剩余的元素</span><br>    <span class="hljs-keyword">while</span> (list1 != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-built_in">insertNodeAtEnd</span>(current, list1-&gt;data);<br>        list1 = list1-&gt;next;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (list2 != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-built_in">insertNodeAtEnd</span>(current, list2-&gt;data);<br>        list2 = list2-&gt;next;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> mergedList;<br>&#125;<br><br><span class="hljs-comment">// 打印单链表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printList</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>    Node* current = head;<br>    <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span>) &#123;<br>        cout &lt;&lt; current-&gt;data &lt;&lt; <span class="hljs-string">&quot; -&gt; &quot;</span>;<br>        current = current-&gt;next;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;nullptr&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Node* list1 = <span class="hljs-literal">nullptr</span>;<br>    Node* list2 = <span class="hljs-literal">nullptr</span>;<br><br>    <span class="hljs-comment">// 建立单链表</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>        <span class="hljs-built_in">insertNodeAtEnd</span>(list1, i * <span class="hljs-number">2</span>);<br>        <span class="hljs-built_in">insertNodeAtEnd</span>(list2, i * <span class="hljs-number">2</span> - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;List 1: &quot;</span>;<br>    <span class="hljs-built_in">printList</span>(list1);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;List 2: &quot;</span>;<br>    <span class="hljs-built_in">printList</span>(list2);<br><br>    <span class="hljs-comment">// 合并有序单链表</span><br>    Node* mergedList = <span class="hljs-built_in">mergeSortedLists</span>(list1, list2);<br><br>    cout &lt;&lt; <span class="hljs-string">&quot;Merged List: &quot;</span>;<br>    <span class="hljs-built_in">printList</span>(mergedList);<br><br>    <span class="hljs-comment">// 查找节点位置</span><br>    <span class="hljs-type">int</span> searchValue = <span class="hljs-number">6</span>;<br>    <span class="hljs-type">int</span> position = <span class="hljs-built_in">findNodePosition</span>(mergedList, searchValue);<br>    <span class="hljs-keyword">if</span> (position != <span class="hljs-number">-1</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Found &quot;</span> &lt;&lt; searchValue &lt;&lt; <span class="hljs-string">&quot; at position &quot;</span> &lt;&lt; position &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; searchValue &lt;&lt; <span class="hljs-string">&quot; not found in the merged list.&quot;</span> &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 删除节点</span><br>    <span class="hljs-type">int</span> deletePosition = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">deleteNodeAtPosition</span>(mergedList, deletePosition)) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Deleted node at position &quot;</span> &lt;&lt; deletePosition &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Updated List: &quot;</span>;<br>        <span class="hljs-built_in">printList</span>(mergedList);<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Unable to delete node at position &quot;</span> &lt;&lt; deletePosition &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 释放内存</span><br>    <span class="hljs-keyword">while</span> (mergedList != <span class="hljs-literal">nullptr</span>) &#123;<br>        Node* temp = mergedList;<br>        mergedList = mergedList-&gt;next;<br>        <span class="hljs-keyword">delete</span> temp;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>数据结构实验</title>
    <link href="/2024/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C/"/>
    <url>/2024/02/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<blockquote><h1 id="数据结构实验-test"><a href="#数据结构实验-test" class="headerlink" title="数据结构实验 test"></a>数据结构实验 test</h1><p>[TOC]</p></blockquote><h2 id="一、实验一"><a href="#一、实验一" class="headerlink" title="一、实验一"></a><a href="http://htmlpreview.github.io/?https://github.com/yanhuigang173/markdown-xtxi/blob/main/typora/uiyjyi.html">一、实验一</a></h2><h3 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h3><ul><li><p>编程实现顺序表的以下基本操作：建立顺序表，修改顺序表，插入顺序表，删除顺序表。</p></li><li><p>采用顺序表结构编程实现：两个集合的运算：交集&#x2F;并集&#x2F;差集。</p></li></ul><h2 id="二、实验二"><a href="#二、实验二" class="headerlink" title="二、实验二"></a><a href="http://htmlpreview.github.io/?https://github.com/yanhuigang173/markdown-xtxi/blob/main/typora/uiyjer.html">二、实验二</a></h2><h3 id="链式表"><a href="#链式表" class="headerlink" title="链式表"></a>链式表</h3><ul><li><p>掌握线性表的链式存储结构；</p></li><li><p>掌握单链表及其基本操作的实现。</p></li></ul><h2 id="三、实验三"><a href="#三、实验三" class="headerlink" title="三、实验三"></a><a href="http://htmlpreview.github.io/?https://github.com/yanhuigang173/markdown-xtxi/blob/main/typora/uiyjsj.html">三、实验三</a></h2><ul><li>掌握栈的顺序存储结构、链式存储结构及其基本操作；</li><li>掌握队列的顺序存储结构、链式存储结构及其基本操作。</li></ul><h2 id="四、实验四"><a href="#四、实验四" class="headerlink" title="四、实验四"></a><a href="lmjp">四、实验四</a></h2><ul><li><p>掌握二叉树的二叉链表存储方式及二叉树的特征；</p></li><li><p>验证二叉树在二叉链表存储结构下遍历操作的实现；</p></li><li><p>掌握哈夫曼树的构造方法和哈夫曼编码的方法。</p></li></ul><h2 id="五、实验五"><a href="#五、实验五" class="headerlink" title="五、实验五"></a><a href="lmjp">五、实验五</a></h2><h3 id="图的操作（6学时）"><a href="#图的操作（6学时）" class="headerlink" title="图的操作（6学时）"></a>图的操作（6学时）</h3><ul><li><p>采用邻接矩阵&#x2F;邻接表建立图；</p></li><li><p>采用深度优先&#x2F;广度优先搜索方式遍历图；</p></li><li><p>编程实现Dijkstra最短路径算法。暂无</p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
